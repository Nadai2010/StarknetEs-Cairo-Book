<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>¿Qué es Ownership? - El lenguaje de programación Cairo </title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">El lenguaje de programación Cairo</a></li><li class="chapter-item expanded affix "><a href="ch00-01-foreword.html">Prólogo</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Introducción</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Cómo empezar</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Instalación</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hola, Mundo!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-scarb.html"><strong aria-hidden="true">1.3.</strong> Hola, Scarb!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-common-programming-concepts.html"><strong aria-hidden="true">2.</strong> Conceptos comunes de programación</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch02-01-variables-and-mutability.html"><strong aria-hidden="true">2.1.</strong> Variables y mutabilidad</a></li><li class="chapter-item expanded "><a href="ch02-02-data-types.html"><strong aria-hidden="true">2.2.</strong> Tipos de datos</a></li><li class="chapter-item expanded "><a href="ch02-03-functions.html"><strong aria-hidden="true">2.3.</strong> Funciones</a></li><li class="chapter-item expanded "><a href="ch02-04-comments.html"><strong aria-hidden="true">2.4.</strong> Comentarios</a></li><li class="chapter-item expanded "><a href="ch02-05-control-flow.html"><strong aria-hidden="true">2.5.</strong> Flujo de contro</a></li></ol></li><li class="chapter-item expanded "><a href="ch03-00-understanding-ownership.html"><strong aria-hidden="true">3.</strong> Comprender Ownership</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-what-is-ownership.html" class="active"><strong aria-hidden="true">3.1.</strong> ¿Qué es Ownership?</a></li><li class="chapter-item expanded "><a href="ch03-02-references-and-snapshots.html"><strong aria-hidden="true">3.2.</strong> Referencias e instantáneas</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-using-structs-to-structure-related-data.html"><strong aria-hidden="true">4.</strong>  Uso de estructuras para estructurar datos relacionados</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-defining-and-instantiating-structs.html"><strong aria-hidden="true">4.1.</strong> Definición e instanciación de estructuras</a></li><li class="chapter-item expanded "><a href="ch04-02-an-example-program-using-structs.html"><strong aria-hidden="true">4.2.</strong> Un programa de ejemplo usando estructuras</a></li><li class="chapter-item expanded "><a href="ch04-03-method-syntax.html"><strong aria-hidden="true">4.3.</strong> Sintaxis de métodos</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-enums-and-pattern-matching.html"><strong aria-hidden="true">5.</strong> Enums y Concordancia de Patrones</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-enums.html"><strong aria-hidden="true">5.1.</strong> Enums</a></li><li class="chapter-item expanded "><a href="ch05-02-the-match-control-flow-construct.html"><strong aria-hidden="true">5.2.</strong> La construcción del flujo de control de coincidencias</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-managing-cairo-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">6.</strong> Gestionando Proyectos Cairo con Paquetes, Crates y Módulos</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-packages-and-crates.html"><strong aria-hidden="true">6.1.</strong> Paquetes y Crates</a></li><li class="chapter-item expanded "><a href="ch06-02-defining-modules-to-control-scope.html"><strong aria-hidden="true">6.2.</strong> Definición de módulos para controlar el alcance</a></li><li class="chapter-item expanded "><a href="ch06-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">6.3.</strong> Rutas para referirse a un elemento en el Arbol de Módulos</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-generic-types.html"><strong aria-hidden="true">7.</strong> Tipos de datos Genéricos</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-generic-data-types.html"><strong aria-hidden="true">7.1.</strong> Funciones genéricas</a></li><li class="chapter-item expanded "><a href="ch07-02-traits-in-cairo.html"><strong aria-hidden="true">7.2.</strong> Traits en Cairo</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-testing-cairo-programs.html"><strong aria-hidden="true">8.</strong> Probando programas de Cairo</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-how-to-write-tests.html"><strong aria-hidden="true">8.1.</strong> Cómo escribir Tests</a></li><li class="chapter-item expanded "><a href="ch09-02-test-organization.html"><strong aria-hidden="true">8.2.</strong> Organización de Testing</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">9.</strong> Apéndice</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">9.1.</strong> A - Herramientas de desarrollo útiles</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">El lenguaje de programación Cairo </h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="what-is-ownership"><a class="header" href="#what-is-ownership">What Is Ownership?</a></h2>
<p>Cairo implements an ownership system to ensure the safety and correctness of its compiled code.
The ownership mechanism complements the linear type system, which enforces that objects are used exactly once.
This helps prevent common operations that can produce runtime errors, such as illegal memory address
references or multiple writes to the same memory address, and ensures the soundness of Cairo programs
by checking at compile time that all the dictionaries are squashed.</p>
<p>Now that we’re past basic Cairo syntax, we won’t include all the <code>fn main() {</code>
code in examples, so if you’re following along, make sure to put the following
examples inside a <code>main</code> function manually. As a result, our examples will be a
bit more concise, letting us focus on the actual details rather than
boilerplate code.</p>
<h3 id="ownership-rules"><a class="header" href="#ownership-rules">Ownership Rules</a></h3>
<p>First, let’s take a look at the ownership rules. Keep these rules in mind as we
work through the examples that illustrate them:</p>
<ul>
<li>Each value in Cairo has an <em>owner</em>.</li>
<li>There can only be one owner at a time.</li>
<li>When the owner goes out of scope, the value will be <em>dropped</em>.</li>
</ul>
<h3 id="variable-scope"><a class="header" href="#variable-scope">Variable Scope</a></h3>
<p>As a first example of ownership, we’ll look at the <em>scope</em> of some variables. A
scope is the range within a program for which an item is valid. Take the
following variable:</p>
<pre><code class="language-rust">let s = 'hello';</code></pre>
<p>The variable <code>s</code> refers to a short string, where the value of the string is
hardcoded into the text of our program. The variable is valid from the point at
which it’s declared until the end of the current <em>scope</em>. Listing 3-1 shows a
program with comments annotating where the variable <code>s</code> would be valid.</p>
<pre><code class="language-rust">    {                      // s is not valid here, it’s not yet declared
        let s = 'hello';   // s is valid from this point forward

        // do stuff with s
    }                      // this scope is now over, and s is no longer valid</code></pre>
<p><span class="caption">Listing 3-1: A variable and the scope in which it is
valid</span></p>
<p>In other words, there are two important points in time here:</p>
<ul>
<li>When <code>s</code> comes <em>into</em> scope, it is valid.</li>
<li>It remains valid until it goes <em>out of</em> scope.</li>
</ul>
<p>At this point, the relationship between scopes and when variables are valid is
similar to that in other programming languages. Now we’ll build on top of this
understanding by introducing the <code>Array</code> type.</p>
<h3 id="the-array-type"><a class="header" href="#the-array-type">The <code>Array</code> Type</a></h3>
<p>To illustrate the rules of ownership, we need a data type that is more complex
than those we covered in the <a href="ch02-02-data-types.html#data-types">“Data Types”</a><!-- ignore --> section
of Chapter 3. The types covered previously are of a known size, can be
quickly and trivially copied to make a new, independent instance if another
part of code needs to use the same value in a different scope, and can easily
be dropped when they're no longer used. But we want to look at data whose size
is unknown at compile time and can't be trivially copied: the <code>Array</code> type.</p>
<p>In Cairo, each memory cell can only be written to once. Arrays are represented in memory by
a segment of contiguous memory cells, and Cairo's linear type system is used to ensure that each cell is
never written to more than once.
Consider the following code, in which we define a variable <code>arr</code> of <code>Array</code> type that holds <code>u128</code> values:</p>
<pre><code class="language-rust">use array::ArrayTrait;
...

let arr = ArrayTrait::&lt;u128&gt;::new();</code></pre>
<p>You can append values to an <code>Array</code> using the <code>append</code> method:</p>
<pre><code class="language-rust">let mut arr = ArrayTrait::&lt;u128&gt;::new();
arr.append(1);
arr.append(2);</code></pre>
<p>So, how does the ownership system ensure that each cell is never written to more than once?
Consider the following code, where we try to pass the same instance of an array in two consecutive
function calls:</p>
<pre><code class="language-rust">use array::ArrayTrait;
fn foo(arr: Array&lt;u128&gt;) {
}

fn bar(arr:Array&lt;u128&gt;){
}

fn main() {
    let mut arr = ArrayTrait::&lt;u128&gt;::new();
    foo(arr);
    bar(arr);
}</code></pre>
<p>In this case, we pass try to pass the same array instance <code>arr</code> by value to the functions <code>foo</code> and <code>bar</code>, which means
that the parameter used in both function calls is the same instance of the array. If you append a value to the array
in <code>foo</code>, and then try to append another value to the same array in <code>bar</code>, what would happen is that
you would attempt to try to write to the same memory cell twice, which is not allowed in Cairo.
To prevent this, the ownership of the <code>arr</code> variable moves from the <code>main</code> function to the <code>foo</code> function. When trying
to call <code>bar</code> with <code>arr</code> as a parameter, the ownership of <code>arr</code> was already moved to the first call. The ownership
system thus prevents us from using the same instance of <code>arr</code> in <code>foo</code>.</p>
<p>Running the code above will result in a compile-time error:</p>
<pre><code class="language-console">error: Variable was previously moved. Trait has no implementation in context: core::traits::Copy::&lt;core::array::Array::&lt;core::integer::u128&gt;&gt;
 --&gt; array.cairo:6:9
    let mut arr = ArrayTrait::&lt;u128&gt;::new();
        ^*****^
</code></pre>
<h3 id="the-copy-trait"><a class="header" href="#the-copy-trait">The <code>Copy</code> Trait</a></h3>
<p>If a type implements the <code>Copy</code> trait, passing it to a function will not move the ownership of the value to the function called, but will instead pass a copy of the value.
You can implement the <code>Copy</code> trait on your type by adding the <code>#[derive(Copy)]</code> annotation to your type definition. However, Cairo won't allow a type to be annotated with Copy if the type itself or any of its components don't implement the Copy trait.
While Arrays and Dictionaries can't be copied, custom types that don't contain either of them can be.</p>
<pre><code class="language-rust">#[derive(Copy, Drop)]
struct Point {
    x: u128,
    y: u128,
}

fn main() {
    let p1 = Point { x: 5, y: 10 };
    foo(p1);
    foo(p1);
}

fn foo(p: Point) {
    // do something with p
}</code></pre>
<p>In this example, we can pass <code>p1</code> twice to the foo function because the <code>Point</code> type implements the <code>Copy</code> trait. This means that when we pass <code>p1</code> to <code>foo</code>, we are actually passing a copy of <code>p1</code>, and the ownership of <code>p1</code> remains with the main function.
If you remove the <code>Copy</code> trait derivation from the <code>Point</code> type, you will get a compile-time error when trying to compile the code.</p>
<h3 id="the-drop-trait"><a class="header" href="#the-drop-trait">The <code>Drop</code> Trait</a></h3>
<p>You may have noticed that the <code>Point</code> type in the previous example also implements the <code>Drop</code> trait. In Cairo, a value cannot go out of scope unless it has been previously moved.
For example, the following code will not compile, because the struct <code>A</code> is not moved before it goes out of scope:</p>
<pre><code class="language-rust">struct A {}

fn main() {
    A {}; // error: Value not dropped.
}</code></pre>
<p>This is to ensure the soundness of Cairo programs. Soundness refers to the fact that if a
statement during the execution of the program is false, no cheating prover can convince an
honest verifier that it is true. In our case, we want to ensure the consistency of
consecutive dictionary key updates during program execution, which is only checked when
the dictionaries are<code>squashed</code> - which moves the ownership of the dictionary to the
<code>squash</code> method, thus allowing the dictionary to go out of scope. Unsquashed dictionaries
are dangerous, as a malicious prover could prove the correctness of inconsistent updates.</p>
<p>However, types that implement the <code>Drop</code> trait are allowed to go out of scope without being explicitly moved. When a value of a type that implements the <code>Drop</code> trait goes out of scope, the <code>Drop</code> implementation is called on the type, which moves the value to the <code>drop</code> function, allowing it to go out of scope - This is what we call &quot;dropping&quot; a value.
It is important to note that the implementation of drop is a &quot;no-op&quot;, meaning that it doesn't perform any actions other than allowing the value to go out of scope.</p>
<p>The <code>Drop</code> implementation can be derived for all types, allowing them to be dropped when goint out of scope, except for dictionaries (<code>Felt252Dict</code>) and types containing dictionaries.
For example, the following code compiles:</p>
<pre><code class="language-rust">#[derive(Drop)]
struct A {}

fn main() {
    A {}; // Now there is no error.
}</code></pre>
<h3 id="the-destruct-trait"><a class="header" href="#the-destruct-trait">The <code>Destruct</code> Trait</a></h3>
<p>Manually calling the <code>squash</code> method on a dictionary is not very convenient, and it is easy to forget to do so. To make it easier to use dictionaries, Cairo provides the <code>Destruct</code> trait, which allows you to specify the behavior of a type when it goes out of scope. While Dictionaries don't implement the <code>Drop</code> trait, they do implement the <code>Destruct</code> trait, which allows them to automatically be <code>squashed</code> when they go out of scope. This means that you can use dictionaries without having to manually call the <code>squash</code> method.</p>
<p>Consider the following example, in which we define a custom type that contains a dictionary:</p>
<pre><code class="language-rust">use dict::Felt252DictTrait;

struct A {
    dict: Felt252Dict&lt;u128&gt;
}

fn main() {
    A {
        dict: Felt252DictTrait::new()
    };
}</code></pre>
<p>If you try to run this code, you will get a compile-time error:</p>
<pre><code class="language-console">error: Variable not dropped. Trait has no implementation in context: core::traits::Drop::&lt;temp7::temp7::A&gt;. Trait has no implementation in context: core::traits::Destruct::&lt;temp7::temp7::A&gt;.
 --&gt; temp7.cairo:7:5
    A {
    ^*^
</code></pre>
<p>When A goes out of scope, it can't be dropped as it implements neither the <code>Drop</code> (as it contains a dictionary and can't <code>derive(Drop)</code>) nor the <code>Destruct</code> trait. To fix this, we can derive the <code>Destruct</code> trait implementation for the <code>A</code> type:</p>
<pre><code class="language-rust">use dict::Felt252DictTrait;

#[derive(Destruct)]
struct A {
    dict: Felt252Dict&lt;u128&gt;
}

fn main() {
    A {
        dict: Felt252DictTrait::new()
    }; // No error here
}</code></pre>
<p>Now, when <code>A</code> goes out of scope, its dictionary will be automatically <code>squashed</code>, and the program will compile.</p>
<h3 id="copy-array-data-with-clone"><a class="header" href="#copy-array-data-with-clone">Copy Array data with Clone</a></h3>
<p>If we <em>do</em> want to deeply copy the data of an <code>Array</code>, we can use a common method called <code>clone</code>. We’ll discuss method syntax in Chapter 5, but because methods are a common feature in many
programming languages, you’ve probably seen them before.</p>
<p>Here’s an example of the <code>clone</code> method in action.</p>
<blockquote>
<p>Note: in the following example, we need to import the <code>Clone</code> trait from the corelib <code>clone</code> module, and its implementation for the array type from the <code>array</code> module.</p>
</blockquote>
<pre><code class="language-rust">use array::ArrayTrait;
use clone::Clone;
use array::ArrayTCloneImpl;
...
let arr1 = ArrayTrait::new::&lt;u128&gt;();
let arr2 = arr1.clone();
</code></pre>
<blockquote>
<p>Note: you will need to run <code>cairo-run</code> with the <code>--available-gas=2000000</code> option to run this example, because it uses a loop and must be ran with a gas limit.</p>
</blockquote>
<p>When you see a call to <code>clone</code>, you know that some arbitrary code is being
executed and that code may be expensive. It’s a visual indicator that something
different is going on.</p>
<h3 id="ownership-and-functions"><a class="header" href="#ownership-and-functions">Ownership and Functions</a></h3>
<p>Passing a variable to a function will either move it or copy it. As seen in the Array section, passing an <code>Array</code> as a function parameter transfers its ownership; let's see what happens with other types.</p>
<p>Listing 3-3 has an example with some annotations
showing where variables go into and out of scope.</p>
<p><span class="filename">Filename: src/main.cairo</span></p>
<pre><code class="language-rust">#[derive(Drop)]
struct MyStruct{}

fn main() {
    let my_struct = MyStruct{};  // my_struct comes into scope

    takes_ownership(my_struct);             // my_struct's value moves into the function...
                                    // ... and so is no longer valid here

    let x = 5_u128;                 // x comes into scope

    makes_copy(x);                  // x would move into the function,
                                    // but u128 implements Copy, so it's okay to still
                                    // use x afterward

} // Here, x goes out of scope and is dropped. But because my_struct's value was moved, nothing
// special happens.

fn takes_ownership(some_struct: A) { // some_struct comes into scope
} // Here, some_struct goes out of scope and `drop` is called.

fn makes_copy(some_uinteger: u128) { // some_uinteger comes into scope
} // Here, some_integer goes out of scope and is dropped.</code></pre>
<p><span class="caption">Listing 3-3: Functions with ownership and scope
annotated</span></p>
<p>If we tried to use <code>my_struct</code> after the call to <code>takes_ownership</code>, Cairo would throw a
compile-time error. These static checks protect us from mistakes. Try adding
code to <code>main</code> that uses <code>my_struct</code> and <code>x</code> to see where you can use them and where
the ownership rules prevent you from doing so.</p>
<h3 id="return-values-and-scope"><a class="header" href="#return-values-and-scope">Return Values and Scope</a></h3>
<p>Returning values can also transfer ownership. Listing 3-4 shows an example of a
function that returns some value, with similar annotations as those in Listing
4-3.</p>
<p><span class="filename">Filename: src/main.cairo</span></p>
<pre><code class="language-rust">#[derive(Drop)]
struct A{}

fn main() {
    let a1 = gives_ownership();         // gives_ownership moves its return
                                        // value into a1

    let a2 = A{};     // a2 comes into scope

    let a3 = takes_and_gives_back(a2);  // a2 is moved into
                                        // takes_and_gives_back, which also
                                        // moves its return value into a3
} // Here, a3 goes out of scope and is dropped. a2 was moved, so nothing
  // happens. a1 goes out of scope and is dropped.

fn gives_ownership() -&gt; A {             // gives_ownership will move its
                                             // return value into the function
                                             // that calls it

    let some_a = A{}; // some_a comes into scope

    some_a                              // some_a is returned and
                                             // moves out to the calling
                                             // function
}

// This function takes an instance of A and returns one
fn takes_and_gives_back(some_a: A) -&gt; A { // some_a comes into
                                                      // scope

    some_a  // some_a is returned and moves out to the calling function
}</code></pre>
<p><span class="caption">Listing 3-4: Transferring ownership of return
values</span></p>
<p>When a variable goes out of scope, its value is dropped, unless ownership of the value has been moved to another variable.</p>
<p>While this works, taking ownership and then returning ownership with every
function is a bit tedious. What if we want to let a function use a value but
not take ownership? It’s quite annoying that anything we pass in also needs to
be passed back if we want to use it again, in addition to any data resulting
from the body of the function that we might want to return as well.</p>
<p>Cairo does let us return multiple values using a tuple, as shown in Listing 3-5.</p>
<p><span class="filename">Filename: src/main.cairo</span></p>
<pre><code class="language-rust">use array::ArrayTrait;
fn main() {
    let arr1 = ArrayTrait::&lt;u128&gt;::new();

    let (arr2, len) = calculate_length(arr1);
}

fn calculate_length(arr: Array&lt;u128&gt;) -&gt; (Array&lt;u128&gt;, usize) {
    let length = arr.len(); // len() returns the length of an array

    (arr, length)
}</code></pre>
<p><span class="caption">Listing 3-5: Returning ownership of parameters</span></p>
<p>But this is too much ceremony and a lot of work for a concept that should be
common. Luckily for us, Cairo has two features for using a value without
transferring ownership, called <em>references</em> and <em>snapshots</em>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch03-00-understanding-ownership.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="ch03-02-references-and-snapshots.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch03-00-understanding-ownership.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="ch03-02-references-and-snapshots.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
