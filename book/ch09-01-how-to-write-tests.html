<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Cómo escribir Tests - El lenguaje de programación Cairo </title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">El lenguaje de programación Cairo</a></li><li class="chapter-item expanded affix "><a href="ch00-01-foreword.html">Prólogo</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Introducción</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Cómo empezar</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Instalación</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hola, Mundo!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-scarb.html"><strong aria-hidden="true">1.3.</strong> Hola, Scarb!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-common-programming-concepts.html"><strong aria-hidden="true">2.</strong> Conceptos comunes de programación</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch02-01-variables-and-mutability.html"><strong aria-hidden="true">2.1.</strong> Variables y mutabilidad</a></li><li class="chapter-item expanded "><a href="ch02-02-data-types.html"><strong aria-hidden="true">2.2.</strong> Tipos de datos</a></li><li class="chapter-item expanded "><a href="ch02-03-functions.html"><strong aria-hidden="true">2.3.</strong> Funciones</a></li><li class="chapter-item expanded "><a href="ch02-04-comments.html"><strong aria-hidden="true">2.4.</strong> Comentarios</a></li><li class="chapter-item expanded "><a href="ch02-05-control-flow.html"><strong aria-hidden="true">2.5.</strong> Flujo de contro</a></li></ol></li><li class="chapter-item expanded "><a href="ch03-00-understanding-ownership.html"><strong aria-hidden="true">3.</strong> Comprender Ownership</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-what-is-ownership.html"><strong aria-hidden="true">3.1.</strong> ¿Qué es Ownership?</a></li><li class="chapter-item expanded "><a href="ch03-02-references-and-snapshots.html"><strong aria-hidden="true">3.2.</strong> Referencias e instantáneas</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-using-structs-to-structure-related-data.html"><strong aria-hidden="true">4.</strong>  Uso de estructuras para estructurar datos relacionados</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-defining-and-instantiating-structs.html"><strong aria-hidden="true">4.1.</strong> Definición e instanciación de estructuras</a></li><li class="chapter-item expanded "><a href="ch04-02-an-example-program-using-structs.html"><strong aria-hidden="true">4.2.</strong> Un programa de ejemplo usando estructuras</a></li><li class="chapter-item expanded "><a href="ch04-03-method-syntax.html"><strong aria-hidden="true">4.3.</strong> Sintaxis de métodos</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-enums-and-pattern-matching.html"><strong aria-hidden="true">5.</strong> Enums y Concordancia de Patrones</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-enums.html"><strong aria-hidden="true">5.1.</strong> Enums</a></li><li class="chapter-item expanded "><a href="ch05-02-the-match-control-flow-construct.html"><strong aria-hidden="true">5.2.</strong> La construcción del flujo de control de coincidencias</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-managing-cairo-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">6.</strong> Gestionando Proyectos Cairo con Paquetes, Crates y Módulos</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-packages-and-crates.html"><strong aria-hidden="true">6.1.</strong> Paquetes y Crates</a></li><li class="chapter-item expanded "><a href="ch06-02-defining-modules-to-control-scope.html"><strong aria-hidden="true">6.2.</strong> Definición de módulos para controlar el alcance</a></li><li class="chapter-item expanded "><a href="ch06-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">6.3.</strong> Rutas para referirse a un elemento en el Arbol de Módulos</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-generic-types.html"><strong aria-hidden="true">7.</strong> Tipos de datos Genéricos</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-generic-data-types.html"><strong aria-hidden="true">7.1.</strong> Funciones genéricas</a></li><li class="chapter-item expanded "><a href="ch07-02-traits-in-cairo.html"><strong aria-hidden="true">7.2.</strong> Traits en Cairo</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-testing-cairo-programs.html"><strong aria-hidden="true">8.</strong> Probando programas de Cairo</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-how-to-write-tests.html" class="active"><strong aria-hidden="true">8.1.</strong> Cómo escribir Tests</a></li><li class="chapter-item expanded "><a href="ch09-02-test-organization.html"><strong aria-hidden="true">8.2.</strong> Organización de Testing</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">9.</strong> Apéndice</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">9.1.</strong> A - Herramientas de desarrollo útiles</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">El lenguaje de programación Cairo </h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="how-to-write-tests"><a class="header" href="#how-to-write-tests">How To Write Tests</a></h1>
<h2 id="the-anatomy-of-a-test-function"><a class="header" href="#the-anatomy-of-a-test-function">The Anatomy of a Test Function</a></h2>
<p>Tests are Cairo functions that verify that the non-test code is functioning in the expected manner. The bodies of test functions typically perform these three actions:</p>
<ul>
<li>Set up any needed data or state.</li>
<li>Run the code you want to test.</li>
<li>Assert the results are what you expect.</li>
</ul>
<p>Let’s look at the features Cairo provides specifically for writing tests that take these actions, which include the <code>test</code> attribute, the <code>assert</code> function, and and the <code>should_panic</code> attribute.</p>
<h3 id="the-anatomy-of-a-test-function-1"><a class="header" href="#the-anatomy-of-a-test-function-1">The Anatomy of a Test Function</a></h3>
<p>At its simplest, a test in Cairo is a function that’s annotated with the <code>test</code> attribute. Attributes are metadata about pieces of Cairo code; one example is the derive attribute we used with structs in Chapter 4. To change a function into a test function, add <code>#[test]</code> on the line before <code>fn</code>. When you run your tests with the <code>cairo-test</code> command, Cairo builds a test runner binary that runs the annotated functions and reports on whether each test function passes or fails.</p>
<p>Let's create a new project called <code>adder</code> that will add two numbers using Scarb with the command <code>scarb new adder</code>:</p>
<pre><code class="language-shell">adder
├── cairo_project.toml
├── Scarb.toml
└── src
    └── lib.cairo
</code></pre>
<!-- TODO: remove when Scarb test work -->
<blockquote>
<p>Note: You will notice here a <code>cairo_project.toml</code> file.
This is the configuration file for &quot;vanilla&quot; Cairo projects (i.e. not managed by Scarb),
which is required to run the <code>cairo-test .</code> command to run the code of the crate.
It is required until Scarb implements this feature. The content of the file is:</p>
<pre><code class="language-toml">[crate_roots]
adder = &quot;src&quot;
</code></pre>
<p>and indicates that the crate named &quot;adder&quot; is located in the <code>src</code> directory.</p>
</blockquote>
<p>In <em>lib.cairo</em>, let's add a firt test, as shown in Listing 9-1.</p>
<p><span class="filename">Filename: lib.cairo</span></p>
<pre><code class="language-rust">#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        let result = 2 + 2;
        assert(result == 4, 'result is not 4');
    }
}</code></pre>
<p>Listing 9-1: A test module and function</p>
<p>For now, let’s ignore the top two lines and focus on the function. Note the <code>#[test]</code> annotation: this attribute indicates this is a test function, so the test runner knows to treat this function as a test. We might also have non-test functions in the tests module to help set up common scenarios or perform common operations, so we always need to indicate which functions are tests.</p>
<p>The example function body uses the <code>assert</code> function, which contains the result of adding 2 and 2, equals 4. This assertion serves as an example of the format for a typical test. Let’s run it to see that this test passes.</p>
<p>The <code>cairo-test .</code> command runs all tests in our project, as shown in Listing 9-2.</p>
<pre><code class="language-shell">$ cairo-test .
running 1 tests
test adder::lib::tests::it_works ... ok
test result: ok. 1 passed; 0 failed; 0 ignored; 0 filtered out;
</code></pre>
<p>Listing 9-2: The output from running a test</p>
<p><code>cairo-test</code> compiled and ran the test. We see the line <code>running 1 tests</code>. The next line shows the name of the generated test function, called <code>it_works</code>, and that the result of running that test is <code>ok</code>. The overall summary <code>test result: ok.</code> means that all the tests passed, and the portion that reads <code>1 passed; 0 failed</code> totals the number of tests that passed or failed.</p>
<p>It’s possible to mark a test as ignored so it doesn’t run in a particular instance; we’ll cover that in the <a href="#ignoring-some-tests-unless-specifically-requested">Ignoring Some Tests Unless Specifically Requested</a> section later in this chapter. Because we haven’t done that here, the summary shows <code>0 ignored</code>. We can also pass an argument to the <code>cairo-test</code> command to run only a test whose name matches a string; this is called filtering and we’ll cover that in the <a href="#running-single-tests">Running Single Tests</a> section. We also haven’t filtered the tests being run, so the end of the summary shows <code>0 filtered out</code>.</p>
<p>Let’s start to customize the test to our own needs. First change the name of the <code>it_works</code> function to a different name, such as <code>exploration</code>, like so:</p>
<p><span class="filename">Filename: lib.cairo</span></p>
<pre><code class="language-rust">#[cfg(test)]
mod tests {
    #[test]
    fn exploration() {
        let result = 2 + 2;
        assert(result == 4, 'result is not 4');
    }
}</code></pre>
<p>Then run <code>cairo-test  -- --path src</code> again. The output now shows <code>exploration</code> instead of <code>it_works</code>:</p>
<pre><code class="language-shell">$ cairo-test .
running 1 tests
test adder::lib::tests::exploration ... ok
test result: ok. 1 passed; 0 failed; 0 ignored; 0 filtered out;
</code></pre>
<p>Now we’ll add another test, but this time we’ll make a test that fails! Tests fail when something in the test function panics. Each test is run in a new thread, and when the main thread sees that a test thread has died, the test is marked as failed. Enter the new test as a function named <code>another</code>, so your <em>src/lib.cairo</em> file looks like Listing 9-3.</p>
<pre><code class="language-rust">#[test]
fn another() {
    let result = 2 + 2;
    assert(result == 6, 'Make this test fail');
}</code></pre>
<p>Listing 9-3: Adding a second test that will fail</p>
<pre><code class="language-shell">$ cairo-test .
running 2 tests
test adder::lib::tests::exploration ... ok
test adder::lib::tests::another ... fail
failures:
    adder::lib::tests::another - panicked with [593979512822486838786147395675889716 ('Make this test fail'), ].
Error: test result: FAILED. 1 passed; 1 failed; 0 ignored
</code></pre>
<p>Listing 9-4: Test results when one test passes and one test fails</p>
<p>Instead of <code>ok</code>, the line <code>adder::lib::tests::another</code> shows <code>fail</code>. A new section appear between the individual results and the summary. It displays the detailed reason for each test failure. In this case, we get the details that <code>another</code> failed because it panicked with <code>[593979512822486838786147395675889716 ('Make this test fail'), ]</code> in the <em>src/lib.cairo</em> file.</p>
<p>The summary line displays at the end: overall, our test result is <code>FAILED</code>. We had one test pass and one test fail.</p>
<p>Now that you’ve seen what the test results look like in different scenarios, let’s look at some functions that are useful in tests.</p>
<h2 id="checking-results-with-the-assert-function"><a class="header" href="#checking-results-with-the-assert-function">Checking Results with the assert function</a></h2>
<p>The <code>assert</code> function, provided by Cairo, is useful when you want to ensure that some condition in a test evaluates to <code>true</code>. We give the <code>assert</code> function a first argument that evaluates to a Boolean. If the value is <code>true</code>, nothing happens and the test passes. If the value is <code>false</code>, the assert function calls <code>panic()</code> to cause the test to fail with a message we defined as the second argument of the <code>assert</code> function. Using the <code>assert</code> function helps us check that our code is functioning in the way we intend.</p>
<p>In <a href="ch04-03-method-syntax.html#multiple-impl-blocks">Chapter 4, Listing 5-15</a>, we used a <code>Rectangle</code> struct and a <code>can_hold</code> method, which are repeated here in Listing 9-5. Let’s put this code in the <em>src/lib.cairo</em> file, then write some tests for it using the <code>assert</code> function.</p>
<p><span class="filename">Filename: lib.cairo</span></p>
<pre><code class="language-rust">trait RectangleTrait {
    fn area(self: @Rectangle) -&gt; u64;
    fn can_hold(self: @Rectangle, other: @Rectangle) -&gt; bool;
}

impl RectangleImpl of RectangleTrait {
    fn area(self: @Rectangle) -&gt; u64 {
        *self.width * *self.height
    }
    fn can_hold(self: @Rectangle, other: @Rectangle) -&gt; bool {
        *self.width &gt; *other.width &amp; *self.height &gt; *other.height
    }
}</code></pre>
<p>Listing 9-5: Using the <code>Rectangle</code> struct and its <code>can_hold</code> method from Chapter 5</p>
<p>The <code>can_hold</code> method returns a <code>Boolean</code>, which means it’s a perfect use case for the assert function. In Listing 9-6, we write a test that exercises the <code>can_hold</code> method by creating a <code>Rectangle</code> instance that has a width of <code>8_u64</code> and a height of <code>7_u64</code> and asserting that it can hold another <code>Rectangle</code> instance that has a width of <code>5_u64</code> and a height of <code>1_u64</code>.</p>
<p><span class="filename">Filename: lib.cairo</span></p>
<pre><code class="language-rust">#[cfg(test)]
mod tests {
    use super::Rectangle;
    use super::RectangleTrait;

    #[test]
    fn larger_can_hold_smaller() {
        let larger = Rectangle {
            height: 7_u64,
            width: 8_u64,
        };
        let smaller = Rectangle {
            height: 1_u64,
            width: 5_u64,
        };

        assert(larger.can_hold(@smaller), 'rectangle cannot hold');
    }
}</code></pre>
<p>Listing 9-6: A test for <code>can_hold</code> that checks whether a larger rectangle can indeed hold a smaller rectangle</p>
<p>Note that we’ve added two new lines inside the tests module: <code>use super::Rectangle;</code> and <code>use super::RectangleTrait;</code>. The tests module is a regular module that follows the usual visibility rules. Because the tests module is an inner module, we need to bring the code under test in the outer module into the scope of the inner module.</p>
<p>We’ve named our test <code>larger_can_hold_smaller</code>, and we’ve created the two <code>Rectangle</code> instances that we need. Then we called the assert function and passed it the result of calling <code>larger.can_hold(@smaller)</code>. This expression is supposed to return <code>true</code>, so our test should pass. Let’s find out!</p>
<pre><code class="language-shell">$ cairo-test .
running 1 tests
test adder::lib::tests::larger_can_hold_smaller ... ok
test result: ok. 1 passed; 0 failed; 0 ignored; 0 filtered out;
</code></pre>
<p>It does pass! Let’s add another test, this time asserting that a smaller rectangle cannot hold a larger rectangle:</p>
<p><span class="filename">Filename: lib.cairo</span></p>
<pre><code class="language-rust">#[cfg(test)]
mod tests {
    use super::Rectangle;
    use super::RectangleTrait;

    #[test]
    fn larger_can_hold_smaller() {
        // --snip--
    }

    #[test]
    fn smaller_cannot_hold_larger() {
        let larger = Rectangle {
            height: 7_u64,
            width: 8_u64,
        };
        let smaller = Rectangle {
            height: 1_u64,
            width: 5_u64,
        };

        assert(!smaller.can_hold(@larger), 'rectangle cannot hold');
    }
}</code></pre>
<p>Because the correct result of the <code>can_hold</code> function in this case is <code>false</code>, we need to negate that result before we pass it to the assert function. As a result, our test will pass if <code>can_hold</code> returns false:</p>
<pre><code class="language-shell">$ cairo-test .
    running 2 tests
    test adder::lib::tests::smaller_cannot_hold_larger ... ok
    test adder::lib::tests::larger_can_hold_smaller ... ok
    test result: ok. 2 passed; 0 failed; 0 ignored; 0 filtered out;
</code></pre>
<p>Two tests that pass! Now let’s see what happens to our test results when we introduce a bug in our code. We’ll change the implementation of the <code>can_hold</code> method by replacing the greater-than sign with a less-than sign when it compares the widths:</p>
<pre><code class="language-rust">// --snip--
impl RectangleImpl of RectangleTrait {
    fn can_hold(self: @Rectangle, other: @Rectangle) -&gt; bool {
        *self.width &lt; *other.width &amp; *self.height &gt; *other.height
    }
}</code></pre>
<p>Running the tests now produces the following:</p>
<pre><code class="language-shell">$ cairo-test .
running 2 tests
test adder::lib::tests::smaller_cannot_hold_larger ... ok
test adder::lib::tests::larger_can_hold_smaller ... fail
failures:
   adder::lib::tests::larger_can_hold_smaller - panicked with [167190012635530104759003347567405866263038433127524 ('rectangle cannot hold'), ].

Error: test result: FAILED. 1 passed; 1 failed; 0 ignored
</code></pre>
<p>Our tests caught the bug! Because <code>larger.width</code> is <code>8_u64</code> and <code>smaller.width</code> is <code>5_u64</code>, the comparison of the widths in <code>can_hold</code> now returns <code>false</code>: <code>8_u6</code>4 is not less than <code>5_u64</code>.</p>
<h2 id="checking-for-panics-with-should_panic"><a class="header" href="#checking-for-panics-with-should_panic">Checking for Panics with <code>should_panic</code></a></h2>
<p>In addition to checking return values, it’s important to check that our code handles error conditions as we expect. For example, consider the Guess type in Listing 9-8. Other code that uses <code>Guess</code> depends on the guarantee that <code>Guess</code> instances will contain only values between <code>1_u64</code> and <code>100_u64</code>. We can write a test that ensures that attempting to create a <code>Guess</code> instance with a value outside that range panics.</p>
<p>We do this by adding the attribute <code>should_panic</code> to our test function. The test passes if the code inside the function panics; the test fails if the code inside the function doesn’t panic.</p>
<p>Listing 9-8 shows a test that checks that the error conditions of <code>GuessTrait::new</code> happen when we expect them to.</p>
<p><span class="filename">Filename: lib.cairo</span></p>
<pre><code class="language-rust">use array::ArrayTrait;

#[derive(Copy, Drop)]
struct Guess {
    value: u64,
}

trait GuessTrait {
    fn new(value: u64) -&gt; Guess;
}

impl GuessImpl of GuessTrait {
    fn new(value: u64) -&gt; Guess {
        if value &lt; 1_u64 {
            let mut data = ArrayTrait::new();
            data.append('Guess must be higher than 1');
            panic(data);
        } else if value &gt; 100_u64 {
            let mut data = ArrayTrait::new();
            data.append('Guess must be smaller than 100');
            panic(data);
        }

        Guess { value, }
    }
}

#[cfg(test)]
mod tests {
    use super::Guess;
    use super::GuessTrait;

    #[test]
    #[should_panic]
    fn greater_than_100() {
        GuessTrait::new(200_u64);
    }
}</code></pre>
<p>Listing 9-8: Testing that a condition will cause a panic</p>
<p>We place the <code>#[should_panic]</code> attribute after the <code>#[test]</code> attribute and before the test function it applies to. Let’s look at the result when this test passes:</p>
<pre><code class="language-shell">$ cairo-test .
running 1 tests
test adder::lib::tests::greater_than_100 ... ok
test result: ok. 1 passed; 0 failed; 0 ignored; 0 filtered out;
</code></pre>
<p>Looks good! Now let’s introduce a bug in our code by removing the condition that the new function will panic if the value is greater than <code>100_u64</code>:</p>
<pre><code class="language-rust">// --snip--
impl GuessImpl of GuessTrait {
    fn new(value: u64) -&gt; Guess {
        if value &lt; 1_u64 {
            let mut data = ArrayTrait::new();
            data.append('Guess must be between 1 and 100');
            panic(data);
        }

        Guess { value, }
    }
}</code></pre>
<p>When we run the test in Listing 9-8, it will fail:</p>
<pre><code class="language-shell">$ cairo-test .
running 1 tests
test adder::lib::tests::greater_than_100 ... fail
failures:
   adder::lib::tests::greater_than_100 - expected panic but finished successfully.
Error: test result: FAILED. 0 passed; 1 failed; 0 ignored
</code></pre>
<p>We don’t get a very helpful message in this case, but when we look at the test function, we see that it’s annotated with <code>#[should_panic]</code>. The failure we got means that the code in the test function did not cause a panic.</p>
<p>Tests that use <code>should_panic</code> can be imprecise. A <code>should_panic</code> test would pass even if the test panics for a different reason from the one we were expecting. To make <code>should_panic</code> tests more precise, we can add an optional expected parameter to the <code>should_panic</code> attribute. The test harness will make sure that the failure message contains the provided text. For example, consider the modified code for <code>Guess</code> in Listing 9-9 where the new function panics with different messages depending on whether the value is too small or too large.</p>
<p><span class="filename">Filename: lib.cairo</span></p>
<pre><code class="language-rust">// --snip--
impl GuessImpl of GuessTrait {
    fn new(value: u64) -&gt; Guess {
        if value &lt; 1_u64 {
            let mut data = ArrayTrait::new();
            data.append('Guess must be greater than 1');
            panic(data);
        } else if value &gt; 100_u64 {
            let mut data = ArrayTrait::new();
            data.append('Guess must be lower than 100');
            panic(data);
        }

        Guess { value, }
    }
}

#[cfg(test)]
mod tests {
    use super::Guess;
    use super::GuessTrait;

    #[test]
    #[should_panic(expected: ('Guess must be lower than 100', ))]
    fn greater_than_100() {
        GuessTrait::new(200_u64);
    }
}</code></pre>
<p>Listing 9-9: Testing for a panic with a panic message containing the error message string</p>
<p>This test will pass because the value we put in the <code>should_panic</code> attribute’s expected parameter is the string of the message that the <code>Guess::new</code> function panics with. We need to specify the entire panic message that we expect.</p>
<p>To see what happens when a <code>should_panic</code> test with an expected message fails, let’s again introduce a bug into our code by swapping the bodies of the if <code>value &lt; 1_u64</code> and the else if <code>value &gt; 100_u64</code> blocks:</p>
<pre><code class="language-rust">if value &lt; 1_u64 {
    let mut data = ArrayTrait::new();
    data.append('Guess must be lower than 100');
    panic(data);
} else if value &gt; 100_u64 {
    let mut data = ArrayTrait::new();
    data.append('Guess must be greater than 1');
    panic(data);
}</code></pre>
<p>This time when we run the <code>should_panic</code> test, it will fail:</p>
<pre><code class="language-shell">$ cairo-test .
running 1 tests
test adder::lib::tests::greater_than_100 ... fail
failures:
   adder::lib::tests::greater_than_100 - panicked with [7525466742201272999442800965907272684056773373474020086884212809777 ('Guess must be greater than 1'), ].

Error: test result: FAILED. 0 passed; 1 failed; 0 ignored
</code></pre>
<p>The failure message indicates that this test did indeed panic as we expected, but the panic message did not include the expected string. The panic message that we did get in this case was <code>Guess must be greater than 1</code>. Now we can start figuring out where our bug is!</p>
<h2 id="running-single-tests"><a class="header" href="#running-single-tests">Running Single Tests</a></h2>
<p>Sometimes, running a full test suite can take a long time. If you’re working on code in a particular area, you might want to run only the tests pertaining to that code. You can choose which tests to run by passing <code>cairo-test</code> the name of the test you want to run as an argument.</p>
<p>To demonstrate how to run a single test, we’ll first create two tests functions, as shown in Listing 9-10, and choose which ones to run.</p>
<p><span class="filename">Filename: src/lib.cairo</span></p>
<pre><code class="language-rust">#[cfg(test)]
mod tests {
    #[test]
    fn add_two_and_two() {
        let result = 2 + 2;
        assert(result == 4, 'result is not 4');
    }

    #[test]
    fn add_three_and_two() {
        let result = 3 + 2;
        assert(result == 5, 'result is not 5');
    }
}</code></pre>
<p>Listing 9-10: Two tests with two different names</p>
<p>We can pass the name of any test function to <code>cairo-test</code> to run only that test using the <code>-f</code> flag:</p>
<pre><code class="language-shell">$ cairo-test . -f add_two_and_two
running 1 tests
test adder::lib::tests::add_two_and_two ... ok
test result: ok. 1 passed; 0 failed; 0 ignored; 1 filtered out;
</code></pre>
<p>Only the test with the name <code>add_two_and_two</code> ran; the other test didn’t match that name. The test output lets us know we had one more test that didn’t run by displaying 1 filtered out at the end.</p>
<p>We can also specify part of a test name, and any test whose name contains that value will be run.</p>
<h2 id="ignoring-some-tests-unless-specifically-requested"><a class="header" href="#ignoring-some-tests-unless-specifically-requested">Ignoring Some Tests Unless Specifically Requested</a></h2>
<p>Sometimes a few specific tests can be very time-consuming to execute, so you might want to exclude them during most runs of <code>cairo-test</code>. Rather than listing as arguments all tests you do want to run, you can instead annotate the time-consuming tests using the <code>ignore</code> attribute to exclude them, as shown here:</p>
<p><span class="filename">Filename: src/lib.cairo</span></p>
<pre><code class="language-rust">#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        let result = 2 + 2;
        assert(result == 4, 'result is not 4');
    }

    #[test]
    #[ignore]
    fn expensive_test() {
        // code that takes an hour to run
    }
}</code></pre>
<p>After <code>#[test]</code> we add the <code>#[ignore]</code> line to the test we want to exclude. Now when we run our tests, it_works runs, but expensive_test doesn’t:</p>
<pre><code class="language-shell">$ cairo-test .
running 2 tests
test adder::lib::tests::expensive_test ... ignored
test adder::lib::tests::it_works ... ok
test result: ok. 1 passed; 0 failed; 1 ignored; 0 filtered out;
</code></pre>
<p>The <code>expensive_test</code> function is listed as ignored.</p>
<p>When you’re at a point where it makes sense to check the results of the ignored tests and you have time to wait for the results, you can run <code>cairo-test -- --include-ignored</code> to run all tests whether they’re ignored or not.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch09-00-testing-cairo-programs.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="ch09-02-test-organization.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch09-00-testing-cairo-programs.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="ch09-02-test-organization.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
