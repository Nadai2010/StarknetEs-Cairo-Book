<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Tipos de datos - El lenguaje de programación Cairo </title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">El lenguaje de programación Cairo</a></li><li class="chapter-item expanded affix "><a href="ch00-01-foreword.html">Prólogo</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Introducción</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Cómo empezar</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Instalación</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hola, Mundo!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-scarb.html"><strong aria-hidden="true">1.3.</strong> Hola, Scarb!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-common-programming-concepts.html"><strong aria-hidden="true">2.</strong> Conceptos comunes de programación</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch02-01-variables-and-mutability.html"><strong aria-hidden="true">2.1.</strong> Variables y mutabilidad</a></li><li class="chapter-item expanded "><a href="ch02-02-data-types.html" class="active"><strong aria-hidden="true">2.2.</strong> Tipos de datos</a></li><li class="chapter-item expanded "><a href="ch02-03-functions.html"><strong aria-hidden="true">2.3.</strong> Funciones</a></li><li class="chapter-item expanded "><a href="ch02-04-comments.html"><strong aria-hidden="true">2.4.</strong> Comentarios</a></li><li class="chapter-item expanded "><a href="ch02-05-control-flow.html"><strong aria-hidden="true">2.5.</strong> Flujo de control</a></li></ol></li><li class="chapter-item expanded "><a href="ch03-00-understanding-ownership.html"><strong aria-hidden="true">3.</strong> Comprender Ownership</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-what-is-ownership.html"><strong aria-hidden="true">3.1.</strong> ¿Qué es Ownership?</a></li><li class="chapter-item expanded "><a href="ch03-02-references-and-snapshots.html"><strong aria-hidden="true">3.2.</strong> Referencias y Snapshots</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-using-structs-to-structure-related-data.html"><strong aria-hidden="true">4.</strong>  Uso de estructuras para estructurar datos relacionados</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-defining-and-instantiating-structs.html"><strong aria-hidden="true">4.1.</strong> Definición e instanciación de estructuras</a></li><li class="chapter-item expanded "><a href="ch04-02-an-example-program-using-structs.html"><strong aria-hidden="true">4.2.</strong> Un programa de ejemplo usando estructuras</a></li><li class="chapter-item expanded "><a href="ch04-03-method-syntax.html"><strong aria-hidden="true">4.3.</strong> Sintaxis de métodos</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-enums-and-pattern-matching.html"><strong aria-hidden="true">5.</strong> Enums y Concordancia de Patrones</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-enums.html"><strong aria-hidden="true">5.1.</strong> Enums</a></li><li class="chapter-item expanded "><a href="ch05-02-the-match-control-flow-construct.html"><strong aria-hidden="true">5.2.</strong> La construcción del flujo de control de coincidencias</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-managing-cairo-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">6.</strong> Gestionando Proyectos Cairo con Paquetes, Crates y Módulos</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-packages-and-crates.html"><strong aria-hidden="true">6.1.</strong> Paquetes y Crates</a></li><li class="chapter-item expanded "><a href="ch06-02-defining-modules-to-control-scope.html"><strong aria-hidden="true">6.2.</strong> Definición de módulos para controlar el alcance</a></li><li class="chapter-item expanded "><a href="ch06-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">6.3.</strong> Rutas para referirse a un elemento en el Arbol de Módulos</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-generic-types.html"><strong aria-hidden="true">7.</strong> Tipos de datos Genéricos</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-generic-data-types.html"><strong aria-hidden="true">7.1.</strong> Funciones genéricas</a></li><li class="chapter-item expanded "><a href="ch07-02-traits-in-cairo.html"><strong aria-hidden="true">7.2.</strong> Traits en Cairo</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-testing-cairo-programs.html"><strong aria-hidden="true">8.</strong> Probando programas de Cairo</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-how-to-write-tests.html"><strong aria-hidden="true">8.1.</strong> Cómo escribir Tests</a></li><li class="chapter-item expanded "><a href="ch09-02-test-organization.html"><strong aria-hidden="true">8.2.</strong> Organización de Testing</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">9.</strong> Apéndice</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">9.1.</strong> A - Herramientas de desarrollo útiles</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">El lenguaje de programación Cairo </h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="tipos-de-datos"><a class="header" href="#tipos-de-datos">Tipos de datos</a></h2>
<p>Cada valor en Cairo tiene un cierto <em>tipo de dato</em>, lo que le dice a Cairo qué tipo de datos se están especificando para que sepa cómo trabajar con esos datos. Esta sección cubre dos subconjuntos de tipos de datos: escalares y compuestos.</p>
<p>Tenga en cuenta que Cairo es un lenguaje <em>de tipado estático</em>, lo que significa que debe conocer los tipos de todas las variables en tiempo de compilación. El compilador suele inferir el tipo deseado en función del valor y su uso. En casos en que pueden ser posibles varios tipos, podemos utilizar un método de conversión donde especificamos el tipo de salida deseado.</p>
<pre><code class="language-Rust">use traits::TryInto;
use option::OptionTrait;
fn main(){
    let x = 3;
    let y:u32 = x.try_into().unwrap();
}
</code></pre>
<p>Verá diferentes anotaciones de tipo para otros tipos de datos.</p>
<h3 id="tipos-escalares"><a class="header" href="#tipos-escalares">Tipos escalares</a></h3>
<p>Un tipo <em>scalar</em> representa un único valor. Cairo tiene tres tipos escalares primarios:
fieltros, enteros y booleanos. Puede que reconozca de otros lenguajes de programación. Veamos cómo funcionan en Cairo.</p>
<h4 id="tipo-felt"><a class="header" href="#tipo-felt">Tipo Felt</a></h4>
<p>En Cairo, si no especificas el tipo de una variable o argumento, su tipo por defecto es un elemento de campo, representado por la palabra clave <code>felt252</code>. En el contexto de Cairo, cuando decimos &quot;un elemento de campo&quot; nos referimos a un entero en el rango <code>0 &lt;= x &lt; P</code>, donde <code>P</code> es un número primo muy grande actualmente igual a <code>P = 2^{251} + 17 * 2^{192}+1</code>. Al sumar, restar o multiplicar, si el resultado queda fuera del rango especificado del número primo, se produce un desbordamiento y se suma o resta un múltiplo apropiado de P para que el resultado vuelva a estar dentro del rango (es decir, el resultado se calcula módulo P).</p>
<p>La diferencia más importante entre los números enteros y los elementos de campo es la división: La división de elementos de campo (y, por tanto, la división en Cairo) es distinta de la división normal de las CPU, en la que
la división entera <code>x / y</code> se define como <code>[x/y]</code> donde se devuelve la parte entera del cociente (por lo que se obtiene <code>7 / 3 = 2</code>) y puede o no satisfacer la ecuación <code>(x / y) * y == x</code>, dependiendo de la divisibilidad de <code>x</code> por <code>y</code>.</p>
<p>En Cairo, el resultado de <code>x/y</code> está definido para satisfacer siempre la ecuación <code>(x / y) * y == x</code>. Si <code>y</code> divide a <code>x</code> entre enteros, obtendrás el resultado esperado en Cairo (por ejemplo <code>6 / 2</code> dará como resultado <code>3</code>).
Pero cuando <code>y</code> no divide a <code>x</code>, puedes obtener un resultado sorprendente: Por ejemplo, como <code>2 * ((P+1)/2) = P+1 ≡ 1 mod[P]</code>, el valor de <code>1 / 2</code> en Cairo es <code>(P+1)/2</code> (y no 0 ó 0,5), ya que satisface la ecuación anterior.</p>
<h4 id="tipos-enteros"><a class="header" href="#tipos-enteros">Tipos enteros</a></h4>
<p>El tipo felt252 es un tipo fundamental que sirve como base para la creación de todos los tipos en la librería central.
Sin embargo, se recomienda encarecidamente a los programadores que utilicen los tipos enteros en lugar del tipo <code>felt252</code> siempre que sea posible, ya que los tipos <code>integer</code> vienen con características de seguridad añadidas que proporcionan protección extra contra posibles vulnerabilidades en el código, como comprobaciones de desbordamiento. Utilizando estos tipos de enteros, los programadores pueden asegurarse de que sus programas son más seguros y menos susceptibles a ataques u otras amenazas de seguridad.</p>
<p>Un <em>integer</em> es un número sin componente fraccionario. Esta declaración de tipo indica el número de bits que el programador puede utilizar para almacenar el entero.</p>
<p>La Tabla 3-1 muestra los tipos enteros incorporados en Cairo. Podemos usar cualquiera de estas variantes para declarar
el tipo de un valor entero.</p>
<p><span class="caption">Table 3-1: Integer Types in Cairo</span></p>
<div class="table-wrapper"><table><thead><tr><th>Length</th><th>Unsigned</th></tr></thead><tbody>
<tr><td>8-bit</td><td><code>u8</code></td></tr>
<tr><td>16-bit</td><td><code>u16</code></td></tr>
<tr><td>32-bit</td><td><code>u32</code></td></tr>
<tr><td>64-bit</td><td><code>u64</code></td></tr>
<tr><td>128-bit</td><td><code>u128</code></td></tr>
<tr><td>256-bit</td><td><code>u256</code></td></tr>
<tr><td>32-bit</td><td><code>usize</code></td></tr>
</tbody></table>
</div>
<p>Cada variante tiene un tamaño explícito. Tenga en cuenta que por ahora, el tipo <code>usize</code> es sólo un alias para <code>u32</code>; sin embargo, podría ser útil cuando en el futuro Cairo pueda ser compilado a MLIR.
Como las variables son sin signo, no pueden contener un número negativo. Este código hará que el programa entre en pánico:</p>
<pre><code class="language-rust">fn sub_u8s(x: u8, y: u8) -&gt; u8 {
    x - y
}

fn main() {
    sub_u8s(1,3);
}</code></pre>
<p>Puede escribir literales enteros en cualquiera de las formas mostradas en la Tabla 3-2. Observe
que los literales numéricos que pueden ser múltiples tipos numéricos permiten un sufijo de tipo
como <code>57_u8</code>, para designar el tipo.</p>
<p><span class="caption">Table 3-2: Integer Literals in Cairo</span></p>
<div class="table-wrapper"><table><thead><tr><th>Numeric literals</th><th>Example</th></tr></thead><tbody>
<tr><td>Decimal</td><td><code>98222</code></td></tr>
<tr><td>Hex</td><td><code>0xff</code></td></tr>
<tr><td>Octal</td><td><code>0o04321</code></td></tr>
<tr><td>Binary</td><td><code>0b01</code></td></tr>
</tbody></table>
</div>
<p>Entonces, ¿cómo saber qué tipo de entero utilizar? Intenta estimar el valor máximo que puede tener tu int y elige un buen tamaño.
La principal situación en la que usarías <code>usize</code> es al indexar algún tipo de colección.</p>
<h4 id="operaciones-numéricas"><a class="header" href="#operaciones-numéricas">Operaciones numéricas</a></h4>
<p>Cairo soporta las operaciones matemáticas básicas que esperarías para todos los tipos de enteros: suma, resta, multiplicación y resto (u256 no soporta división y resto todavía). Entero trunca hacia cero al entero más cercano. El siguiente código muestra cómo utilizar cada operación numérica en una sentencia <code>let</code>:</p>
<pre><code class="language-rust">fn main() {
     // addition
    let sum = 5_u128 + 10_u128;

    // subtraction
    let difference = 95_u128 - 4_u128;

    // multiplication
    let product = 4_u128 * 30_u128;

    // division
    let quotient = 56_u128 / 32_u128; //result is 1
    let quotient = 64_u128 / 32_u128; //result is 2

    // remainder
    let remainder = 43_u128 % 5_u128; // result is 3
}</code></pre>
<p>Cada expresión de estas sentencias utiliza un operador matemático y se evalúa a un único valor, que se asigna a una variable.</p>
<!-- TODO: Appendix operator -->
<!-- [Appendix B][appendix_b] ignore contains a list of all operators that Cairo provides. -->
<h4 id="el-tipo-booleano"><a class="header" href="#el-tipo-booleano">El tipo Booleano</a></h4>
<p>Como en la mayoría de los lenguajes de programación, un tipo booleano en Cairo tiene dos posibles valores: <code>true</code> y <code>false</code>. Los booleanos tienen un byte de tamaño. El tipo booleano en Cairo se especifica usando <code>bool</code>. Por ejemplo:</p>
<pre><code class="language-rust">fn main() {
    let t = true;

    let f: bool = false; // with explicit type annotation
}</code></pre>
<p>La principal forma de utilizar valores booleanos es a través de condicionales, como una expresión <code>if</code> expresión. Cubriremos cómo funcionan las expresiones <code>if</code> en Cairo en la sección. <a href="ch02-05-control-flow.html">“Control de flujo”</a><!-- ignore --> </p>
<h4 id="el-tipo-de-short-string"><a class="header" href="#el-tipo-de-short-string">El tipo de Short String</a></h4>
<p>Cairo no tiene un tipo nativo para strings, pero puedes almacenar caracteres formando lo que llamamos un &quot;short string&quot; dentro de <code>felt252</code>. Aquí hay algunos ejemplos de declaración de valores entre comillas simples:</p>
<pre><code class="language-rust">let my_first_char = 'C';
let my_first_string = 'Hello world';</code></pre>
<h3 id="conversión-de-tipos"><a class="header" href="#conversión-de-tipos">Conversión de Tipos</a></h3>
<p>En Cairo, puedes convertir valores entre tipos escalares comunes y <code>felt252</code> usando los métodos <code>try_into</code> e <code>into</code> proporcionados por los rasgos <code>TryInto</code> e <code>Into</code>, respectivamente.</p>
<p>El método <code>try_into</code> permite una conversión de tipos segura cuando el tipo de destino puede no encajar con el valor de origen. Ten en cuenta que <code>try_into</code> devuelve un tipo <code>Option&lt;T&gt;</code>, que tendrás que desenvolver para acceder al nuevo valor.</p>
<p>Por otro lado, el método <code>into</code> se puede utilizar para la conversión de tipos cuando el éxito está garantizado, como cuando el tipo de destino es más pequeño que el tipo de origen.</p>
<p>Para realizar la conversión, llame a <code>var.into()</code> o <code>var.try_into()</code> sobre el valor fuente para convertirlo a otro tipo. El tipo de la nueva variable debe definirse explícitamente, como se muestra en el siguiente ejemplo.</p>
<pre><code class="language-rust">use traits::TryInto;
use traits::Into;
use option::OptionTrait;

fn main(){
    let my_felt = 10;
    let my_u8: u8 = my_felt.try_into().unwrap(); // Since a felt252 might not fit in a u8, we need to unwrap the Option&lt;T&gt; type
    let my_u16: u16 = my_felt.try_into().unwrap();
    let my_u32: u32 = my_felt.try_into().unwrap();
    let my_u64: u64 = my_felt.try_into().unwrap();
    let my_u128: u128 = my_felt.try_into().unwrap();
    let my_u256: u256 = my_felt.into(); // As a felt252 is smaller than a u256, we can use the into() method
    let my_usize: usize = my_felt.try_into().unwrap();
    let my_felt2: felt252 = my_u8.into();
    let my_felt3: felt252 = my_u16.into();
}</code></pre>
<h3 id="tipos-compuestos"><a class="header" href="#tipos-compuestos">Tipos compuestos</a></h3>
<p><em>Los tipos compuestos</em> pueden agrupar varios valores en un tipo. Cairo tiene dos
tipos compuestos primitivos: Tuplas y Matrices.</p>
<h4 id="el-tipo-tupla"><a class="header" href="#el-tipo-tupla">El tipo tupla</a></h4>
<p>Una <em>tupla</em> es una forma general de agrupar un número de valores con una variedad de tipos en un tipo compuesto. Las tuplas tienen una longitud fija: una vez declaradas, no pueden aumentar ni disminuir de tamaño.</p>
<p>Se crea una tupla escribiendo una lista de valores separados por comas entre paréntesis. Cada posición de la tupla tiene un tipo, y los tipos de los distintos valores de la tupla no tienen por qué ser iguales. Hemos añadido anotaciones opcionales de tipo en este ejemplo:</p>
<pre><code class="language-rust">fn main() {
    let tup: (u32,u64,bool) = (10,20,true);
}</code></pre>
<p>La variable <code>tup</code> se vincula a toda la tupla porque una tupla se considera un único elemento compuesto. Para obtener los valores individuales de una tupla, podemos utilizar la concordancia de patrones para desestructurar un valor de tupla, así:</p>
<pre><code class="language-rust">use debug::PrintTrait;
fn main() {
    let tup = (500, 6, true);

    let (x, y, z) = tup;

    if y == 6 {
        'y is six!'.print();
    }
}</code></pre>
<p>Este programa crea primero una tupla y la asocia a la variable <code>tup</code>. A continuación, utiliza un patrón con <code>let</code> para tomar <code>tup</code> y convertirla en tres variables separadas, <code>x</code>, <code>y</code>, y <code>z</code>. Esto se llama <em>desestructuración</em> porque divide la tupla en tres partes. Finalmente, el programa imprime <code>y es seis</code> ya que el valor de <code>y</code> es <code>6</code>.</p>
<p>También podemos declarar la tupla con valor y nombre al mismo tiempo.
Por ejemplo:</p>
<pre><code class="language-rust">fn main() {
    let tup: (x: felt, y: felt) = (2,3);
}</code></pre>
<h4 id="el-tipo-array"><a class="header" href="#el-tipo-array">El tipo Array</a></h4>
<p>Otra forma de tener una colección de múltiples valores es con un <em>array</em>. A diferencia de
cada elemento de un array debe tener el mismo tipo. Puedes crear y utilizar métodos de array importando el trait <code>array::ArrayTrait</code>.</p>
<p>Una cosa importante a tener en cuenta es que los arrays son append-only. Esto significa que sólo puedes añadir elementos al final de un array.
Los arrays son, de hecho, colas cuyos valores no se pueden saltar ni modificar.
Esto tiene que ver con el hecho de que una vez que se escribe en un espacio de memoria, no se puede sobrescribir, sino sólo leer de él.</p>
<p>He aquí un ejemplo de creación de un array con 3 elementos:</p>
<pre><code class="language-rust">use array::ArrayTrait;

fn main() {
    let mut a = ArrayTrait::new();
    a.append(0);
    a.append(1);
    a.append(2);
}</code></pre>
<p>Es posible eliminar un elemento de la parte frontal de un array llamando al método <code>pop_front()</code>:</p>
<pre><code class="language-rust">
use option::OptionTrait;
use array::ArrayTrait;
use debug::PrintTrait;

fn main() {
    let mut a = ArrayTrait::new();
    a.append(10);
    a.append(1);
    a.append(2);

    let first_value = a.pop_front().unwrap();
    first_value.print();

}</code></pre>
<p>El código anterior imprimirá <code>10</code> cuando eliminemos el primer elemento añadido.</p>
<p>Puedes pasar el tipo esperado de elementos dentro del array al instanciar el array así</p>
<pre><code class="language-rust ">let mut arr = ArrayTrait::&lt;u128&gt;::new();</code></pre>
<h5 id="acceso-a-los-elementos-de-una-matriz"><a class="header" href="#acceso-a-los-elementos-de-una-matriz">Acceso a los elementos de una matriz</a></h5>
<p>Para acceder a los elementos de un array, puedes utilizar los métodos <code>get()</code> o <code>at()</code> que devuelven diferentes tipos. Utilizar <code>arr.at(index)</code> es equivalente a utilizar el operador de subíndice <code>arr[index]</code>.</p>
<p>La función <code>get</code> devuelve una <code>Option&lt;Box&lt;@T&gt;&gt;</code>, lo que significa que devuelve una opción a un tipo Box (el tipo smart-pointer de Cairo) que contiene una instantánea al elemento en el índice especificado si ese elemento existe en el array. Si el elemento no existe, <code>get</code> devuelve <code>None</code>. Este método es útil cuando esperas acceder a índices que pueden no estar dentro de los límites del array y quieres manejar tales casos con gracia sin pánicos. Las instantáneas se explicarán con más detalle en el capítulo <a href="ch03-02-references-and-snapshots.html">Referencias y Snapshots</a>.</p>
<p>La función <code>at</code>, por otro lado, devuelve directamente una instantánea al elemento en el índice especificado utilizando el operador <code>unbox()</code> para extraer el valor almacenado en una caja. Si el índice está fuera de los límites, se produce un error de pánico. Sólo debe utilizar at cuando desee que el programa entre en pánico si el índice proporcionado está fuera de los límites del array, lo que puede evitar comportamientos inesperados.</p>
<p>En resumen, usa <code>at</code> cuando quieras que el programa entre en pánico ante intentos de acceso fuera de los límites, y usa <code>get</code> cuando prefieras manejar estos casos con gracia sin entrar en pánico.</p>
<pre><code class="language-rust">fn main() {
    let mut a = ArrayTrait::new();
    a.append(0);
    a.append(1);

    let first = *a.at(0_usize);
    let second = *a.at(1_usize);
}</code></pre>
<p>En este ejemplo, la variable llamada <code>first</code> obtendrá el valor <code>0</code> porque es el valor del índice <code>0</code> del array. La variable llamada <code>second</code> obtendrá el valor <code>1</code> del índice <code>1</code> del array.</p>
<pre><code class="language-rust">use array::ArrayTrait;
use box::BoxTrait;
fn main() -&gt; u128 {
    let mut arr = ArrayTrait::&lt;u128&gt;::new();
    arr.append(100_u128);
    let length = arr.len();
    match arr.get(length - 1_usize) {
        Option::Some(x) =&gt; {
            *x.unbox()
        },
        Option::None(_) =&gt; {
            let mut data = ArrayTrait::new();
            data.append('out of bounds');
            panic(data)
        }
    } // returns 100
}</code></pre>
<p>El ejemplo anterior muestra cómo podemos hacer una gestión de errores utilizando el método <code>get</code> en lugar del método <code>at</code>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch02-01-variables-and-mutability.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="ch02-03-functions.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch02-01-variables-and-mutability.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="ch02-03-functions.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
