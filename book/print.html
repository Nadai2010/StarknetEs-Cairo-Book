<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>El lenguaje de programación Cairo </title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">El lenguaje de programación Cairo</a></li><li class="chapter-item expanded affix "><a href="ch00-01-foreword.html">Prólogo</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Introducción</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Cómo empezar</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Instalación</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hola, Mundo!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-scarb.html"><strong aria-hidden="true">1.3.</strong> Hola, Scarb!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-common-programming-concepts.html"><strong aria-hidden="true">2.</strong> Conceptos comunes de programación</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch02-01-variables-and-mutability.html"><strong aria-hidden="true">2.1.</strong> Variables y mutabilidad</a></li><li class="chapter-item expanded "><a href="ch02-02-data-types.html"><strong aria-hidden="true">2.2.</strong> Tipos de datos</a></li><li class="chapter-item expanded "><a href="ch02-03-functions.html"><strong aria-hidden="true">2.3.</strong> Funciones</a></li><li class="chapter-item expanded "><a href="ch02-04-comments.html"><strong aria-hidden="true">2.4.</strong> Comentarios</a></li><li class="chapter-item expanded "><a href="ch02-05-control-flow.html"><strong aria-hidden="true">2.5.</strong> Flujo de contro</a></li></ol></li><li class="chapter-item expanded "><a href="ch03-00-understanding-ownership.html"><strong aria-hidden="true">3.</strong> Comprender Ownership</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-what-is-ownership.html"><strong aria-hidden="true">3.1.</strong> ¿Qué es Ownership?</a></li><li class="chapter-item expanded "><a href="ch03-02-references-and-snapshots.html"><strong aria-hidden="true">3.2.</strong> Referencias e instantáneas</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-using-structs-to-structure-related-data.html"><strong aria-hidden="true">4.</strong>  Uso de estructuras para estructurar datos relacionados</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-defining-and-instantiating-structs.html"><strong aria-hidden="true">4.1.</strong> Definición e instanciación de estructuras</a></li><li class="chapter-item expanded "><a href="ch04-02-an-example-program-using-structs.html"><strong aria-hidden="true">4.2.</strong> Un programa de ejemplo usando estructuras</a></li><li class="chapter-item expanded "><a href="ch04-03-method-syntax.html"><strong aria-hidden="true">4.3.</strong> Sintaxis de métodos</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-enums-and-pattern-matching.html"><strong aria-hidden="true">5.</strong> Enums y Concordancia de Patrones</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-enums.html"><strong aria-hidden="true">5.1.</strong> Enums</a></li><li class="chapter-item expanded "><a href="ch05-02-the-match-control-flow-construct.html"><strong aria-hidden="true">5.2.</strong> La construcción del flujo de control de coincidencias</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-managing-cairo-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">6.</strong> Gestionando Proyectos Cairo con Paquetes, Crates y Módulos</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-packages-and-crates.html"><strong aria-hidden="true">6.1.</strong> Paquetes y Crates</a></li><li class="chapter-item expanded "><a href="ch06-02-defining-modules-to-control-scope.html"><strong aria-hidden="true">6.2.</strong> Definición de módulos para controlar el alcance</a></li><li class="chapter-item expanded "><a href="ch06-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">6.3.</strong> Rutas para referirse a un elemento en el Arbol de Módulos</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-generic-types.html"><strong aria-hidden="true">7.</strong> Tipos de datos Genéricos</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-generic-data-types.html"><strong aria-hidden="true">7.1.</strong> Funciones genéricas</a></li><li class="chapter-item expanded "><a href="ch07-02-traits-in-cairo.html"><strong aria-hidden="true">7.2.</strong> Traits en Cairo</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-testing-cairo-programs.html"><strong aria-hidden="true">8.</strong> Probando programas de Cairo</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-how-to-write-tests.html"><strong aria-hidden="true">8.1.</strong> Cómo escribir Tests</a></li><li class="chapter-item expanded "><a href="ch09-02-test-organization.html"><strong aria-hidden="true">8.2.</strong> Organización de Testing</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">9.</strong> Apéndice</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">9.1.</strong> A - Herramientas de desarrollo útiles</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">El lenguaje de programación Cairo </h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="el-lenguaje-de-programación-cairo"><a class="header" href="#el-lenguaje-de-programación-cairo">El lenguaje de programación Cairo</a></h1>
<p>Creado por la Comunidad Cairo y sus <a href="https://github.com/cairo-book/cairo-book.github.io">colaboradores</a>. Un agradecimiento especial a <a href="https://starkware.co/">Starkware</a> a través de <a href="https://www.onlydust.xyz/">OnlyDust</a>, y <a href="https://voyager.online/">Voyager</a> por apoyar la creación de este libro.</p>
<p>Esta versión del texto asume que estás usando Cairo v1.0.0-alpha.7 (publicado el 2023-04-13). Consulte la sección &quot;Instalación&quot; del Capítulo 1 para instalar o actualizar Cairo.</p>
<div style="break-before: page; page-break-before: always;"></div><p>En 2020, StarkWare lanzó Cairo 0, un lenguaje de programación Turing completo que admite cálculo verificable. Cairo comenzó como un lenguaje ensamblador y gradualmente se volvió más expresivo. La curva de aprendizaje fue inicialmente pronunciada, ya que Cairo 0.x era un lenguaje de bajo nivel que no abstraía por completo las primitivas criptográficas subyacentes requeridas para construir una prueba para la ejecución de un programa.</p>
<p>Con el lanzamiento de Cairo 1, la experiencia del desarrollador ha mejorado considerablemente, abstrayendo el modelo de memoria inmutable subyacente de la arquitectura de Cairo siempre que sea posible. Inspirado en Rust, Cairo 1 ha sido construido para ayudarte a crear programas comprobables sin conocimientos específicos de su arquitectura subyacente, para que puedas concentrarte en el programa en sí, aumentando la seguridad general de los programas de Cairo. Alimentado por una máquina virtual Rust, la ejecución de los programas de Cairo es ahora extremadamente rápida, lo que te permite construir una amplia suite de pruebas sin comprometer el rendimiento.</p>
<p>Los desarrolladores de blockchain que desean implementar contratos en Starknet utilizarán el lenguaje de programación Cairo para codificar sus contratos inteligentes. Esto permite al sistema operativo Starknet generar trazas de ejecución para transacciones que deben ser demostradas por un probador, que luego se verifica en Ethereum L1 antes de actualizar la raíz del estado de Starknet.</p>
<p>Sin embargo, Cairo no es solo para desarrolladores de blockchain. Como lenguaje de programación de propósito general, se puede utilizar para cualquier cálculo que se beneficie de ser demostrado en una computadora y verificado en otras máquinas con requisitos de hardware más bajos.</p>
<p>Este libro está diseñado para desarrolladores con una comprensión básica de los conceptos de programación. Es un texto amigable y accesible destinado a ayudarte a mejorar tus conocimientos de Cairo, pero también a ayudarte a desarrollar tus habilidades de programación en general. ¡Así que sumérgete y prepárate para aprender todo lo que hay que saber sobre Cairo!</p>
<ul>
<li>La comunidad de Cairo</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introducción"><a class="header" href="#introducción">Introducción</a></h1>
<h2 id="qué-es-cairo"><a class="header" href="#qué-es-cairo">¿Qué es Cairo?</a></h2>
<p>Cairo es un lenguaje de programación diseñado para una CPU virtual del mismo nombre. El aspecto único de este procesador es que no fue creado para las restricciones físicas de nuestro mundo, sino para las criptográficas, lo que lo hace capaz de probar eficientemente la ejecución de cualquier programa que se ejecute en él. Esto significa que puedes realizar operaciones que consumen mucho tiempo en una máquina en la que no confías, y comprobar el resultado muy rápidamente en una máquina más barata.
Mientras que Cairo 0 solía compilarse directamente a CASM, el ensamblador de CPU de Cairo, Cairo 1 es un lenguaje de más alto nivel. Primero compila a Sierra, una representación intermedia de Cairo que compilará más tarde a un subconjunto seguro de CASM. El objetivo de Sierra es garantizar que tu CASM sea siempre demostrable, incluso cuando falle el cálculo.</p>
<h2 id="qué-puedes-hacer-con-cairo"><a class="header" href="#qué-puedes-hacer-con-cairo">¿Qué puedes hacer con Cairo?</a></h2>
<p>Cairo te permite calcular valores confiables en máquinas no confiables. Un caso de uso importante es Starknet, una solución para la escalabilidad de Ethereum. Ethereum es una plataforma blockchain descentralizada que permite la creación de aplicaciones descentralizadas donde cada interacción entre un usuario y una d-app es verificada por todos los participantes. Starknet es una capa 2 construida sobre Ethereum. En lugar de que todos los participantes de la red verifiquen todas las interacciones del usuario, solo un nodo, llamado el probador, ejecuta los programas y genera pruebas de que los cálculos se realizaron correctamente. Estas pruebas luego son verificadas por un contrato inteligente de Ethereum, lo que requiere significativamente menos potencia de cálculo en comparación con la ejecución de las interacciones mismas. Este enfoque permite un mayor rendimiento y una reducción en los costos de transacción, pero preservando la seguridad de Ethereum.</p>
<h2 id="cuáles-son-las-diferencias-con-otros-lenguajes-de-programación"><a class="header" href="#cuáles-son-las-diferencias-con-otros-lenguajes-de-programación">¿Cuáles son las diferencias con otros lenguajes de programación?</a></h2>
<p>Cairo es bastante diferente de los lenguajes de programación tradicionales, especialmente en cuanto a los costos generales y sus ventajas principales. Tu programa se puede ejecutar de dos formas diferentes:</p>
<ul>
<li>
<p>Cuando se ejecuta por el probador, es similar a cualquier otro lenguaje. Debido a que Cairo está virtualizado y porque las operaciones no se diseñaron específicamente para la máxima eficiencia, esto puede llevar a una sobrecarga de rendimiento, pero no es la parte más relevante para optimizar.</p>
</li>
<li>
<p>Cuando el probador genera la prueba, es un poco diferente. Esto tiene que ser lo más barato posible, ya que potencialmente se podría verificar en muchas máquinas muy pequeñas. Afortunadamente, verificar es más rápido que computar y Cairo tiene algunas ventajas únicas para mejorar aún más. Uno notable es la no determinación. Este es un tema que cubrirás con más detalle más adelante en este libro, pero la idea es que teóricamente puedes usar un algoritmo diferente para verificar que para calcular. Actualmente, escribir código personalizado no determinista no está soportado para los desarrolladores, pero la biblioteca estándar aprovecha la no determinación para mejorar el rendimiento. Por ejemplo, ordenar una matriz en Cairo cuesta lo mismo que copiarla. Debido a que el verificador no ordena la matriz, simplemente verifica que está ordenada, lo que es más barato.</p>
</li>
</ul>
<p>Otro aspecto que diferencia al lenguaje es su modelo de memoria. En Cairo, el acceso a la memoria es inmutable, lo que significa que una vez que se escribe un valor en la memoria, no se puede cambiar. Cairo 1 proporciona abstracciones que ayudan a los desarrolladores a trabajar con estas limitaciones, pero no simula completamente la mutabilidad. Por lo tanto, los desarrolladores deben pensar cuidadosamente en cómo administran la memoria y las estructuras de datos en sus programas para optimizar el rendimiento.</p>
<h2 id="referencias"><a class="header" href="#referencias">Referencias</a></h2>
<ul>
<li>Arquitectura del CPU de Cairo: <a href="https://eprint.iacr.org/2021/1063">https://eprint.iacr.org/2021/1063</a></li>
<li>Cairo, Sierra y Casm: <a href="https://medium.com/nethermind-eth/under-the-hood-of-cairo-1-0-exploring-sierra-7f32808421f5">https://medium.com/nethermind-eth/under-the-hood-of-cairo-1-0-exploring-sierra-7f32808421f5</a></li>
<li>Estado no determinista:  <a href="https://twitter.com/PapiniShahar/status/1638203716535713798">https://twitter.com/PapiniShahar/status/1638203716535713798</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="instalación"><a class="header" href="#instalación">Instalación</a></h1>
<p>El primer paso es instalar Cairo. Descargaremos Cairo manualmente, utilizando el repositorio de Cairo o un script de instalación. Necesitará una conexión a Internet para la descarga.</p>
<h3 id="requisitos-previos"><a class="header" href="#requisitos-previos">Requisitos previos</a></h3>
<p>Primero deberá tener Rust y Git instalados.</p>
<pre><code class="language-bash"># Install stable Rust
rustup override set stable &amp;&amp; rustup update
</code></pre>
<p>Instalar <a href="https://git-scm.com/">Git</a>.</p>
<h2 id="instalando-cairo-con-un-script-instalador-por-fran"><a class="header" href="#instalando-cairo-con-un-script-instalador-por-fran">Instalando Cairo con un Script (<a href="https://github.com/franalgaba/cairo-installer">Instalador</a> por <a href="https://github.com/franalgaba">Fran</a>)</a></h2>
<h3 id="instalación-1"><a class="header" href="#instalación-1">Instalación</a></h3>
<p>Si deseas instalar una versión específica de Cairo en lugar de la última versión, debes establecer la variable de entorno <code>CAIRO_GIT_TAG</code> (por ejemplo,<code>export CAIRO_GIT_TAG=v1.0.0-alpha.6</code>).</p>
<pre><code class="language-bash">curl -L https://github.com/franalgaba/cairo-installer/raw/main/bin/cairo-installer | bash
</code></pre>
<p>Tras la instalación, sigue <a href="ch01-01-installation.html#set-up-your-shell-environment-for-cairo">estas instrucciones</a> para configurar tu entorno shell.</p>
<h3 id="actualización"><a class="header" href="#actualización">Actualización</a></h3>
<pre><code>rm -fr ~/.cairo
curl -L https://github.com/franalgaba/cairo-installer/raw/main/bin/cairo-installer | bash
</code></pre>
<h3 id="desinstalación"><a class="header" href="#desinstalación">Desinstalación</a></h3>
<p>Cairo se instala dentro de <code>$CAIRO_ROOT</code> (por defecto: ~/.cairo). Para desinstalarlo, basta con eliminarlo:</p>
<pre><code class="language-bash">rm -fr ~/.cairo
</code></pre>
<p>luego elimina estas tres líneas de .bashrc:</p>
<pre><code class="language-bash">export PATH=&quot;$HOME/.cairo/target/release:$PATH&quot;
</code></pre>
<p>y, por último, reinicia tu shell:</p>
<pre><code class="language-bash">exec $SHELL
</code></pre>
<h3 id="configure-su-entorno-shell-para-cairo"><a class="header" href="#configure-su-entorno-shell-para-cairo">Configure su entorno shell para Cairo</a></h3>
<ul>
<li>Define la variable de entorno <code>CAIRO_ROOT</code> para apuntar a la ruta donde
Cairo almacenará sus datos. Por defecto es <code>$HOME/.cairo</code>.
Si instaló Cairo a través de Git checkout, recomendamos
la misma ubicación donde lo clonaste.</li>
<li>Añade los ejecutables de <code>cairo-*</code> a tu <code>PATH</code> si no están ya allí.</li>
</ul>
<p>La siguiente configuración debería funcionar para la gran mayoría de usuarios en casos de uso comunes.</p>
<ul>
<li>Para <strong>bash</strong>:</li>
</ul>
<p>Los archivos de inicio de Bash predeterminados varían ampliamente entre las distribuciones, en cuanto a la fuente de ellos, las circunstancias, el orden y la configuración adicional que realizan. </p>
<p>Como tal, la forma más confiable de obtener Cairo en todos los entornos es agregar los comandos de configuración de Cairo tanto en <code>.bashrc</code> (para shells interactivos) como en el archivo de perfil que Bash utilizaría (para shells de inicio de sesión).</p>
<p>En primer lugar, agrega los comandos a <code>~/.bashrc</code> ejecutando lo siguiente en tu terminal:</p>
<pre><code>~~~ bash
echo 'export CAIRO_ROOT=&quot;$HOME/.cairo&quot;' &gt;&gt; ~/.bashrc
echo 'command -v cairo-compile &gt;/dev/null || export PATH=&quot;$CAIRO_ROOT/target/release:$PATH&quot;' &gt;&gt; ~/.bashrc
~~~

Entonces, si tiene `~/.profile`, `~/.bash_profile` o `~/.bash_login`, añada también allí los comandos.
Si no tienes ninguno de estos, añádelos a `~/.profile`.

* Para añadir a `~/.profile`:
  ~~~ bash
  echo 'export CAIRO_ROOT=&quot;$HOME/.cairo&quot;' &gt;&gt; ~/.profile
  echo 'command -v cairo-compile &gt;/dev/null || export PATH=&quot;$CAIRO_ROOT/target/release:$PATH&quot;' &gt;&gt; ~/.profile
  ~~~

* Para añadir a `~/.bash_profile`:
  ~~~ bash
  echo 'export CAIRO_ROOT=&quot;$HOME/.cairo&quot;' &gt;&gt; ~/.bash_profile
  echo 'command -v cairo-compile &gt;/dev/null || export PATH=&quot;$CAIRO_ROOT/target/release:$PATH&quot;' &gt;&gt; ~/.bash_profile
  ~~~
</code></pre>
<ul>
<li>
<p>Para <strong>Zsh</strong>:</p>
<pre><code class="language-zsh">echo 'export CAIRO_ROOT=&quot;$HOME/.cairo&quot;' &gt;&gt; ~/.zshrc
echo 'command -v cairo-compile &gt;/dev/null || export PATH=&quot;$CAIRO_ROOT/target/release:$PATH&quot;' &gt;&gt; ~/.zshrc
</code></pre>
<p>Si también desea obtener Cairo en shells de inicio de sesión no interactivos, añada también los comandos a <code>~/.zprofile</code> or <code>~/.zlogin</code>.</p>
</li>
<li>
<p>Para <strong>Fish shell</strong>:</p>
<p>Si tiene Fish 3.2.0 o posterior, ejecútelo interactivamente:</p>
<pre><code class="language-fish">set -Ux CAIRO_ROOT $HOME/.cairo
fish_add_path $CAIRO_ROOT/target/release
</code></pre>
<p>De lo contrario, ejecute el siguiente fragmento:</p>
<pre><code class="language-fish">set -Ux CAIRO_ROOT $HOME/.cairo
set -U fish_user_paths $CAIRO_ROOT/target/release $fish_user_paths
</code></pre>
</li>
</ul>
<p>En MacOS, es posible que también desee instalar <a href="https://fig.io/">Fig</a> que proporciona complementos de shell alternativos para muchas herramientas de línea de comandos con una interfaz emergente similar a IDE en la ventana de terminal.
(Tenga en cuenta que sus complementos son independientes del código base de Cairo
por lo que pueden estar ligeramente desincronizadas para cambios de interfaz de última generación).</p>
<h3 id="reinicia-tu-shell"><a class="header" href="#reinicia-tu-shell">Reinicia tu shell</a></h3>
<p>para que los cambios en <code>PATH</code> surtan efecto.</p>
<pre><code class="language-sh">exec &quot;$SHELL&quot;
</code></pre>
<h2 id="instalando-cairo-manualmente-guía-por-abdel"><a class="header" href="#instalando-cairo-manualmente-guía-por-abdel">Instalando Cairo Manualmente (<a href="https://github.com/auditless/cairo-template">Guía</a> por <a href="https://github.com/abdelhamidbakhta">Abdel</a>)</a></h2>
<h3 id="paso-1-instalar-cairo-10"><a class="header" href="#paso-1-instalar-cairo-10">Paso 1: Instalar Cairo 1.0</a></h3>
<p>Si utiliza un sistema Linux x86 y puede utilizar el binario de lanzamiento, descargue Cairo aquí:
<a href="https://github.com/starkware-libs/cairo/releases">https://github.com/starkware-libs/cairo/releases</a>.</p>
<p>Para todos los demás, recomendamos compilar Cairo desde el código fuente de la siguiente manera:</p>
<pre><code class="language-bash"># Start by defining environment variable CAIRO_ROOT
export CAIRO_ROOT=&quot;${HOME}/.cairo&quot;

# Create .cairo folder if it doesn't exist yet
mkdir $CAIRO_ROOT

# Clone the Cairo compiler in $CAIRO_ROOT (default root)
cd $CAIRO_ROOT &amp;&amp; git clone git@github.com:starkware-libs/cairo.git .

# OPTIONAL/RECOMMENDED: If you want to install a specific version of the compiler
# Fetch all tags (versions)
git fetch --all --tags
# View tags (you can also do this in the cairo compiler repository)
git describe --tags `git rev-list --tags`
# Checkout the version you want
git checkout tags/v1.0.0-alpha.6

# Generate release binaries
cargo build --all --release
</code></pre>
<p>. </p>
<p><strong>NOTA: Mantener Cairo actualizado</strong></p>
<p>Ahora que tu compilador Cairo está en un repositorio clonado, todo lo que necesitas hacer
es extraer los últimos cambios y reconstruir como sigue:</p>
<pre><code class="language-bash">cd $CAIRO_ROOT &amp;&amp; git fetch &amp;&amp; git pull &amp;&amp; cargo build --all --release
</code></pre>
<h3 id="paso-2-añade-los-ejecutables-de-cairo-10-a-tu-ruta"><a class="header" href="#paso-2-añade-los-ejecutables-de-cairo-10-a-tu-ruta">Paso 2: Añade los ejecutables de Cairo 1.0 a tu ruta</a></h3>
<pre><code class="language-bash">export PATH=&quot;$CAIRO_ROOT/target/release:$PATH&quot;
</code></pre>
<p>**NOTA: Si instala desde un binario Linux, adapte la ruta de destino en consecuencia.</p>
<h3 id="paso-3-configurar-el-servidor-de-idiomas"><a class="header" href="#paso-3-configurar-el-servidor-de-idiomas">Paso 3: Configurar el servidor de idiomas</a></h3>
<h4 id="extensión-vs-code"><a class="header" href="#extensión-vs-code">Extensión VS Code</a></h4>
<ul>
<li>Deshabilite la extensión anterior Cairo 0.x</li>
<li>Instale la extensión Cairo 1 para un correcto resaltado de sintaxis y navegación por el código.
Simplemente siga los pasos indicados <a href="https://github.com/starkware-libs/cairo/blob/main/vscode-cairo/README.md">aquí</a>.</li>
</ul>
<h4 id="servidor-de-lenguaje-de-cairo"><a class="header" href="#servidor-de-lenguaje-de-cairo">Servidor de Lenguaje de Cairo</a></h4>
<p>Desde <a href="ch01-01-installation.html#step-1-install-cairo-10-guide-by-abdel">Paso 1</a>, el binario <code>cairo-language-server</code> debe ser construido y ejecutando este comando se copiará su ruta en el portapapeles.</p>
<pre><code class="language-bash">which cairo-language-server | pbcopy
</code></pre>
<p>Actualiza el <code>languageServerPath</code> de la extensión Cairo 1.0 pegando la ruta.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="hola-mundo"><a class="header" href="#hola-mundo">Hola, Mundo</a></h2>
<p>Ahora que has instalado Cairo, es hora de escribir tu primer programa Cairo.
Es tradicional cuando se aprende un nuevo lenguaje escribir un pequeño programa que
imprima el texto <code>¡Hola, mundo!</code> en la pantalla, ¡así que haremos lo mismo aquí!</p>
<blockquote>
<p>Nota: Este libro asume una familiaridad básica con la línea de comandos. Cairo no hace
ninguna demanda específica sobre su edición o herramientas o donde vive su código, así que
si prefiere usar un entorno de desarrollo integrado (IDE) en lugar de la línea de comandos, &gt; siéntase libre de hacerlo.
la línea de comandos, siéntase libre de usar su IDE favorito. El equipo de Cairo ha desarrollado
una extensión VSCode para el lenguaje Cairo que puedes usar para obtener las características de
el servidor de lenguajes y el resaltado de código. Ver <a href="appendix-04-useful-development-tools.html">Apéndice A</a><!-- ignore -->
para más detalles.</p>
</blockquote>
<h3 id="creando-un-directorio-de-proyecto"><a class="header" href="#creando-un-directorio-de-proyecto">Creando un Directorio de Proyecto</a></h3>
<p>Empezarás creando un directorio para almacenar tu código de Cairo. A Cairo no le importa
a Cairo dónde vive tu código, pero para los ejercicios y proyectos de este libro,
sugerimos hacer un directorio <em>cairo_projects</em> en su directorio home y mantener todos
tus proyectos allí.</p>
<p>Abre un terminal e introduce los siguientes comandos para crear un directorio <em>cairo_projects</em>.
y un directorio para el proyecto &quot;¡Hola, mundo!&quot; dentro del directorio <em>cairo_projects</em>.</p>
<p>Para Linux, macOS y PowerShell en Windows, introduce esto:</p>
<pre><code class="language-console">mkdir ~/cairo_projects
cd ~/cairo_projects
mkdir hello_world
cd hello_world
</code></pre>
<p>Para Windows CMD, introduzca esto:</p>
<pre><code class="language-cmd">&gt; mkdir &quot;%USERPROFILE%\projects&quot;
&gt; cd /d &quot;%USERPROFILE%\projects&quot;
&gt; mkdir hello_world
&gt; cd hello_world
</code></pre>
<h3 id="escribiendo-y-ejecutando-un-programa-cairo"><a class="header" href="#escribiendo-y-ejecutando-un-programa-cairo">Escribiendo y Ejecutando un Programa Cairo</a></h3>
<p>A continuación, crea un nuevo archivo fuente y llámalo <em>main.cairo</em>. Los archivos Cairo siempre terminan con la extensión <em>.cairo</em>. Si usas más de una palabra en tu nombre de archivo, la convención es usar un guión bajo para separarlas. Por ejemplo_, hello_mundo.cairo_ en lugar de <em>helloworld.cairo</em>.</p>
<p>Ahora abre el archivo <em>main.cairo</em> que acabas de crear e introduce el código del Listado 1-1.</p>
<p><span class="filename">Filename: main.cairo</span></p>
<pre><code class="language-rust">use debug::PrintTrait;
fn main() {
    'Hello, world!'.print();
}</code></pre>
<p><span class="caption">Listing 1-1: A program that prints <code>Hello, world!</code></span></p>
<p>Guarde el archivo y vuelva a su ventana de terminal en el directorio
<em>~/cairo_projects/hello_world</em>. Introduzca los siguientes comandos
para compilar y ejecutar el archivo:</p>
<pre><code class="language-console">$ cairo-run main.cairo
Hello, world!
</code></pre>
<p>Independientemente de su sistema operativo, la cadena <code>Hello, world!</code> debería imprimirse en el terminal.</p>
<p>Si <code>Hello, world!</code> se imprime, ¡enhorabuena! Has escrito oficialmente un programa en Cairo. Eso te convierte en un programador de Cairo ¡Bienvenido!</p>
<h3 id="anatomía-de-un-programa-cairo"><a class="header" href="#anatomía-de-un-programa-cairo">Anatomía de un Programa Cairo</a></h3>
<p>Revisemos este programa &quot;¡Hola, mundo!&quot; en detalle. Aquí está la primera pieza del puzzle:</p>
<pre><code class="language-rust">fn main() {

}</code></pre>
<p>Estas líneas definen una función llamada <code>main</code>. La función <code>main</code> es especial: es
es siempre el primer código que se ejecuta en cada programa ejecutable de El Cairo. Aquí, la
primera línea declara una función llamada <code>main</code> que no tiene parámetros y devuelve
nada. Si hubiera parámetros, irían dentro de los paréntesis <code>()</code>.</p>
<p>El cuerpo de la función está envuelto en <code>{}</code>. Cairo requiere llaves alrededor de todos los
cuerpos de función. Es de buen estilo colocar la llave de apertura en la misma línea que la declaración de la función, añadiendo un espacio en medio.</p>
<blockquote>
<p>Nota: Si quieres mantener un estilo estándar en todos los proyectos de Cairo, puedes
usar la herramienta de formateo automático llamada <code>cairo-format</code> para formatear tu código 
en un estilo particular (más sobre <code>cairo-format</code> en
<a href="appendix-04-useful-development-tools.html">Apéndice A</a><!-- ignore -->). El equipo de Cairo ha incluido esta herramienta
con la distribución estándar de Cairo, como lo es <code>cairo-run</code>, así que ya debería estar
¡instalada en tu ordenador!</p>
</blockquote>
<p>Antes de la declaración de la función principal, la línea <code>use debug::PrintTrait;</code> es responsable de importar un elemento definido en otro módulo. En este caso, estamos importando el elemento <code>PrintTrait</code> de la biblioteca central de Cairo. Haciendo esto, ganamos la habilidad de usar el método <code>print()</code> en tipos de datos que son compatibles con la impresión.</p>
<p>El cuerpo de la función <code>main</code> contiene el siguiente código:</p>
<pre><code class="language-rust">    'Hello, world!'.print();</code></pre>
<p>Esta línea hace todo el trabajo en este pequeño programa: imprime texto en la pantalla.
pantalla. Hay cuatro detalles importantes a tener en cuenta aquí.</p>
<p>En primer lugar, el estilo de Cairo es hacer sangrías con cuatro espacios, no con una tabulación.</p>
<p>Segundo, la función <code>print()</code> es un método del trait <code>PrintTrait</code>. Este trait se importa de la librería del núcleo de Cairo, y define cómo imprimir valores en la pantalla para diferentes tipos de datos. En nuestro caso, nuestro texto está definido como una &quot;cadena corta&quot;, que es una cadena ASCII que puede caber en el tipo de datos básico de Cairo, que es el tipo <code>felt252</code>. Al llamar a <code>Hello, world!'.print()</code>, estamos llamando al método <code>print()</code> de la implementación <code>felt252</code> del rasgo <code>PrintTrait</code>.</p>
<p>En tercer lugar, ves la cadena corta <code>'Hello, world!'</code> Pasamos esta cadena corta como argumento
a <code>print()</code>, y la cadena corta se imprime en la pantalla.</p>
<p>Cuarto, terminamos la línea con un punto y coma (<code>;</code>), que indica que esta
expresión ha terminado y la siguiente está lista para comenzar. La mayoría de las líneas de código de Cairo terminan con punto y coma.</p>
<p>Sólo ejecutar con <code>cairo-run</code> está bien para programas simples, pero a medida que tu proyecto
proyecto crezca, querrá manejar todas las opciones y hacer fácil compartir su código.
código. A continuación, te presentaremos la herramienta Scarb, que te ayudará a escribir
programas Cairo del mundo real.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hello-scarb"><a class="header" href="#hello-scarb">Hello, Scarb</a></h1>
<p>Scarb is the Cairo package manager and heavily inspired by <a href="https://doc.rust-lang.org/cargo/">Cargo</a>, Rust’s build system and package manager.</p>
<p>Scarb handles a lot of tasks for you, such as building your code (either pure Cairo or Starknet contracts), downloading the libraries your code depends on, and building those libraries.</p>
<p>If we were to build the 'Hello, world!' project using Scarb, only the part of Scarb that handles building the code would be utilized, since the program doesn't require any external dependencies. As you write more complex Cairo programs, you’ll add dependencies, and if you start a project using Scarb, adding dependencies will be much easier to do.</p>
<p>Let's start by installing Scarb.</p>
<h2 id="installing-scarb"><a class="header" href="#installing-scarb">Installing Scarb</a></h2>
<h3 id="requirements"><a class="header" href="#requirements">Requirements</a></h3>
<p>Scarb requires a Git executable to be available in the <code>PATH</code> environment variable.</p>
<h3 id="installation"><a class="header" href="#installation">Installation</a></h3>
<p>As for now, Scarb needs manual installation with the following steps:</p>
<ul>
<li>
<p>Download the release archive matching your operating system and CPU architecture, from <a href="https://github.com/software-mansion/scarb/releases">Scarb releases on GitHub</a></p>
</li>
<li>
<p>Extract it to a location where you would like to have Scarb installed, e.g. <code>~/scarb</code></p>
</li>
<li>
<p>Add path to the <code>scarb/bin</code> directory to your <code>PATH</code> environment variable.</p>
<p>This depend on what shell you are using. Let’s take the example of <a href="https://ohmyz.sh/">zsh</a> and you have extracted Scarb to <code>~/scarb</code>:</p>
<ul>
<li>Open <code>~/.zshrc</code> file in your favorite editor</li>
<li>Add the following line to the end of the file: <code>export PATH=&quot;$PATH:~/scarb/bin&quot;</code></li>
</ul>
</li>
<li>
<p>Verify installation by running the following command in new terminal session, it should print both Scarb and Cairo language versions, e.g:</p>
<pre><code class="language-bash">$ scarb --version
scarb 0.1.0 (289137c24 2023-03-28)
cairo: 1.0.0-alpha.6
</code></pre>
</li>
</ul>
<h3 id="creating-a-project-with-scarb"><a class="header" href="#creating-a-project-with-scarb">Creating a Project with Scarb</a></h3>
<p>Let’s create a new project using Scarb and look at how it differs from our original “Hello, world!” project.</p>
<p>Navigate back to your projects directory (or wherever you decided to store your code). Then run the following:</p>
<pre><code class="language-bash">$ scarb new hello_scarb
</code></pre>
<p>It creates a new directory and project called hello_scarb. We’ve named our project hello_scarb, and Scarb creates its files in a directory of the same name.</p>
<p>Go into the hello_scarb directory with the command <code>cd hello_scarb</code>. You’ll see that Scarb has generated two files and one directory for us: a <code>Scarb.toml</code> file and a src directory with a <code>lib.cairo</code> file inside.</p>
<p>It has also initialized a new Git repository along with a <code>.gitignore</code> file</p>
<blockquote>
<p>Note: Git is a common version control system. You can stop using version control system by using the <code>--vcs</code> flag.
Run <code>scarb new -help</code> to see the available options.</p>
</blockquote>
<p>Open <em>Scarb.toml</em> in your text editor of choice. It should look similar to the code in Listing 1-2.</p>
<p><span class="filename">Filename: Scarb.toml</span></p>
<pre><code class="language-toml">[package]
name = &quot;hello_scarb&quot;
version = &quot;0.1.0&quot;

# See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest

[dependencies]
# foo = { path = &quot;vendor/foo&quot; }
</code></pre>
<p><span class="caption">Listing 1-2: Contents of Scarb.toml generated by <code>scarb new</code></span></p>
<p>This file is in the <a href="https://toml.io/">TOML</a> (Tom’s Obvious, Minimal Language) format, which is Scarb’s configuration format.</p>
<p>The first line, <code>[package]</code>, is a section heading that indicates that the following statements are configuring a package. As we add more information to this file, we’ll add other sections.</p>
<p>The next two lines set the configuration information Scarb needs to compile your program: the name and the version of Scarb to use.</p>
<p>The last line, <code>[dependencies]</code>, is the start of a section for you to list any of your project’s dependencies. In Cairo, packages of code are referred to as crates. We won’t need any other crates for this project.</p>
<p>The other file created by Scarb is <code>src/lib.cairo</code>, let's delete all the content and put in the following content, we will explain the reason later.</p>
<pre><code class="language-rust">mod hello_scarb;</code></pre>
<p>Then create a new file called <code>src/hello_scarb.cairo</code> and put the following code in it:</p>
<p><span class="filename">Filename: src/hello_scarb.cairo</span></p>
<pre><code class="language-rust">use debug::PrintTrait;
fn main() {
    'Hello, Scarb!'.print();
}</code></pre>
<p>We have just created a file called <code>lib.cairo</code>, which contains a module declaration referencing another module named &quot;hello_scarb&quot;, as well as the file <code>hello_scarb.cairo</code>,containing the implementation details of the &quot;hello_scarb&quot; module.</p>
<p>Scarb requires your source files to be located within the src directory.</p>
<p>The top-level project directory is reserved for README files, license information, configuration files, and any other non-code-related content.
Scarb ensures a designated location for all project components, maintaining a structured organization.</p>
<p>If you started a project that doesn’t use Scarb, as we did with the “Hello, world!” project, you can convert it to a project that does use Scarb. Move the project code into the src directory and create an appropriate <code>Scarb.toml</code> file.</p>
<h3 id="building-a-scarb-project"><a class="header" href="#building-a-scarb-project">Building a Scarb Project</a></h3>
<p>From your hello_scarb directory, build your project by entering the following command:</p>
<pre><code class="language-bash">$ scarb build
   Compiling hello_scarb v0.1.0 (file:///projects/Scarb.toml)
    Finished release target(s) in 0 seconds
</code></pre>
<p>This command creates a <code>sierra</code> file in <code>target/release</code>, let's ignore the <code>sierra</code> file for now.</p>
<p>If you have installed Cairo correctly, you should be able to run and see the following output:</p>
<pre><code class="language-bash">$ cairo-run src/lib.cairo
[DEBUG] Hello, Scarb!                   (raw: 5735816763073854913753904210465)

Run completed successfully, returning []
</code></pre>
<blockquote>
<p>Note: You will notice here that we didn't use a Scarb command, but rather a command from the Cairo binaries directly.
As Scarb doesn't have a command to execute Cairo code, yet we have to use the <code>cairo-run</code> command directly.
We will use this command in the rest of the tutorial, but we will also use Scarb commands to initialize projects.</p>
</blockquote>
<h3 id="defining-custom-scripts"><a class="header" href="#defining-custom-scripts">Defining Custom Scripts</a></h3>
<p>We can define scarb scripts in <code>Scarb.toml</code> file, which can be used to execute custom shell scripts.
Add the following line to your <code>Scarb.toml</code> file:</p>
<pre><code class="language-toml">[scripts]
run-lib = &quot;cairo-run src/lib.cairo&quot;
</code></pre>
<p>Now you can run the following command to run the project:</p>
<pre><code class="language-bash">$ scarb run run-lib
[DEBUG] Hello, Scarb!                   (raw: 5735816763073854913753904210465)

Run completed successfully, returning []
</code></pre>
<p>Using <code>scarb run</code> is a convenient way to run custom shell scripts that can be useful to run files and test your project.</p>
<p>Let’s recap what we’ve learned so far about Scarb:</p>
<ul>
<li>We can create a project using <code>scarb new</code>.</li>
<li>We can build a project using <code>scarb build</code> to generate the compiled Sierra code.</li>
<li>We can define custom scripts in <code>Scarb.toml</code> and call them with the <code>scarb run</code> command.</li>
</ul>
<p>An additional advantage of using Scarb is that the commands are the same no matter which operating system you’re working on. So, at this point, we’ll no longer provide specific instructions for Linux and macOS versus Windows.</p>
<h1 id="summary"><a class="header" href="#summary">Summary</a></h1>
<p>You’re already off to a great start on your Cairo journey! In this chapter, you’ve learned how to:</p>
<ul>
<li>Install the latest stable version of Cairo</li>
<li>Write and run a “Hello, world!” program using <code>cairo-run</code> directly</li>
<li>Create and run a new project using the conventions of Scarb</li>
</ul>
<p>This is a great time to build a more substantial program to get used to reading and writing Cairo code.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="common-programming-concepts"><a class="header" href="#common-programming-concepts">Common Programming Concepts</a></h1>
<p>This chapter covers concepts that appear in almost every programming language and how they work in Cairo. Many programming languages have much in common at their core. None of the concepts presented in this chapter are unique to Cairo, but we’ll discuss them in the context of Cairo and explain the conventions around using these concepts.</p>
<p>Specifically, you’ll learn about variables, basic types, functions, comments, and control flow. These foundations will be in every Cairo program, and learning them early will give you a strong core to start from.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="variables-and-mutability"><a class="header" href="#variables-and-mutability">Variables and Mutability</a></h2>
<p>Cairo uses an immutable memory model, meaning that once a memory cell is written to,
it can't be overwritten but only read from. To reflect this immutable memory model,
variables in Cairo are immutable by default.
However, the language abstracts this model and gives you the option to make your
variables mutable. Let’s explore how and why Cairo enforces immutability, and how
you can make your variables mutable.</p>
<p>When a variable is immutable, once a value is bound to a name, you can’t change
that value. To illustrate this, generate a new project called <em>variables</em> in
your <em>cairo_projects</em> directory by using <code>scarb new variables</code>.</p>
<p>Then, in your new <em>variables</em> directory, open <em>src/lib.cairo</em> and replace its
code with the following code, which won’t compile just yet:</p>
<p><span class="filename">Filename: src/lib.cairo</span></p>
<pre><code class="language-rust">use debug::PrintTrait;
fn main() {
    let x = 5;
    x.print();
    x = 6;
    x.print();
}</code></pre>
<p>Save and run the program using <code>cairo-run src/lib.cairo</code>. You should receive an error message
regarding an immutability error, as shown in this output:</p>
<pre><code class="language-console">error: Cannot assign to an immutable variable.
 --&gt; lib.cairo:5:5
    x = 6;
    ^***^

Error: failed to compile: src/lib.cairo
</code></pre>
<p>This example shows how the compiler helps you find errors in your programs.
Compiler errors can be frustrating, but really they only mean your program
isn’t safely doing what you want it to do yet; they do <em>not</em> mean that you’re
not a good programmer! Experienced Caironautes still get compiler errors.</p>
<p>You received the error message <code>Cannot assign to an immutable variable.</code>
because you tried to assign a second value to the immutable <code>x</code> variable.</p>
<p>It’s important that we get compile-time errors when we attempt to change a
value that’s designated as immutable because this specific situation can lead to
bugs. If one part of our code operates on the assumption that a value will
never change and another part of our code changes that value, it’s possible
that the first part of the code won’t do what it was designed to do. The cause
of this kind of bug can be difficult to track down after the fact, especially
when the second piece of code changes the value only <em>sometimes</em>. The Cairo
compiler guarantees that when you state that a value won’t change, it really
won’t change, so you don’t have to keep track of it yourself. Your code is thus
easier to reason through.</p>
<p>But mutability can be very useful, and can make code more convenient to write.
Although variables are immutable by default, you can make them mutable by
adding <code>mut</code> in front of the variable name. Adding <code>mut</code> also conveys
intent to future readers of the code by indicating that other parts of the code
will be changing this variable’s value.</p>
<p>However, you might be wondering at this point what exactly happens when a variable
is declared as <code>mut</code>, as we previously mentioned that Cairo's memory is immutable.
The answer is that Cairo's memory is immutable, but the memory address the variable points
to can be changed. Upon examining the low-level Cairo Assembly code, it becomes clear that
variable mutation is implemented as syntactic sugar, which translates mutation operations
into a series of steps equivalent to variable shadowing. The only difference is that at the Cairo
level, the variable is not redeclared so its type cannot change.</p>
<p>For example, let’s change <em>src/lib.cairo</em> to the following:</p>
<p><span class="filename">Filename: src/lib.cairo</span></p>
<pre><code class="language-rust">use debug::PrintTrait;
fn main() {
    let mut x = 5;
    x.print();
    x = 6;
    x.print();
}</code></pre>
<p>When we run the program now, we get this:</p>
<pre><code class="language-console">❯ cairo-run src/lib.cairo
[DEBUG]	                              	(raw: 5)

[DEBUG]	                              	(raw: 6)

Run completed successfully, returning []
</code></pre>
<p>We’re allowed to change the value bound to <code>x</code> from <code>5</code> to <code>6</code> when <code>mut</code> is
used. Ultimately, deciding whether to use mutability or not is up to you and
depends on what you think is clearest in that particular situation.</p>
<h3 id="constants"><a class="header" href="#constants">Constants</a></h3>
<p>Like immutable variables, <em>constants</em> are values that are bound to a name and
are not allowed to change, but there are a few differences between constants
and variables.</p>
<p>First, you aren’t allowed to use <code>mut</code> with constants. Constants aren’t just
immutable by default—they’re always immutable. You declare constants using the
<code>const</code> keyword instead of the <code>let</code> keyword, and the type of the value <em>must</em>
be annotated. We’ll cover types and type annotations in the next section,
<a href="ch03-02-data-types.html#data-types">“Data Types”</a><!-- ignore -->, so don’t worry about the details
right now. Just know that you must always annotate the type.</p>
<p>Constants can only be declared in the global scope, which makes
them useful for values that many parts of code need to know about.</p>
<p>The last difference is that constants may be set only to a constant expression,
not the result of a value that could only be computed at runtime. Only literal constants
are currently supported.</p>
<p>Here’s an example of a constant declaration:</p>
<pre><code class="language-rust">const ONE_HOUR_IN_SECONDS: u32 = 3600_u32;</code></pre>
<p>Cairo's naming convention for constants is to use all uppercase with
underscores between words.</p>
<p>Constants are valid for the entire time a program runs, within the scope in
which they were declared. This property makes constants useful for values in
your application domain that multiple parts of the program might need to know
about, such as the maximum number of points any player of a game is allowed to
earn, or the speed of light.</p>
<p>Naming hardcoded values used throughout your program as constants is useful in
conveying the meaning of that value to future maintainers of the code. It also
helps to have only one place in your code you would need to change if the
hardcoded value needed to be updated in the future.</p>
<h3 id="shadowing"><a class="header" href="#shadowing">Shadowing</a></h3>
<p>Variable shadowing refers to the declaration of a
new variable with the same name as a previous variable. Caironautes say that the
first variable is <em>shadowed</em> by the second, which means that the second
variable is what the compiler will see when you use the name of the variable.
In effect, the second variable overshadows the first, taking any uses of the
variable name to itself until either it itself is shadowed or the scope ends.
We can shadow a variable by using the same variable’s name and repeating the
use of the <code>let</code> keyword as follows:</p>
<p><span class="filename">Filename: src/lib.cairo</span></p>
<pre><code class="language-swift">use debug::PrintTrait;
fn main() {
    let x = 5;
    let x = x + 1;
    {
        let x = x * 2;
        'Inner scope x value is:'.print();
        x.print()
    }
    'Outer scope x value is:'.print();
    x.print();
}
</code></pre>
<p>This program first binds <code>x</code> to a value of <code>5</code>. Then it creates a new variable
<code>x</code> by repeating <code>let x =</code>, taking the original value and adding <code>1</code> so the
value of <code>x</code> is then <code>6</code>. Then, within an inner scope created with the curly
brackets, the third <code>let</code> statement also shadows <code>x</code> and creates a new
variable, multiplying the previous value by <code>2</code> to give <code>x</code> a value of <code>12</code>.
When that scope is over, the inner shadowing ends and <code>x</code> returns to being <code>6</code>.
When we run this program, it will output the following:</p>
<pre><code class="language-console">cairo-run src/lib.cairo
[DEBUG]	Inner scope x value is:        	(raw: 7033328135641142205392067879065573688897582790068499258)

[DEBUG]
                                      	(raw: 12)

[DEBUG]	Outer scope x value is:        	(raw: 7610641743409771490723378239576163509623951327599620922)

[DEBUG]	                              	(raw: 6)

Run completed successfully, returning []
</code></pre>
<p>Shadowing is different from marking a variable as <code>mut</code> because we’ll get a
compile-time error if we accidentally try to reassign to this variable without
using the <code>let</code> keyword. By using <code>let</code>, we can perform a few transformations
on a value but have the variable be immutable after those transformations have
been completed.</p>
<p>Another distinction between <code>mut</code> and shadowing is that when we use the <code>let</code> keyword again,
we are effectively creating a new variable, which allows us to change the type of the
value while reusing the same name. As mentioned before, variable shadowing and mutable variables
are equivalent at the lower level.
The only difference is that by shadowing a variable, the compiler will not complaing
if you change its type. For example, say our program performs a type conversion between the
<code>u64</code> and <code>felt252</code> types.</p>
<pre><code class="language-rust">use debug::PrintTrait;
use traits::Into;
fn main() {
    let x = 2_u64;
    x.print();
    let x = x.into(); // converts x to a felt.
    x.print()
}</code></pre>
<p>The first <code>x</code> variable has a <code>u64</code> type while the second <code>x</code> variable has a <code>felt252</code> type.
Shadowing thus spares us from having to come up with different names, such as <code>x_u64</code>
and <code>x_felt252</code>; instead, we can reuse the simpler <code>x</code> name. However, if we try to use
<code>mut</code> for this, as shown here, we’ll get a compile-time error:</p>
<pre><code class="language-rust">use debug::PrintTrait;
use traits::Into;
fn main() {
    let mut x = 2_u64;
    x.print();
    x = x.into();
    x.print()
}</code></pre>
<p>The error says we’re were expecting a <code>u64</code> (the original type) but we got a different type:</p>
<pre><code class="language-console">❯ cairo-run src/lib.cairo
error: Unexpected argument type. Expected: &quot;core::integer::u64&quot;, found: &quot;core::felt252&quot;.
 --&gt; lib.cairo:6:9
    x = x.into();
        ^******^

Error: failed to compile: src/lib.cairo
</code></pre>
<p>Now that we’ve explored how variables work, let’s look at more data types they
can have.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="data-types"><a class="header" href="#data-types">Data Types</a></h2>
<p>Every value in Cairo is of a certain <em>data type</em>, which tells Cairo what kind of
data is being specified so it knows how to work with that data. This section covers two subsets of data types: scalars and compounds.</p>
<p>Keep in mind that Cairo is a <em>statically typed</em> language, which means that it
must know the types of all variables at compile time. The compiler can usually infer the desired type based on the value and its usage. In cases
when many types are possible, we can use a cast method where we specify the desired output type.</p>
<pre><code class="language-Rust">use traits::TryInto;
use option::OptionTrait;
fn main(){
    let x = 3;
    let y:u32 = x.try_into().unwrap();
}
</code></pre>
<p>You’ll see different type annotations for other data types.</p>
<h3 id="scalar-types"><a class="header" href="#scalar-types">Scalar Types</a></h3>
<p>A <em>scalar</em> type represents a single value. Cairo has three primary scalar types:
felts, integers, and booleans. You may recognize
these from other programming languages. Let’s jump into how they work in Cairo.</p>
<h4 id="felt-type"><a class="header" href="#felt-type">Felt Type</a></h4>
<p>In Cairo, if you don't specify the type of a variable or argument, its type defaults to a field element, represented by the keyword <code>felt252</code>. In the context of Cairo, when we say “a field element” we mean an integer in the range <code>0 &lt;= x &lt; P</code>,
where <code>P</code> is a very large prime number currently equal to <code>P = 2^{251} + 17 * 2^{192}+1</code>. When adding, subtracting, or multiplying, if the result falls outside the specified range of the prime number, an overflow occurs, and an appropriate multiple of P is added or subtracted to bring the result back within the range (i.e., the result is computed modulo P).</p>
<p>The most important difference between integers and field elements is division: Division of field elements (and therefore division in Cairo) is unlike regular CPUs division, where
integer division <code>x / y</code> is defined as <code>[x/y]</code> where the integer part of the quotient is returned (so you get <code>7 / 3 = 2</code>) and it may or may not satisfy the equation <code>(x / y) * y == x</code>,
depending on the divisibility of <code>x</code> by <code>y</code>.</p>
<p>In Cairo, the result of <code>x/y</code> is defined to always satisfy the equation <code>(x / y) * y == x</code>. If y divides x as integers, you will get the expected result in Cairo (for example <code>6 / 2</code>
will indeed result in <code>3</code>).
But when y does not divide x, you may get a surprising result: For example, since <code>2 * ((P+1)/2) = P+1 ≡ 1 mod[P]</code>, the value of <code>1 / 2</code> in Cairo is <code>(P+1)/2</code> (and not 0 or 0.5), as it satisfies the above equation.</p>
<h4 id="integer-types"><a class="header" href="#integer-types">Integer Types</a></h4>
<p>The felt252 type is a fundamental type that serves as the basis for creating all types in the core library.
However, it is highly recommended for programmers to use the integer types instead of the <code>felt252</code> type whenever possible, as the <code>integer</code> types come with added security features that provide extra protection against potential vulnerabilities in the code, such as overflow checks. By using these integer types, programmers can ensure that their programs are more secure and less susceptible to attacks or other security threats.
An <em>integer</em> is a number without a fractional component. This type declaration indicates the number of bits the programmer can use to store the integer.
Table 3-1 shows
the built-in integer types in Cairo. We can use any of these variants to declare
the type of an integer value.</p>
<p><span class="caption">Table 3-1: Integer Types in Cairo</span></p>
<div class="table-wrapper"><table><thead><tr><th>Length</th><th>Unsigned</th></tr></thead><tbody>
<tr><td>8-bit</td><td><code>u8</code></td></tr>
<tr><td>16-bit</td><td><code>u16</code></td></tr>
<tr><td>32-bit</td><td><code>u32</code></td></tr>
<tr><td>64-bit</td><td><code>u64</code></td></tr>
<tr><td>128-bit</td><td><code>u128</code></td></tr>
<tr><td>256-bit</td><td><code>u256</code></td></tr>
<tr><td>32-bit</td><td><code>usize</code></td></tr>
</tbody></table>
</div>
<p>Each variant has an explicit size. Note that for now, the <code>usize</code> type is just an alias for <code>u32</code>; however, it might be useful when in the future Cairo can be compiled to MLIR.
As variables are unsigned, they can't contain a negative number. This code will cause the program to panic:</p>
<pre><code class="language-rust">fn sub_u8s(x: u8, y: u8) -&gt; u8 {
    x - y
}

fn main() {
    sub_u8s(1,3);
}</code></pre>
<p>You can write integer literals in any of the forms shown in Table 3-2. Note
that number literals that can be multiple numeric types allow a type suffix,
such as <code>57_u8</code>, to designate the type.</p>
<p><span class="caption">Table 3-2: Integer Literals in Cairo</span></p>
<div class="table-wrapper"><table><thead><tr><th>Numeric literals</th><th>Example</th></tr></thead><tbody>
<tr><td>Decimal</td><td><code>98222</code></td></tr>
<tr><td>Hex</td><td><code>0xff</code></td></tr>
<tr><td>Octal</td><td><code>0o04321</code></td></tr>
<tr><td>Binary</td><td><code>0b01</code></td></tr>
</tbody></table>
</div>
<p>So how do you know which type of integer to use? Try to estimate the max value your int can have and choose the good size.
The primary situation in which you’d use <code>usize</code> is when indexing some sort of collection.</p>
<h4 id="numeric-operations"><a class="header" href="#numeric-operations">Numeric Operations</a></h4>
<p>Cairo supports the basic mathematical operations you’d expect for all the integer
types: addition, subtraction, multiplication, division, and remainder (u256 doesn't support division and remainder yet). Integer
division truncates toward zero to the nearest integer. The following code shows
how you’d use each numeric operation in a <code>let</code> statement:</p>
<pre><code class="language-rust">fn main() {
     // addition
    let sum = 5_u128 + 10_u128;

    // subtraction
    let difference = 95_u128 - 4_u128;

    // multiplication
    let product = 4_u128 * 30_u128;

    // division
    let quotient = 56_u128 / 32_u128; //result is 1
    let quotient = 64_u128 / 32_u128; //result is 2

    // remainder
    let remainder = 43_u128 % 5_u128; // result is 3
}</code></pre>
<p>Each expression in these statements uses a mathematical operator and evaluates
to a single value, which is then bound to a variable.</p>
<!-- TODO: Appendix operator -->
<!-- [Appendix B][appendix_b] ignore contains a list of all operators that Cairo provides. -->
<h4 id="the-boolean-type"><a class="header" href="#the-boolean-type">The Boolean Type</a></h4>
<p>As in most other programming languages, a Boolean type in Cairo has two possible
values: <code>true</code> and <code>false</code>. Booleans are one byte in size. The Boolean type in
Cairo is specified using <code>bool</code>. For example:</p>
<pre><code class="language-rust">fn main() {
    let t = true;

    let f: bool = false; // with explicit type annotation
}</code></pre>
<p>The main way to use Boolean values is through conditionals, such as an <code>if</code>
expression. We’ll cover how <code>if</code> expressions work in Cairo in the <a href="ch02-05-control-flow.html">“Control
Flow”</a><!-- ignore --> section.</p>
<h4 id="the-short-string-type"><a class="header" href="#the-short-string-type">The Short String Type</a></h4>
<p>Cairo doesn't have a native type for strings, but you can store characters forming what we call a &quot;short string&quot; inside <code>felt252</code>s. Here are
some examples of declaring values by puting them beteen single quotes:</p>
<pre><code class="language-rust">let my_first_char = 'C';
let my_first_string = 'Hello world';</code></pre>
<h3 id="type-casting"><a class="header" href="#type-casting">Type casting</a></h3>
<p>In Cairo, you can convert values between common scalar types and <code>felt252</code> using the <code>try_into</code> and <code>into</code> methods provided by the <code>TryInto</code> and <code>Into</code> traits, respectively.</p>
<p>The <code>try_into</code> method allows for safe type casting when the target type might not fit the source value. Keep in mind that <code>try_into</code> returns an <code>Option&lt;T&gt;</code> type, which you'll need to unwrap to access the new value.</p>
<p>On the other hand, the <code>into</code> method can be used for type casting when success is guaranteed, such as when the destination type is smaller than the source type.</p>
<p>To perform the conversion, call <code>var.into()</code> or <code>var.try_into()</code> on the source value to cast it to another type. The new variable's type must be explicitly defined, as demonstrated in the example below.</p>
<pre><code class="language-rust">use traits::TryInto;
use traits::Into;
use option::OptionTrait;

fn main(){
    let my_felt = 10;
    let my_u8: u8 = my_felt.try_into().unwrap(); // Since a felt252 might not fit in a u8, we need to unwrap the Option&lt;T&gt; type
    let my_u16: u16 = my_felt.try_into().unwrap();
    let my_u32: u32 = my_felt.try_into().unwrap();
    let my_u64: u64 = my_felt.try_into().unwrap();
    let my_u128: u128 = my_felt.try_into().unwrap();
    let my_u256: u256 = my_felt.into(); // As a felt252 is smaller than a u256, we can use the into() method
    let my_usize: usize = my_felt.try_into().unwrap();
    let my_felt2: felt252 = my_u8.into();
    let my_felt3: felt252 = my_u16.into();
}</code></pre>
<h3 id="compound-types"><a class="header" href="#compound-types">Compound Types</a></h3>
<p><em>Compound types</em> can group multiple values into one type. Cairo has two
primitive compound types: tuples and arrays.</p>
<h4 id="the-tuple-type"><a class="header" href="#the-tuple-type">The Tuple Type</a></h4>
<p>A <em>tuple</em> is a general way of grouping together a number of values with a
variety of types into one compound type. Tuples have a fixed length: once
declared, they cannot grow or shrink in size.</p>
<p>We create a tuple by writing a comma-separated list of values inside
parentheses. Each position in the tuple has a type, and the types of the
different values in the tuple don’t have to be the same. We’ve added optional
type annotations in this example:</p>
<pre><code class="language-rust">fn main() {
    let tup: (u32,u64,bool) = (10,20,true);
}</code></pre>
<p>The variable <code>tup</code> binds to the entire tuple because a tuple is considered a
single compound element. To get the individual values out of a tuple, we can
use pattern matching to destructure a tuple value, like this:</p>
<pre><code class="language-rust">use debug::PrintTrait;
fn main() {
    let tup = (500, 6, true);

    let (x, y, z) = tup;

    if y == 6 {
        'y is six!'.print();
    }
}</code></pre>
<p>This program first creates a tuple and binds it to the variable <code>tup</code>. It then
uses a pattern with <code>let</code> to take <code>tup</code> and turn it into three separate
variables, <code>x</code>, <code>y</code>, and <code>z</code>. This is called <em>destructuring</em> because it breaks
the single tuple into three parts. Finally, the program prints <code>y is six</code> as the value of
<code>y</code> is <code>6</code>.</p>
<p>We can also declare the tuple with value and name at the same time.
For example:</p>
<pre><code class="language-rust">fn main() {
    let tup: (x: felt, y: felt) = (2,3);
}</code></pre>
<h4 id="the-array-type"><a class="header" href="#the-array-type">The Array Type</a></h4>
<p>Another way to have a collection of multiple values is with an <em>array</em>. Unlike
a tuple, every element of an array must have the same type. You can create and use array methods by importing the <code>array::ArrayTrait</code> trait.</p>
<p>An important thing to note is that arrays are append-only. This means that you can only add elements to the end of an array.
Arrays are, in fact, queues whose values can't be popped nor modified.
This has to do with the fact that once a memory slot is written to, it cannot be overwritten, but only read from it.</p>
<p>Here is an example of creation of an array with 3 elements:</p>
<pre><code class="language-rust">use array::ArrayTrait;

fn main() {
    let mut a = ArrayTrait::new();
    a.append(0);
    a.append(1);
    a.append(2);
}</code></pre>
<p>It is possible to remove an element from the front of an array by calling the <code>pop_front()</code> method:</p>
<pre><code class="language-rust">
use option::OptionTrait;
use array::ArrayTrait;
use debug::PrintTrait;

fn main() {
    let mut a = ArrayTrait::new();
    a.append(10);
    a.append(1);
    a.append(2);

    let first_value = a.pop_front().unwrap();
    first_value.print();

}</code></pre>
<p>The above code will print <code>10</code> as we remove the first element that was added.</p>
<p>You can pass the expected type of items inside the array when instantiating the array like this</p>
<pre><code class="language-rust ">let mut arr = ArrayTrait::&lt;u128&gt;::new();</code></pre>
<h5 id="accessing-array-elements"><a class="header" href="#accessing-array-elements">Accessing Array Elements</a></h5>
<p>To access array elements, you can use <code>get()</code> or <code>at()</code> array methods that return different types. Using <code>arr.at(index)</code> is equivalent to using the subscripting operator <code>arr[index]</code>.</p>
<p>The <code>get</code> function returns an <code>Option&lt;Box&lt;@T&gt;&gt;</code>, which means it returns an option to a Box type (Cairo's smart-pointer type) containing a snapshot to the element at the specified index if that element exists in the array. If the element doesn't exist, <code>get</code> returns <code>None</code>. This method is useful when you expect to access indices that may not be within the array's bounds and want to handle such cases gracefully without panics. Snapshots will be explained in more detail in the <a href="ch03-02-references-and-snapshots.html">References and Snapshots</a> chapter.</p>
<p>The <code>at</code> function, on the other hand, directly returns a snapshot to the element at the specified index using the <code>unbox()</code> operator to extract the value stored in a box. If the index is out of bounds, a panic error occurs. You should only use at when you want the program to panic if the provided index is out of the array's bounds, which can prevent unexpected behavior.</p>
<p>In summary, use <code>at</code> when you want to panic on out-of-bounds access attempts, and use <code>get</code> when you prefer to handle such cases gracefully without panicking.</p>
<pre><code class="language-rust">fn main() {
    let mut a = ArrayTrait::new();
    a.append(0);
    a.append(1);

    let first = *a.at(0_usize);
    let second = *a.at(1_usize);
}</code></pre>
<p>In this example, the variable named <code>first</code> will get the value <code>0</code> because that
is the value at index <code>0</code> in the array. The variable named <code>second</code> will get
the value <code>1</code> from index <code>1</code> in the array.</p>
<pre><code class="language-rust">use array::ArrayTrait;
use box::BoxTrait;
fn main() -&gt; u128 {
    let mut arr = ArrayTrait::&lt;u128&gt;::new();
    arr.append(100_u128);
    let length = arr.len();
    match arr.get(length - 1_usize) {
        Option::Some(x) =&gt; {
            *x.unbox()
        },
        Option::None(_) =&gt; {
            let mut data = ArrayTrait::new();
            data.append('out of bounds');
            panic(data)
        }
    } // returns 100
}</code></pre>
<p>The above example shows how we can do an error management by using the <code>get</code> instead of the <code>at</code> method.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="functions"><a class="header" href="#functions">Functions</a></h2>
<p>Functions are prevalent in Cairo code. You’ve already seen one of the most
important functions in the language: the <code>main</code> function, which is the entry
point of many programs. You’ve also seen the <code>fn</code> keyword, which allows you to
declare new functions.</p>
<p>Cairo code uses <em>snake case</em> as the conventional style for function and variable
names, in which all letters are lowercase and underscores separate words.
Here’s a program that contains an example function definition:</p>
<pre><code class="language-rust">use debug::PrintTrait;

fn another_function() {
    'Another function.'.print();
}

fn main() {
    'Hello, world!'.print();
    another_function();
}</code></pre>
<p>We define a function in Cairo by entering <code>fn</code> followed by a function name and a
set of parentheses. The curly brackets tell the compiler where the function
body begins and ends.</p>
<p>We can call any function we’ve defined by entering its name followed by a set
of parentheses. Because <code>another_function</code> is defined in the program, it can be
called from inside the <code>main</code> function. Note that we defined <code>another_function</code>
<em>before</em> the <code>main</code> function in the source code; we could have defined it after
as well. Cairo doesn’t care where you define your functions, only that they’re
defined somewhere in a scope that can be seen by the caller.</p>
<p>Let’s start a new project with Scarb named <em>functions</em> to explore functions
further. Place the <code>another_function</code> example in <em>src/lib.cairo</em> and run it. You
should see the following output:</p>
<pre><code class="language-console">$ cairo-run src/lib.cairo
[DEBUG] Hello, world!                (raw: 5735816763073854953388147237921)
[DEBUG] Another function.            (raw: 22265147635379277118623944509513687592494)
</code></pre>
<p>The lines execute in the order in which they appear in the <code>main</code> function.
First the “Hello, world!” message prints, and then <code>another_function</code> is called
and its message is printed.</p>
<h3 id="parameters"><a class="header" href="#parameters">Parameters</a></h3>
<p>We can define functions to have <em>parameters</em>, which are special variables that
are part of a function’s signature. When a function has parameters, you can
provide it with concrete values for those parameters. Technically, the concrete
values are called <em>arguments</em>, but in casual conversation, people tend to use
the words <em>parameter</em> and <em>argument</em> interchangeably for either the variables
in a function’s definition or the concrete values passed in when you call a
function.</p>
<p>In this version of <code>another_function</code> we add a parameter:</p>
<pre><code class="language-rust">use debug::PrintTrait;

fn main() {
    another_function(5);
}

fn another_function(x: felt252) {
    x.print();
}</code></pre>
<p>Try running this program; you should get the following output:</p>
<pre><code class="language-console">$ cairo-run src/lib.cairo
[DEBUG]                                 (raw: 5)
</code></pre>
<p>The declaration of <code>another_function</code> has one parameter named <code>x</code>. The type of
<code>x</code> is specified as <code>felt252</code>. When we pass <code>5</code> in to <code>another_function</code>, the
<code>.print()</code> function outputs <code>5</code> in the console.</p>
<p>In function signatures, you <em>must</em> declare the type of each parameter. This is
a deliberate decision in Cairo’s design: requiring type annotations in function
definitions means the compiler almost never needs you to use them elsewhere in
the code to figure out what type you mean. The compiler is also able to give
more helpful error messages if it knows what types the function expects.</p>
<p>When defining multiple parameters, separate the parameter declarations with
commas, like this:</p>
<pre><code class="language-rust">use debug::PrintTrait;

fn main() {
    another_function(5,6);
}

fn another_function(x: felt252, y:felt252) {
    x.print();
    y.print();
}</code></pre>
<p>This example creates a function named <code>another_function</code> with two
parameters. The first parameter is named <code>x</code> and is an <code>felt252</code>. The second is
named <code>y</code> and is type <code>felt252</code> too. The function then prints the content of the felt <code>x</code> and then the content of the felt <code>y</code>.</p>
<p>Let’s try running this code. Replace the program currently in your <em>functions</em>
project’s <em>src/lib.cairo</em> file with the preceding example and run it using <code>cairo-run src/lib.cairo</code>:</p>
<pre><code class="language-console">$ cairo-run src/lib.cairo
[DEBUG]                                 (raw: 5)
[DEBUG]                                 (raw: 6)
</code></pre>
<p>Because we called the function with <code>5</code> as the value for <code>x</code> and <code>6</code> as
the value for <code>y</code>, the program output contains those values.</p>
<h3 id="statements-and-expressions"><a class="header" href="#statements-and-expressions">Statements and Expressions</a></h3>
<p>Function bodies are made up of a series of statements optionally ending in an
expression. So far, the functions we’ve covered haven’t included an ending
expression, but you have seen an expression as part of a statement. Because
Cairo is an expression-based language, this is an important distinction to
understand. Other languages don’t have the same distinctions, so let’s look at
what statements and expressions are and how their differences affect the bodies
of functions.</p>
<ul>
<li><strong>Statements</strong> are instructions that perform some action and do not return
a value.</li>
<li><strong>Expressions</strong> evaluate to a resultant value. Let’s look at some examples.</li>
</ul>
<p>We’ve actually already used statements and expressions. Creating a variable and
assigning a value to it with the <code>let</code> keyword is a statement. In Listing 3-1,
<code>let y = 6;</code> is a statement.</p>
<pre><code class="language-rust">fn main() {
    let y = 6;
}</code></pre>
<p><span class="caption">Listing 3-1: A <code>main</code> function declaration containing one statement</span></p>
<p>Function definitions are also statements; the entire preceding example is a
statement in itself.</p>
<p>Statements do not return values. Therefore, you can’t assign a <code>let</code> statement
to another variable, as the following code tries to do; you’ll get an error:</p>
<pre><code class="language-rust">fn main() {
    let x = (let y = 6);
}</code></pre>
<p>When you run this program, the error you’ll get looks like this:</p>
<pre><code class="language-console">$ cairo-run src/lib.cairo
error: Missing token TerminalRParen.
 --&gt; src/lib.cairo:2:14
    let x = (let y = 6);
             ^

error: Missing token TerminalSemicolon.
 --&gt; src/lib.cairo:2:14
    let x = (let y = 6);
             ^

error: Missing token TerminalSemicolon.
 --&gt; src/lib.cairo:2:14
    let x = (let y = 6);
                      ^

error: Skipped tokens. Expected: statement.
 --&gt; src/lib.cairo:2:14
    let x = (let y = 6);
</code></pre>
<p>The <code>let y = 6</code> statement does not return a value, so there isn’t anything for
<code>x</code> to bind to. This is different from what happens in other languages, such as
C and Ruby, where the assignment returns the value of the assignment. In those
languages, you can write <code>x = y = 6</code> and have both <code>x</code> and <code>y</code> have the value
<code>6</code>; that is not the case in Cairo.</p>
<p>Expressions evaluate to a value and make up most of the rest of the code that
you’ll write in Cairo. Consider a math operation, such as <code>5 + 6</code>, which is an
expression that evaluates to the value <code>11</code>. Expressions can be part of
statements: in Listing 3-1, the <code>6</code> in the statement <code>let y = 6;</code> is an
expression that evaluates to the value <code>6</code>. Calling a function is an
expression. A new scope block created with
curly brackets is an expression, for example:</p>
<pre><code class="language-rust">use debug::PrintTrait;
fn main() {
    let y = {
        let x = 3;
        x + 1
    };

    y.print();
}</code></pre>
<p>This expression:</p>
<pre><code class="language-rust">{
    let x = 3;
    x + 1
}</code></pre>
<p>is a block that, in this case, evaluates to <code>4</code>. That value gets bound to <code>y</code>
as part of the <code>let</code> statement. Note that the <code>x + 1</code> line doesn’t have a
semicolon at the end, which is unlike most of the lines you’ve seen so far.
Expressions do not include ending semicolons. If you add a semicolon to the end
of an expression, you turn it into a statement, and it will then not return a
value. Keep this in mind as you explore function return values and expressions
next.</p>
<h3 id="functions-with-return-values"><a class="header" href="#functions-with-return-values">Functions with Return Values</a></h3>
<p>Functions can return values to the code that calls them. We don’t name return
values, but we must declare their type after an arrow (<code>-&gt;</code>). In Cairo, the
return value of the function is synonymous with the value of the final
expression in the block of the body of a function. You can return early from a
function by using the <code>return</code> keyword and specifying a value, but most
functions return the last expression implicitly. Here’s an example of a
function that returns a value:</p>
<pre><code class="language-rust">use debug::PrintTrait;

fn five() -&gt; u32 {
    5_u32
}

fn main() {
    let x = five();
    x.print();
}</code></pre>
<p>There are no function calls, or even <code>let</code> statements in the <code>five</code>
function—just the number <code>5</code> by itself. That’s a perfectly valid function in
Cairo. Note that the function’s return type is specified too, as <code>-&gt; u32</code>. Try
running this code; the output should look like this:</p>
<pre><code class="language-console">$ cairo-run src/lib.cairo
[DEBUG]                                 (raw: 5)
</code></pre>
<p>The <code>5</code> in <code>five</code> is the function’s return value, which is why the return type
is <code>u32</code>. Let’s examine this in more detail. There are two important bits:
first, the line <code>let x = five();</code> shows that we’re using the return value of a
function to initialize a variable. Because the function <code>five</code> returns a <code>5</code>,
that line is the same as the following:</p>
<pre><code class="language-rust">let x = 5;</code></pre>
<p>Second, the <code>five</code> function has no parameters and defines the type of the
return value, but the body of the function is a lonely <code>5</code> with no semicolon
because it’s an expression whose value we want to return.
Let’s look at another example:</p>
<pre><code class="language-rust">use debug::PrintTrait;

fn main() {
    let x = plus_one(5_u32);

    x.print();
}

fn plus_one(x: u32) -&gt; u32 {
    x + 1_u32
}</code></pre>
<p>Running this code will print <code>[DEBUG]                    (raw: 6)</code>. But if we place a
semicolon at the end of the line containing <code>x + 1</code>, changing it from an
expression to a statement, we’ll get an error:</p>
<pre><code class="language-rust">use debug::PrintTrait;

fn main() {
    let x = plus_one(5_u32);

    x.print();
}

fn plus_one(x: u32) -&gt; u32 {
    x + 1_u32;
}</code></pre>
<p>Compiling this code produces an error, as follows:</p>
<pre><code class="language-console">error: Unexpected return type. Expected: &quot;core::integer::u32&quot;, found: &quot;()&quot;.
</code></pre>
<p>The main error message, <code>Unexpected return type</code>, reveals the core issue with this
code. The definition of the function <code>plus_one</code> says that it will return an
<code>u32</code>, but statements don’t evaluate to a value, which is expressed by <code>()</code>,
the unit type. Therefore, nothing is returned, which contradicts the function
definition and results in an error.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="comments"><a class="header" href="#comments">Comments</a></h1>
<p>In Cairo programs, you can include explanatory text within the code using comments. To create a comment, use the // syntax, after which any text on the same line will be ignored by the compiler.</p>
<p><span class="filename">Filename: comments.cairo</span></p>
<pre><code class="language-rust">fn main() -&gt; felt252 {
    // start of the function
    1 + 4 // return the sum of 1 and 4
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="control-flow"><a class="header" href="#control-flow">Control Flow</a></h2>
<p>The ability to run some code depending on whether a condition is true and to run some code repeatedly while a condition is true are basic building blocks in most programming languages. The most common constructs that let you control the flow of execution of Cairo code are if expressions and loops.</p>
<h3 id="if-expressions"><a class="header" href="#if-expressions"><code>if</code> Expressions</a></h3>
<p>An if expression allows you to branch your code depending on conditions. You provide a condition and then state, “If this condition is met, run this block of code. If the condition is not met, do not run this block of code.”</p>
<p><span class="filename">Filename: main.cairo</span></p>
<pre><code class="language-rust">use debug::PrintTrait;

fn main() {
    let number = 3;

    if number == 5 {
        'condition was true'.print();
    } else {
        'condition was false'.print();
    }
}</code></pre>
<p>All <code>if</code> expressions start with the keyword <code>if</code>, followed by a condition. In this case, the condition checks whether or not the variable <code>number</code> has a value equal to 5. We place the block of code to execute if the condition is <code>true</code> immediately after the condition inside curly brackets.</p>
<p>Optionally, we can also include an <code>else</code> expression, which we chose to do here, to give the program an alternative block of code to execute should the condition evaluate to <code>false</code>. If you don’t provide an <code>else</code> expression and the condition is <code>false</code>, the program will just skip the <code>if</code> block and move on to the next bit of code.</p>
<p>Try running this code; you should see the following output:</p>
<pre><code class="language-console">$ cairo-run main.cairo
[DEBUG]	condition was false
</code></pre>
<p>Let’s try changing the value of <code>number</code> to a value that makes the condition <code>true</code> to see what happens:</p>
<pre><code class="language-rust">    let number = 5;</code></pre>
<pre><code class="language-console">$ cairo-run main.cairo
condition was true
</code></pre>
<p>It’s also worth noting that the condition in this code must be a bool. If the condition isn’t a bool, we’ll get an error.</p>
<pre><code class="language-console">$ cairo-run main.cairo
thread 'main' panicked at 'Failed to specialize: `enum_match&lt;felt252&gt;`. Error: Could not specialize libfunc `enum_match` with generic_args: [Type(ConcreteTypeId { id: 1, debug_name: None })]. Error: Provided generic argument is unsupported.', crates/cairo-lang-sierra-generator/src/utils.rs:256:9
</code></pre>
<h3 id="handling-multiple-conditions-with-else-if"><a class="header" href="#handling-multiple-conditions-with-else-if">Handling Multiple Conditions with <code>else if</code></a></h3>
<p>You can use multiple conditions by combining if and else in an else if expression. For example:</p>
<p><span class="filename">Filename: main.cairo</span></p>
<pre><code class="language-rust">use debug::PrintTrait;

fn main() {
    let number = 3;

    if number == 12 {
        'number is 12'.print();
    } else if number == 3 {
        'number is 3'.print();
    } else if number - 2 == 1 {
        'number minus 2 is 1'.print();
    } else {
        'number not found'.print();
    }
}</code></pre>
<p>This program has four possible paths it can take. After running it, you should see the following output:</p>
<pre><code class="language-console">[DEBUG]	number is 3
</code></pre>
<p>When this program executes, it checks each <code>if</code> expression in turn and executes the first body for which the condition evaluates to <code>true</code>. Note that even though <code>number - 2 == 1</code> is <code>true</code>, we don’t see the output <code>number minus 2 is 1'.print()</code>, nor do we see the <code>number is not divisible by 4, 3, or 2</code> text from the <code>else</code> block. That’s because Cairo only executes the block for the first true condition, and once it finds one, it doesn’t even check the rest. Using too many <code>else if</code> expressions can clutter your code, so if you have more than one, you might want to refactor your code. Chapter 5 describes a powerful Cairo branching construct called <code>match</code> for these cases.</p>
<h3 id="using-if-in-a-let-statement"><a class="header" href="#using-if-in-a-let-statement">Using <code>if</code> in a <code>let</code> statement</a></h3>
<p>Because if is an expression, we can use it on the right side of a let statement to assign the outcome to a variable.</p>
<p><span class="filename">Filename: main.cairo</span></p>
<pre><code class="language-rust">use debug::PrintTrait;

fn main() {
    let condition = true;
    let number = if condition { 5 } else { 6 };

    if number == 5 {
        'condition was true'.print();
    }
}</code></pre>
<pre><code class="language-console">$ cairo-run main.cairo
[DEBUG]	condition was true
</code></pre>
<p>The <code>number</code> variable will be bound to a value based on the outcome of the <code>if</code> expression. Which will be 5 here.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="understanding-cairos-ownership-system"><a class="header" href="#understanding-cairos-ownership-system">Understanding Cairo's Ownership system</a></h1>
<p>Cairo is a language built around a linear type system that allows us to
statically ensure that in every Cairo program, a value is used exactly once.
This linear type system helps preventing runtime errors by ensuring that operations that could cause such errors, such as writing twice to a memory cell, are detected at compile time.
This is achieved by implementing an ownership system
and forbidding copying and dropping values by default. In this chapter, we’ll
talk about Cairo's ownership system as well as references and snapshots.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="what-is-ownership"><a class="header" href="#what-is-ownership">What Is Ownership?</a></h2>
<p>Cairo implements an ownership system to ensure the safety and correctness of its compiled code.
The ownership mechanism complements the linear type system, which enforces that objects are used exactly once.
This helps prevent common operations that can produce runtime errors, such as illegal memory address
references or multiple writes to the same memory address, and ensures the soundness of Cairo programs
by checking at compile time that all the dictionaries are squashed.</p>
<p>Now that we’re past basic Cairo syntax, we won’t include all the <code>fn main() {</code>
code in examples, so if you’re following along, make sure to put the following
examples inside a <code>main</code> function manually. As a result, our examples will be a
bit more concise, letting us focus on the actual details rather than
boilerplate code.</p>
<h3 id="ownership-rules"><a class="header" href="#ownership-rules">Ownership Rules</a></h3>
<p>First, let’s take a look at the ownership rules. Keep these rules in mind as we
work through the examples that illustrate them:</p>
<ul>
<li>Each value in Cairo has an <em>owner</em>.</li>
<li>There can only be one owner at a time.</li>
<li>When the owner goes out of scope, the value will be <em>dropped</em>.</li>
</ul>
<h3 id="variable-scope"><a class="header" href="#variable-scope">Variable Scope</a></h3>
<p>As a first example of ownership, we’ll look at the <em>scope</em> of some variables. A
scope is the range within a program for which an item is valid. Take the
following variable:</p>
<pre><code class="language-rust">let s = 'hello';</code></pre>
<p>The variable <code>s</code> refers to a short string, where the value of the string is
hardcoded into the text of our program. The variable is valid from the point at
which it’s declared until the end of the current <em>scope</em>. Listing 3-1 shows a
program with comments annotating where the variable <code>s</code> would be valid.</p>
<pre><code class="language-rust">    {                      // s is not valid here, it’s not yet declared
        let s = 'hello';   // s is valid from this point forward

        // do stuff with s
    }                      // this scope is now over, and s is no longer valid</code></pre>
<p><span class="caption">Listing 3-1: A variable and the scope in which it is
valid</span></p>
<p>In other words, there are two important points in time here:</p>
<ul>
<li>When <code>s</code> comes <em>into</em> scope, it is valid.</li>
<li>It remains valid until it goes <em>out of</em> scope.</li>
</ul>
<p>At this point, the relationship between scopes and when variables are valid is
similar to that in other programming languages. Now we’ll build on top of this
understanding by introducing the <code>Array</code> type.</p>
<h3 id="the-array-type-1"><a class="header" href="#the-array-type-1">The <code>Array</code> Type</a></h3>
<p>To illustrate the rules of ownership, we need a data type that is more complex
than those we covered in the <a href="ch02-02-data-types.html#data-types">“Data Types”</a><!-- ignore --> section
of Chapter 3. The types covered previously are of a known size, can be
quickly and trivially copied to make a new, independent instance if another
part of code needs to use the same value in a different scope, and can easily
be dropped when they're no longer used. But we want to look at data whose size
is unknown at compile time and can't be trivially copied: the <code>Array</code> type.</p>
<p>In Cairo, each memory cell can only be written to once. Arrays are represented in memory by
a segment of contiguous memory cells, and Cairo's linear type system is used to ensure that each cell is
never written to more than once.
Consider the following code, in which we define a variable <code>arr</code> of <code>Array</code> type that holds <code>u128</code> values:</p>
<pre><code class="language-rust">use array::ArrayTrait;
...

let arr = ArrayTrait::&lt;u128&gt;::new();</code></pre>
<p>You can append values to an <code>Array</code> using the <code>append</code> method:</p>
<pre><code class="language-rust">let mut arr = ArrayTrait::&lt;u128&gt;::new();
arr.append(1);
arr.append(2);</code></pre>
<p>So, how does the ownership system ensure that each cell is never written to more than once?
Consider the following code, where we try to pass the same instance of an array in two consecutive
function calls:</p>
<pre><code class="language-rust">use array::ArrayTrait;
fn foo(arr: Array&lt;u128&gt;) {
}

fn bar(arr:Array&lt;u128&gt;){
}

fn main() {
    let mut arr = ArrayTrait::&lt;u128&gt;::new();
    foo(arr);
    bar(arr);
}</code></pre>
<p>In this case, we pass try to pass the same array instance <code>arr</code> by value to the functions <code>foo</code> and <code>bar</code>, which means
that the parameter used in both function calls is the same instance of the array. If you append a value to the array
in <code>foo</code>, and then try to append another value to the same array in <code>bar</code>, what would happen is that
you would attempt to try to write to the same memory cell twice, which is not allowed in Cairo.
To prevent this, the ownership of the <code>arr</code> variable moves from the <code>main</code> function to the <code>foo</code> function. When trying
to call <code>bar</code> with <code>arr</code> as a parameter, the ownership of <code>arr</code> was already moved to the first call. The ownership
system thus prevents us from using the same instance of <code>arr</code> in <code>foo</code>.</p>
<p>Running the code above will result in a compile-time error:</p>
<pre><code class="language-console">error: Variable was previously moved. Trait has no implementation in context: core::traits::Copy::&lt;core::array::Array::&lt;core::integer::u128&gt;&gt;
 --&gt; array.cairo:6:9
    let mut arr = ArrayTrait::&lt;u128&gt;::new();
        ^*****^
</code></pre>
<h3 id="the-copy-trait"><a class="header" href="#the-copy-trait">The <code>Copy</code> Trait</a></h3>
<p>If a type implements the <code>Copy</code> trait, passing it to a function will not move the ownership of the value to the function called, but will instead pass a copy of the value.
You can implement the <code>Copy</code> trait on your type by adding the <code>#[derive(Copy)]</code> annotation to your type definition. However, Cairo won't allow a type to be annotated with Copy if the type itself or any of its components don't implement the Copy trait.
While Arrays and Dictionaries can't be copied, custom types that don't contain either of them can be.</p>
<pre><code class="language-rust">#[derive(Copy, Drop)]
struct Point {
    x: u128,
    y: u128,
}

fn main() {
    let p1 = Point { x: 5, y: 10 };
    foo(p1);
    foo(p1);
}

fn foo(p: Point) {
    // do something with p
}</code></pre>
<p>In this example, we can pass <code>p1</code> twice to the foo function because the <code>Point</code> type implements the <code>Copy</code> trait. This means that when we pass <code>p1</code> to <code>foo</code>, we are actually passing a copy of <code>p1</code>, and the ownership of <code>p1</code> remains with the main function.
If you remove the <code>Copy</code> trait derivation from the <code>Point</code> type, you will get a compile-time error when trying to compile the code.</p>
<h3 id="the-drop-trait"><a class="header" href="#the-drop-trait">The <code>Drop</code> Trait</a></h3>
<p>You may have noticed that the <code>Point</code> type in the previous example also implements the <code>Drop</code> trait. In Cairo, a value cannot go out of scope unless it has been previously moved.
For example, the following code will not compile, because the struct <code>A</code> is not moved before it goes out of scope:</p>
<pre><code class="language-rust">struct A {}

fn main() {
    A {}; // error: Value not dropped.
}</code></pre>
<p>This is to ensure the soundness of Cairo programs. Soundness refers to the fact that if a
statement during the execution of the program is false, no cheating prover can convince an
honest verifier that it is true. In our case, we want to ensure the consistency of
consecutive dictionary key updates during program execution, which is only checked when
the dictionaries are<code>squashed</code> - which moves the ownership of the dictionary to the
<code>squash</code> method, thus allowing the dictionary to go out of scope. Unsquashed dictionaries
are dangerous, as a malicious prover could prove the correctness of inconsistent updates.</p>
<p>However, types that implement the <code>Drop</code> trait are allowed to go out of scope without being explicitly moved. When a value of a type that implements the <code>Drop</code> trait goes out of scope, the <code>Drop</code> implementation is called on the type, which moves the value to the <code>drop</code> function, allowing it to go out of scope - This is what we call &quot;dropping&quot; a value.
It is important to note that the implementation of drop is a &quot;no-op&quot;, meaning that it doesn't perform any actions other than allowing the value to go out of scope.</p>
<p>The <code>Drop</code> implementation can be derived for all types, allowing them to be dropped when goint out of scope, except for dictionaries (<code>Felt252Dict</code>) and types containing dictionaries.
For example, the following code compiles:</p>
<pre><code class="language-rust">#[derive(Drop)]
struct A {}

fn main() {
    A {}; // Now there is no error.
}</code></pre>
<h3 id="the-destruct-trait"><a class="header" href="#the-destruct-trait">The <code>Destruct</code> Trait</a></h3>
<p>Manually calling the <code>squash</code> method on a dictionary is not very convenient, and it is easy to forget to do so. To make it easier to use dictionaries, Cairo provides the <code>Destruct</code> trait, which allows you to specify the behavior of a type when it goes out of scope. While Dictionaries don't implement the <code>Drop</code> trait, they do implement the <code>Destruct</code> trait, which allows them to automatically be <code>squashed</code> when they go out of scope. This means that you can use dictionaries without having to manually call the <code>squash</code> method.</p>
<p>Consider the following example, in which we define a custom type that contains a dictionary:</p>
<pre><code class="language-rust">use dict::Felt252DictTrait;

struct A {
    dict: Felt252Dict&lt;u128&gt;
}

fn main() {
    A {
        dict: Felt252DictTrait::new()
    };
}</code></pre>
<p>If you try to run this code, you will get a compile-time error:</p>
<pre><code class="language-console">error: Variable not dropped. Trait has no implementation in context: core::traits::Drop::&lt;temp7::temp7::A&gt;. Trait has no implementation in context: core::traits::Destruct::&lt;temp7::temp7::A&gt;.
 --&gt; temp7.cairo:7:5
    A {
    ^*^
</code></pre>
<p>When A goes out of scope, it can't be dropped as it implements neither the <code>Drop</code> (as it contains a dictionary and can't <code>derive(Drop)</code>) nor the <code>Destruct</code> trait. To fix this, we can derive the <code>Destruct</code> trait implementation for the <code>A</code> type:</p>
<pre><code class="language-rust">use dict::Felt252DictTrait;

#[derive(Destruct)]
struct A {
    dict: Felt252Dict&lt;u128&gt;
}

fn main() {
    A {
        dict: Felt252DictTrait::new()
    }; // No error here
}</code></pre>
<p>Now, when <code>A</code> goes out of scope, its dictionary will be automatically <code>squashed</code>, and the program will compile.</p>
<h3 id="copy-array-data-with-clone"><a class="header" href="#copy-array-data-with-clone">Copy Array data with Clone</a></h3>
<p>If we <em>do</em> want to deeply copy the data of an <code>Array</code>, we can use a common method called <code>clone</code>. We’ll discuss method syntax in Chapter 5, but because methods are a common feature in many
programming languages, you’ve probably seen them before.</p>
<p>Here’s an example of the <code>clone</code> method in action.</p>
<blockquote>
<p>Note: in the following example, we need to import the <code>Clone</code> trait from the corelib <code>clone</code> module, and its implementation for the array type from the <code>array</code> module.</p>
</blockquote>
<pre><code class="language-rust">use array::ArrayTrait;
use clone::Clone;
use array::ArrayTCloneImpl;
...
let arr1 = ArrayTrait::new::&lt;u128&gt;();
let arr2 = arr1.clone();
</code></pre>
<blockquote>
<p>Note: you will need to run <code>cairo-run</code> with the <code>--available-gas=2000000</code> option to run this example, because it uses a loop and must be ran with a gas limit.</p>
</blockquote>
<p>When you see a call to <code>clone</code>, you know that some arbitrary code is being
executed and that code may be expensive. It’s a visual indicator that something
different is going on.</p>
<h3 id="ownership-and-functions"><a class="header" href="#ownership-and-functions">Ownership and Functions</a></h3>
<p>Passing a variable to a function will either move it or copy it. As seen in the Array section, passing an <code>Array</code> as a function parameter transfers its ownership; let's see what happens with other types.</p>
<p>Listing 3-3 has an example with some annotations
showing where variables go into and out of scope.</p>
<p><span class="filename">Filename: src/main.cairo</span></p>
<pre><code class="language-rust">#[derive(Drop)]
struct MyStruct{}

fn main() {
    let my_struct = MyStruct{};  // my_struct comes into scope

    takes_ownership(my_struct);             // my_struct's value moves into the function...
                                    // ... and so is no longer valid here

    let x = 5_u128;                 // x comes into scope

    makes_copy(x);                  // x would move into the function,
                                    // but u128 implements Copy, so it's okay to still
                                    // use x afterward

} // Here, x goes out of scope and is dropped. But because my_struct's value was moved, nothing
// special happens.

fn takes_ownership(some_struct: A) { // some_struct comes into scope
} // Here, some_struct goes out of scope and `drop` is called.

fn makes_copy(some_uinteger: u128) { // some_uinteger comes into scope
} // Here, some_integer goes out of scope and is dropped.</code></pre>
<p><span class="caption">Listing 3-3: Functions with ownership and scope
annotated</span></p>
<p>If we tried to use <code>my_struct</code> after the call to <code>takes_ownership</code>, Cairo would throw a
compile-time error. These static checks protect us from mistakes. Try adding
code to <code>main</code> that uses <code>my_struct</code> and <code>x</code> to see where you can use them and where
the ownership rules prevent you from doing so.</p>
<h3 id="return-values-and-scope"><a class="header" href="#return-values-and-scope">Return Values and Scope</a></h3>
<p>Returning values can also transfer ownership. Listing 3-4 shows an example of a
function that returns some value, with similar annotations as those in Listing
4-3.</p>
<p><span class="filename">Filename: src/main.cairo</span></p>
<pre><code class="language-rust">#[derive(Drop)]
struct A{}

fn main() {
    let a1 = gives_ownership();         // gives_ownership moves its return
                                        // value into a1

    let a2 = A{};     // a2 comes into scope

    let a3 = takes_and_gives_back(a2);  // a2 is moved into
                                        // takes_and_gives_back, which also
                                        // moves its return value into a3
} // Here, a3 goes out of scope and is dropped. a2 was moved, so nothing
  // happens. a1 goes out of scope and is dropped.

fn gives_ownership() -&gt; A {             // gives_ownership will move its
                                             // return value into the function
                                             // that calls it

    let some_a = A{}; // some_a comes into scope

    some_a                              // some_a is returned and
                                             // moves out to the calling
                                             // function
}

// This function takes an instance of A and returns one
fn takes_and_gives_back(some_a: A) -&gt; A { // some_a comes into
                                                      // scope

    some_a  // some_a is returned and moves out to the calling function
}</code></pre>
<p><span class="caption">Listing 3-4: Transferring ownership of return
values</span></p>
<p>When a variable goes out of scope, its value is dropped, unless ownership of the value has been moved to another variable.</p>
<p>While this works, taking ownership and then returning ownership with every
function is a bit tedious. What if we want to let a function use a value but
not take ownership? It’s quite annoying that anything we pass in also needs to
be passed back if we want to use it again, in addition to any data resulting
from the body of the function that we might want to return as well.</p>
<p>Cairo does let us return multiple values using a tuple, as shown in Listing 3-5.</p>
<p><span class="filename">Filename: src/main.cairo</span></p>
<pre><code class="language-rust">use array::ArrayTrait;
fn main() {
    let arr1 = ArrayTrait::&lt;u128&gt;::new();

    let (arr2, len) = calculate_length(arr1);
}

fn calculate_length(arr: Array&lt;u128&gt;) -&gt; (Array&lt;u128&gt;, usize) {
    let length = arr.len(); // len() returns the length of an array

    (arr, length)
}</code></pre>
<p><span class="caption">Listing 3-5: Returning ownership of parameters</span></p>
<p>But this is too much ceremony and a lot of work for a concept that should be
common. Luckily for us, Cairo has two features for using a value without
transferring ownership, called <em>references</em> and <em>snapshots</em>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="references-and-snapshots"><a class="header" href="#references-and-snapshots">References and Snapshots</a></h2>
<p>The issue with the tuple code in Listing 3-5 is that we have to return the
<code>Array</code> to the calling function so we can still use the <code>Array</code> after the
call to <code>calculate_length</code>, because the <code>Array</code> was moved into
<code>calculate_length</code>.</p>
<h3 id="snapshots"><a class="header" href="#snapshots">Snapshots</a></h3>
<p>Instead, we can provide a <em>snapshot</em> of the <code>Array</code> value. In Cairo, a snapshot
is an immutable view of a value at a certain point in time. In the previous chapter,
we talked about how Cairo's ownership system prevents us from using a value after
we've moved it, protecting us from potentially writing twice to the same memory cell when
appending values to arrays. However, it's not very convenient. Let's see how we can retain ownership
of the value in the calling function using snapshots.</p>
<p>Here is how you would define and use a <code>calculate_length</code> function that takes a
snapshot to an array as a parameter instead of taking ownership of the underlying value. In this example,
the <code>calculate_length</code> function returns the length of the array passed as parameter.
As we're passing it as a snapshot, which is an immutable view of the array, we can be sure that
the <code>calculate_length</code> function will not mutate the array, and ownership of the array is kept in the main function.</p>
<p><span class="filename">Filename: src/lib.cairo</span></p>
<pre><code class="language-rust">use array::ArrayTrait;
use debug::PrintTrait;

fn main() {
    let mut arr1 = ArrayTrait::&lt;u128&gt;::new();
    let first_snapshot = @arr1; // Take a snapshot of `arr1` at this point in time
    arr1.append(1_u128); // Mutate `arr1` by appending a value
    let first_length = calculate_length(first_snapshot); // Calculate the length of the array when the snapshot was taken
    let second_length = calculate_length(@arr1); // Calculate the current length of the array
    first_length.print();
    second_length.print();
}

fn calculate_length(arr: @Array&lt;u128&gt;) -&gt; usize {
    arr.len()
}</code></pre>
<blockquote>
<p>Note: It is only possible to call the <code>len()</code> method on an array snapshot because it is defined as such in the <code>ArrayTrait</code> trait. If you try to call a method that is not defined for snapshots on a snapshot, you will get a compilation error. However, you can call methods expecting a snapshot on non-snapshot types.</p>
</blockquote>
<p>The output of this program is:</p>
<pre><code class="language-console">[DEBUG]	                               	(raw: 0)

[DEBUG]	                              	(raw: 1)

Run completed successfully, returning []
</code></pre>
<p>First, notice that all the tuple code in the variable declaration and the function return value is gone. Second, note
that we pass <code>@arr1</code> into <code>calculate_length</code> and, in its definition, we take <code>@Array&lt;u128&gt;</code> rather than <code>Array&lt;u128&gt;</code>.</p>
<p>Let’s take a closer look at the function call here:</p>
<pre><code class="language-rust">let mut arr1 = ArrayTrait::&lt;u128&gt;::new();
let second_length = calculate_length(@arr1); // Calculate the current length of the array</code></pre>
<p>The <code>@arr1</code> syntax lets us create a snapshot of the value in <code>arr1</code>. Because a snapshot is an immutable view of a value, the value it points to cannot be modified through the snapshot, and the value it refers to will not be dropped once the snapshot stops being used.</p>
<p>Similarly, the signature of the function uses <code>@</code> to indicate that the type of the parameter <code>arr</code> is a snapshot. Let’s add some explanatory annotations:</p>
<pre><code class="language-rust">fn calculate_length(array_snapshot: @Array&lt;u128&gt;) -&gt; usize { // array_snapshot is a snapshot of an Array
    array_snapshot.len()
} // Here, array_snapshot goes out of scope and is dropped.
// However, because it is only a view of what the original array `arr` contains, the original `arr` can still be used.</code></pre>
<p>The scope in which the variable <code>array_snapshot</code> is valid is the same as any function parameter’s scope, but the underlying value of the snapshot is not dropped when <code>array_snapshot</code> stops being used. When functions have snapshots as parameters instead of the actual values, we won’t need to return the values in order to give back ownership of the original value, because we never had it.</p>
<p>Snapshots can be converted back into regular values using the <code>desnap</code> operator <code>*</code>, as long as the value type is copyable (which is not the case for Arrays, as they don't implement <code>Copy</code>). In the following example, we want to calculate the area of a rectangle, but we don't want to take ownership of the rectangle in the <code>calculate_area</code> function, because we might want to use the rectangle again after the function call. Since our function doesn't mutate the rectangle instance, we can pass the snapshot of the rectangle to the function, and then transform the snapshots back into values using the <code>desnap</code> operator <code>*</code>.</p>
<p>The snapshot type is always copyable and droppable, so that you can use it multiple times without worrying about ownership transfers.</p>
<pre><code class="language-rust">#[derive(Copy,Drop)]
struct Rectangle {
    height: u64,
    width: u64,
}

fn main(){
    let rec = Rectangle{height:3_u64, width:10_u64};
}

fn calculate_area(rec: @Rectangle) -&gt; u64 {
    // As rec is a snapshot to a Rectangle, its fields are also snapshots of the fields types.
    // We need to transform the snapshots back into values using the desnap operator `*`.
    // This is only possible if the type is copyable, which is the case for u64.
    // Here, `*` is used for both multiplying the height and width and for desnapping the snapshots.
    *rec.height * *rec.width
}</code></pre>
<p>But, what happens if we try to modify something we’re passing as snapshot? Try the code in
Listing 3-6. Spoiler alert: it doesn’t work!</p>
<p><span class="filename">Filename: src/lib.cairo</span></p>
<pre><code class="language-rust">#[derive(Copy,Drop)]
struct Rectangle {
    height: u64,
    width: u64,
}

fn main(){
    let rec = Rectangle{height:3_u64, width:10_u64};
    flip(@rec);
}

fn flip(rec: @Rectangle) {
    let temp = rec.height;
    rec.height = rec.width;
    rec.width = temp;
}</code></pre>
<p><span class="caption">Listing 3-6: Attempting to modify a snapshot value</span></p>
<p>Here’s the error:</p>
<pre><code class="language-console">error: Invalid left-hand side of assignment.
 --&gt; ownership.cairo:15:5
    rec.height = rec.width;
    ^********^
</code></pre>
<p>The compiler prevents us from modifying values associated to snapshots.</p>
<h3 id="mutable-references"><a class="header" href="#mutable-references">Mutable References</a></h3>
<p>We can achieve the behavior we want in Listing 3-6 by using a <em>mutable reference</em> instead of a snapshot. Mutable references are actually mutable values passed to a function that are implicitly returned at the end of the function, returning ownership to the calling context. By doing so, they allow you to mutate the value passed while keeping ownership of it by returning it automatically at the end of the execution.
In Cairo, a parameter can be passed as <em>mutable reference</em> using the <code>ref</code> modifier.</p>
<blockquote>
<p><strong>Note</strong>: In Cairo, a parameter can only be passed as <em>mutable reference</em> using the <code>ref</code> modifier if the variable is declared as mutable with <code>mut</code>.</p>
</blockquote>
<p>In Listing 3-7, we use a mutable reference to modify the value of the <code>height</code> field of the <code>Rectangle</code> instance in the <code>flip</code> function.</p>
<pre><code class="language-rust">use debug::PrintTrait;
#[derive(Copy,Drop)]
struct Rectangle {
    height: u64,
    width: u64,
}

fn main(){
    let mut rec = Rectangle{height:3_u64, width:10_u64};
    flip(ref rec);
    rec.height.print();
    rec.width.print();
}

fn flip(ref rec: Rectangle) {
    let temp = rec.height;
    rec.height = rec.width;
    rec.width = temp;
}</code></pre>
<p>First, we change <code>rec</code> to be <code>mut</code>. Then we pass a mutable reference of <code>rec</code> into <code>flip</code> with <code>ref rec</code>, and update the function signature to accept a mutable reference with <code>ref rec: Rectangle</code>. This makes it very clear that the <code>flip</code> function will mutate the value of the <code>Rectangle</code> instance passed as parameter.</p>
<p>The output of the program is:</p>
<pre><code class="language-console">[DEBUG]
                                (raw: 10)

[DEBUG]	                        (raw: 3)
</code></pre>
<p>As expected, the <code>height</code> and <code>width</code> fields of the <code>rec</code> variable have been swapped.</p>
<h3 id="small-recap"><a class="header" href="#small-recap">Small recap</a></h3>
<p>Let’s recap what we’ve discussed about ownership, snapshots, and references:</p>
<ul>
<li>At any given time, a variable can only have one owner.</li>
<li>You can pass a variable by-value, by-snapshot, or by-reference to a function.</li>
<li>If you pass-by-value, ownership of the variable is transferred to the function.</li>
<li>If you want to keep ownership of the variable and know that your function won’t mutate it, you can pass it as a snapshot with <code>@</code>.</li>
<li>If you want to keep ownership of the variable and know that your function will mutate it, you can pass it as a mutable reference with <code>ref</code>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-structs-to-structure-related-data"><a class="header" href="#using-structs-to-structure-related-data">Using Structs to Structure Related Data</a></h1>
<p>A struct, or structure, is a custom data type that lets you package together and name multiple related values that make up a meaningful group. If you’re familiar with an object-oriented language, a struct is like an object’s data attributes. In this chapter, we’ll compare and contrast tuples with structs to build on what you already know and demonstrate when structs are a better way to group data.</p>
<p>We’ll demonstrate how to define and instantiate structs. We’ll discuss how to define associated functions, especially the kind of associated functions called methods, to specify behavior associated with a struct type. Structs and enums (discussed in Chapter 6) are the building blocks for creating new types in your program’s domain to take full advantage of Cairo's compile-time type checking.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="defining-and-instantiating-structs"><a class="header" href="#defining-and-instantiating-structs">Defining and Instantiating Structs</a></h1>
<p>Structs are similar to tuples, discussed in <a href="ch02-02-data-types.html">The Data Types</a> section, in that both hold multiple related values. Like tuples, the pieces of a struct can be different types. Unlike with tuples, in a struct you’ll name each piece of data so it’s clear what the values mean. Adding these names means that structs are more flexible than tuples: you don’t have to rely on the order of the data to specify or access the values of an instance.</p>
<p>To define a struct, we enter the keyword <code>struct</code> and name the entire struct. A struct’s name should describe the significance of the pieces of data being grouped together. Then, inside curly brackets, we define the names and types of the pieces of data, which we call fields. For example, Listing 4-1 shows a struct that stores information about a user account.</p>
<p><span class="filename">Filename: structs.cairo</span></p>
<pre><code class="language-rust">#[derive(Copy, Drop)]
struct User {
    active: bool,
    username: felt252,
    email: felt252,
    sign_in_count: u64,
}</code></pre>
<p><span class="caption">Listing 4-1: A <code>User</code> struct definition</span></p>
<p>To use a struct after we’ve defined it, we create an <em>instance</em> of that struct by specifying concrete values for each of the fields.
We create an instance by stating the name of the struct and then add curly brackets containing <em>key: value</em> pairs, where the keys are the names of the fields and the values are the data we want to store in those fields. We don’t have to specify the fields in the same order in which we declared them in the struct. In other words, the struct definition is like a general template for the type, and instances fill in that template with particular data to create values of the type.</p>
<p>For example, we can declare a particular user as shown in Listing 4-2.</p>
<p><span class="filename">Filename: structs.cairo</span></p>
<pre><code class="language-rust">#[derive(Copy, Drop)]
struct User {
    active: bool,
    username: felt252,
    email: felt252,
    sign_in_count: u64,
}
fn main() {
    let user1 = User {
        active: true,
        username: 'someusername123',
        email: 'someone@example.com',
        sign_in_count: 1_u64,
    };
}</code></pre>
<p><span class="caption">Listing 4-2: Creating an instance of the <code>User</code> struct</span></p>
<p>To get a specific value from a struct, we use dot notation. For example, to access this user’s email address, we use <code>user1.email</code>. If the instance is mutable, we can change a value by using the dot notation and assigning into a particular field. Listing 4-3 shows how to change the value in the <code>email</code> field of a mutable <code>User</code> instance.</p>
<p><span class="filename">Filename: structs.cairo</span></p>
<pre><code class="language-rust">fn main() {
    let mut user1 = User {
        active: true,
        username: 'someusername123',
        email: 'someone@example.com',
        sign_in_count: 1_u64,
    };
    user1.email = 'anotheremail@example.com';
}</code></pre>
<p><span class="caption">Listing 4-3: Changing the value in the email field of a <code>User</code> instance</span></p>
<p>Note that the entire instance must be mutable; Cairo doesn’t allow us to mark only certain fields as mutable.</p>
<p>As with any expression, we can construct a new instance of the struct as the last expression in the function body to implicitly return that new instance.</p>
<p>Listing 4-4 shows a <code>build_user</code> function that returns a <code>User</code> instance with the given email and username. The <code>active</code> field gets the value of <code>true</code>, and the <code>sign_in_count</code> gets a value of <code>1</code>.</p>
<p><span class="filename">Filename: structs.cairo</span></p>
<pre><code class="language-rust">fn build_user(email: felt, username: String) -&gt; User {
    User {
        active: true,
        username: username,
        email: email,
        sign_in_count: 1,
    }
}</code></pre>
<p><span class="caption">Listing 4-4: A <code>build_user</code> function that takes an email and username and returns a <code>User</code> instance</span></p>
<p>It makes sense to name the function parameters with the same name as the struct fields, but having to repeat the <code>email</code> and <code>username</code> field names and variables is a bit tedious. If the struct had more fields, repeating each name would get even more annoying. Luckily, there’s a convenient shorthand!</p>
<h2 id="using-the-field-init-shorthand"><a class="header" href="#using-the-field-init-shorthand">Using the Field Init Shorthand</a></h2>
<p>Because the parameter names and the struct field names are exactly the same in Listing 4-4, we can use the field init shorthand syntax to rewrite <code>build_user</code> so it behaves exactly the same but doesn’t have the repetition of <code>username</code> and <code>email</code>, as shown in Listing 4-5.</p>
<p><span class="filename">Filename: structs.cairo</span></p>
<pre><code class="language-rust">fn build_user(email: felt252, username: felt252) -&gt; User {
    User {
        active: true,
        username,
        email,
        sign_in_count: 1_u64,
    }
}</code></pre>
<p><span class="caption">Listing 4-5: A <code>build_user</code> function that uses field init shorthand because the <code>username</code> and <code>email</code> parameters have the same name as struct fields</span></p>
<p>Here, we’re creating a new instance of the <code>User</code> struct, which has a field named <code>email</code>. We want to set the <code>email</code> field’s value to the value in the <code>email</code> parameter of the <code>build_user</code> function. Because the <code>email</code> field and the <code>email</code> parameter have the same name, we only need to write <code>email</code> rather than <code>email: email</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="an-example-program-using-structs"><a class="header" href="#an-example-program-using-structs">An Example Program Using Structs</a></h1>
<p>To understand when we might want to use structs, let’s write a program that calculates the area of a rectangle. We’ll start by using single variables, and then refactor the program until we’re using structs instead.</p>
<p>Let’s make a new project with Scarb called <em>rectangles</em> that will take the width and height of a rectangle specified in pixels and calculate the area of the rectangle. Listing 4-6 shows a short program with one way of doing exactly that in our project’s <em>src/lib.cairo</em>.</p>
<p><span class="filename">Filename: src/lib.cairo</span></p>
<pre><code class="language-rust">use debug::PrintTrait;
fn main() {
    let width1 = 30_u64;
    let height1 = 10_u64;
    let area = area(width1, height1);
    area.print();
}

fn area(width: u64, height: u64) -&gt; u64 {
    width * height
}</code></pre>
<p><span class="caption">Listing 4-6: Calculating the area of a rectangle specified by separate width and height variables</span></p>
<p>Now run the program with <code>cairo-run src/lib.cairo</code>:</p>
<pre><code class="language-bash">$ cairo-run src/lib.cairo
[DEBUG] ,                               (raw: 300)

Run completed successfully, returning []
</code></pre>
<p>This code succeeds in figuring out the area of the rectangle by calling the <code>area</code> function with each dimension, but we can do more to make this code clear and readable.</p>
<p>The issue with this code is evident in the signature of <code>area</code>:</p>
<pre><code class="language-rust">fn area(width: u64, height: u64) -&gt; u64 {</code></pre>
<p>The <code>area</code> function is supposed to calculate the area of one rectangle, but the function we wrote has two parameters, and it’s not clear anywhere in our program that the parameters are related. It would be more readable and more manageable to group width and height together. We’ve already discussed one way we might do that in <a href="ch02-02-data-types.html#the-tuple-type">Chapter 3</a>: using tuples.</p>
<h2 id="refactoring-with-tuples"><a class="header" href="#refactoring-with-tuples">Refactoring with Tuples</a></h2>
<p>Listing 4-7 shows another version of our program that uses tuples.</p>
<p><span class="filename">Filename: src/lib.cairo</span></p>
<pre><code class="language-rust">use debug::PrintTrait;
fn main() {
    let rectangle = (30_u64, 10_u64);
    let area = area(rectangle);
    area.print(); // print out the area
}

fn area(dimension: (u64, u64)) -&gt; u64 {
    let (x,y) = dimension;
    x * y
}</code></pre>
<p><span class="caption">Listing 4-7: Specifying the width and height of the rectangle with a tuple</span></p>
<p>In one way, this program is better. Tuples let us add a bit of structure, and we’re now passing just one argument. But in another way, this version is less clear: tuples don’t name their elements, so we have to index into the parts of the tuple, making our calculation less obvious.</p>
<p>Mixing up the width and height wouldn’t matter for the area calculation, but if we want to calculate the difference, it would matter! We would have to keep in mind that <code>width</code> is the tuple index <code>0</code> and <code>height</code> is the tuple index <code>1</code>. This would be even harder for someone else to figure out and keep in mind if they were to use our code. Because we haven’t conveyed the meaning of our data in our code, it’s now easier to introduce errors.</p>
<h2 id="refactoring-with-structs-adding-more-meaning"><a class="header" href="#refactoring-with-structs-adding-more-meaning">Refactoring with Structs: Adding More Meaning</a></h2>
<p>We use structs to add meaning by labeling the data. We can transform the tuple we’re using into a struct with a name for the whole as well as names for the parts.</p>
<p><span class="filename">Filename: src/lib.cairo</span></p>
<pre><code class="language-rust">use debug::PrintTrait;

struct Rectangle {
    width: u64,
    heigh: u64,
}

fn main() {
    let rectangle = Rectangle {
        width: 30_u64,
        heigh: 10_u64,
    };
    let area = area(rectangle);
    area.print(); // print out the area
}

fn area(rectangle: Rectangle) -&gt; u64 {
    rectangle.width * rectangle.heigh
}</code></pre>
<p><span class="caption">Listing 4-8: Defining a <code>Rectangle</code> struct</span></p>
<p>Here we’ve defined a struct and named it <code>Rectangle</code>. Inside the curly brackets, we defined the fields as <code>width</code> and <code>height</code>, both of which have type <code>u64</code>. Then, in <code>main</code>, we created a particular instance of <code>Rectangle</code> that has a width of <code>30</code> and a height of <code>10</code>. Our <code>area</code> function is now defined with one parameter, which we’ve named <code>rectangle</code> which is of type <code>Rectangle</code> struct. We can then access the fields of the instance with dot notation, and it gives descriptive names to the values rather than using the tuple index values of <code>0</code> and <code>1</code>.</p>
<h2 id="adding-useful-functionality-with-trait"><a class="header" href="#adding-useful-functionality-with-trait">Adding Useful Functionality with Trait</a></h2>
<p>It’d be useful to be able to print an instance of <code>Rectangle</code> while we’re debugging our program and see the values for all its fields. Listing 4-9 tries using the <code>print</code> as we have used in previous chapters. This won’t work.</p>
<p><span class="filename">Filename: src/lib.cairo</span></p>
<pre><code class="language-rust">use debug::PrintTrait;

struct Rectangle {
    width: u64,
    heigh: u64,
}

fn main() {
    let rectangle = Rectangle {
        width: 30_u64,
        heigh: 10_u64,
    };
    rectangle.print();
}</code></pre>
<p><span class="caption">Listing 4-9: Attempting to print a <code>Rectangle</code> instance</span></p>
<p>When we compile this code, we get an error with this message:</p>
<pre><code class="language-bash">$ cairo-compile src/lib.cairo
error: Method `print` not found on type &quot;../src::Rectangle&quot;. Did you import the correct trait and impl?
 --&gt; lib.cairo:16:15
    rectangle.print();
              ^***^

Error: Compilation failed.
</code></pre>
<p>The <code>print</code> trait is implemented for many data types, but not for the <code>Rectangle</code> struct. We can fix this by implementing the <code>PrintTrait</code> trait on <code>Rectangle</code> as shown in Listing 4-10.
To learn more about traits, see <a href="ch07-02-traits-in-cairo.html">Traits in Cairo</a>.</p>
<p><span class="filename">Filename: src/lib.cairo</span></p>
<pre><code class="language-rust">use debug::PrintTrait;

struct Rectangle {
    width: u64,
    heigh: u64,
}

fn main() {
    let rectangle = Rectangle {
        width: 30_u64,
        heigh: 10_u64,
    };
    rectangle.print();
}

impl RectanglePrintImpl of PrintTrait&lt;Rectangle&gt; {
    fn print(self: Rectangle) {
        self.width.print();
        self.heigh.print();
    }
}</code></pre>
<p><span class="caption">Listing 4-10: Implementing the <code>PrintTrait</code> trait on <code>Rectangle</code></span></p>
<p>Nice! It’s not the prettiest output, but it shows the values of all the fields for this instance, which would definitely help during debugging.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="method-syntax"><a class="header" href="#method-syntax">Method Syntax</a></h2>
<p><em>Methods</em> are similar to functions: we declare them with the <code>fn</code> keyword and a
name, they can have parameters and a return value, and they contain some code
that’s run when the method is called from somewhere else. Unlike functions,
methods are defined within the context of a type and their first parameter is
always <code>self</code>, which represents the instance of the type the method is being
called on. For those familiar with Rust, Cairo's approach might be confusing,
as methods cannot be defined directly on types. Instead, you must define a trait
and an implementation associated with the type for which the method is intended.</p>
<h3 id="defining-methods"><a class="header" href="#defining-methods">Defining Methods</a></h3>
<p>Let’s change the <code>area</code> function that has a <code>Rectangle</code> instance as a parameter
and instead make an <code>area</code> method defined on the <code>RectangleTrait</code> trait, as shown
in Listing 5-13.</p>
<p><span class="filename">Filename: src/lib.cairo</span></p>
<pre><code class="language-rust">use debug::PrintTrait;
#[derive(Copy, Drop)]
struct Rectangle {
    width: u64,
    height: u64,
}

trait RectangleTrait {
    fn area(self: @Rectangle) -&gt; u64;
}

impl RectangleImpl of RectangleTrait {
    fn area(self: @Rectangle) -&gt; u64 {
        (*self.width) * (*self.height)
    }
}

fn main() {
    let rect1 = Rectangle { width: 30_u64, height: 50_u64,  };

    rect1.area().print();
}</code></pre>
<p><span class="caption">Listing 4-13: Defining an <code>area</code> method to use on the
<code>Rectangle</code> </span></p>
<p>To define the function within the context of <code>Rectangle</code>, we start by definining a <code>trait</code>
block with the signature of the method that we want to implement. Traits are not linked to
a specific type; only the <code>self</code> parameter of the method defines which type it can be used
with. Then, we define an <code>impl</code> (implementation) block for <code>RectangleTrait</code>, that defines
the behavior of the methods implemented. Everything within this <code>impl</code> block will be
associated with the type of the <code>self</code> parameter of the method called. While it is technically
possible to define methods for multiple types within the same <code>impl</code> block, it is not
a recommended practice, as it can lead to confusion. We recommend that the type of the <code>self</code> parameter
stays consistent within the same <code>impl</code> block.
Then we move the <code>area</code> function within the <code>impl</code> curly brackets and change the first (and in this case, only)
parameter to be <code>self</code> in the signature and everywhere within the body. In
<code>main</code>, where we called the <code>area</code> function and passed <code>rect1</code> as an argument,
we can instead use the <em>method syntax</em> to call the <code>area</code> method on our <code>Rectangle</code>
instance. The method syntax goes after an instance: we add a dot followed by
the method name, parentheses, and any arguments.</p>
<p>Methods must have a parameter named <code>self</code> of the type they will be applied to for their first parameter.
Note that we used the <code>@</code> snapshot operator in front of the <code>Rectangle</code> type in the function signature.
By doing so, we indicate that this method takes an immutable snapshot of the <code>Rectangle</code> instance, which is
automatically created by the compiler when passing the instance to the method.
Methods can take ownership of <code>self</code>, use <code>self</code> with snapshots as we’ve done here, or use a mutable reference to <code>self</code>
using the <code>ref self: T</code> syntax.</p>
<p>We chose <code>self: @Rectangle</code> here for the same reason we used <code>@Rectangle</code> in the function
version: we don’t want to take ownership, and we just want to read the data in
the struct, not write to it. If we wanted to change the instance that we’ve
called the method on as part of what the method does, we’d use <code>ref self: Rectangle</code> as
the first parameter. Having a method that takes ownership of the instance by
using just <code>self</code> as the first parameter is rare; this technique is usually
used when the method transforms <code>self</code> into something else and you want to
prevent the caller from using the original instance after the transformation.</p>
<p>Observe the use of the desnap operator <code>*</code> within the area method when accessing the struct's members.
This is necessary because the struct is passed as a snapshot, and all of its field values are of type <code>@T</code>,
requiring them to be desnapped in order to manipulate them.</p>
<p>The main reason for using methods instead of functions is for organization and code clarity. We’ve put all the things we can do with an instance of a type in one combination of <code>trait</code> &amp; <code>impl</code> blocks, rather than making future users
of our code search for capabilities of <code>Rectangle</code> in various places in the
library we provide. However, we can define multiple combinations of <code>trait</code> &amp; <code>impl</code> blocks for the same type at different places, which can be useful for a more granular code organization. For example, you could implement
the <code>Add</code> trait for your type in one <code>impl</code> block, and the <code>Sub</code> trait in another block.</p>
<p>Note that we can choose to give a method the same name as one of the struct’s
fields. For example, we can define a method on <code>Rectangle</code> that is also named
<code>width</code>:</p>
<p><span class="filename">Filename: src/lib.cairo</span></p>
<pre><code class="language-rust">use debug::PrintTrait;
#[derive(Copy, Drop)]
struct Rectangle {
    width: u64,
    height: u64,
}

trait RectangleTrait {
    fn width(self: @Rectangle) -&gt; bool;
}

impl RectangleImpl of RectangleTrait {
    fn width(self: @Rectangle) -&gt; bool {
        (*self.width) &gt; 0_u64
    }
}

fn main() {
    let rect1 = Rectangle { width: 30_u64, height: 50_u64,  };
    rect1.width().print();
}</code></pre>
<p>Here, we’re choosing to make the <code>width</code> method return <code>true</code> if the value in
the instance’s <code>width</code> field is greater than <code>0</code> and <code>false</code> if the value is
<code>0</code>: we can use a field within a method of the same name for any purpose. In
<code>main</code>, when we follow <code>rect1.width</code> with parentheses, Cairo knows we mean the
method <code>width</code>. When we don’t use parentheses, Cairo knows we mean the field
<code>width</code>.</p>
<h3 id="methods-with-more-parameters"><a class="header" href="#methods-with-more-parameters">Methods with More Parameters</a></h3>
<p>Let’s practice using methods by implementing a second method on the <code>Rectangle</code>
struct. This time we want an instance of <code>Rectangle</code> to take another instance
of <code>Rectangle</code> and return <code>true</code> if the second <code>Rectangle</code> can fit completely
within <code>self</code> (the first <code>Rectangle</code>); otherwise, it should return <code>false</code>.
That is, once we’ve defined the <code>can_hold</code> method, we want to be able to write
the program shown in Listing 5-14.</p>
<p><span class="filename">Filename: src/lib.cairo</span></p>
<pre><code class="language-swift">use debug::PrintTrait;
#[derive(Copy, Drop)]
struct Rectangle {
    width: u64,
    height: u64,
}


fn main() {
    let rect1 = Rectangle {
        width: 30_u64,
        height: 50_u64,
    };
    let rect2 = Rectangle {
        width: 10_u64,
        height: 40_u64,
    };
    let rect3 = Rectangle {
        width: 60_u64,
        height: 45_u64,
    };

    'Can rect1 hold rect2?'.print();
    rect1.can_hold(@rect2).print();

    'Can rect1 hold rect?'.print();
    rect1.can_hold(@rect3).print();
}
</code></pre>
<p><span class="caption">Listing 5-14: Using the as-yet-unwritten <code>can_hold</code>
method</span></p>
<p>The expected output would look like the following because both dimensions of
<code>rect2</code> are smaller than the dimensions of <code>rect1</code>, but <code>rect3</code> is wider than
<code>rect1</code>:</p>
<pre><code class="language-text">❯ cairo-run src/lib.cairo
[DEBUG]	Can rec1 hold rect2?           	(raw: 384675147322001379018464490539350216396261044799)

[DEBUG]	true                           	(raw: 1953658213)

[DEBUG]	Can rect1 hold rect?           	(raw: 384675147322001384331925548502381811111693612095)

[DEBUG]	false                          	(raw: 439721161573)

</code></pre>
<p>We know we want to define a method, so it will be within the <code>trait RectangleTrait</code>
and <code>impl RectangleImpl of RectangleTrait</code> blocks.
The method name will be <code>can_hold</code>, and it will take a snapshot
of another <code>Rectangle</code> as a parameter. We can tell what the type of the
parameter will be by looking at the code that calls the method:
<code>rect1.can_hold(@rect2)</code> passes in <code>@rect2</code>, which is a snapshot to
<code>rect2</code>, an instance of <code>Rectangle</code>. This makes sense because we only need to
read <code>rect2</code> (rather than write, which would mean we’d need a mutable borrow),
and we want <code>main</code> to retain ownership of <code>rect2</code> so we can use it again after
calling the <code>can_hold</code> method. The return value of <code>can_hold</code> will be a
Boolean, and the implementation will check whether the width and height of
<code>self</code> are greater than the width and height of the other <code>Rectangle</code>,
respectively. Let’s add the new <code>can_hold</code> method to the <code>trait</code> and <code>impl</code> blocks from
Listing 5-13, shown in Listing 5-15.</p>
<p><span class="filename">Filename: src/lib.cairo</span></p>
<pre><code class="language-rust">trait RectangleTrait {
    fn area(self: @Rectangle) -&gt; u64;
    fn can_hold(self: @Rectangle, other: @Rectangle) -&gt; bool;
}

impl RectangleImpl of RectangleTrait {
    fn area(self: @Rectangle) -&gt; u64 {
        *self.width * *self.height
    }

    fn can_hold(self: @Rectangle, other: @Rectangle) -&gt; bool {
        *self.width &gt; *other.width &amp; *self.height &gt; *other.height
    }
}</code></pre>
<p><span class="caption">Listing 5-15: Implementing the <code>can_hold</code> method on
<code>Rectangle</code> that takes another <code>Rectangle</code> instance as a parameter</span></p>
<p>When we run this code with the <code>main</code> function in Listing 5-14, we’ll get our
desired output. Methods can take multiple parameters that we add to the
signature after the <code>self</code> parameter, and those parameters work just like
parameters in functions.</p>
<h3 id="accessing-implementation-functions"><a class="header" href="#accessing-implementation-functions">Accessing implementation functions</a></h3>
<p>All functions defined within a <code>trait</code> and <code>impl</code> block can be directly addressed
using the <code>::</code> operator on the implementation name.
Functions in traits that aren’t methods are often used for constructors that
will return a new instance of the struct. These are often called <code>new</code>, but
<code>new</code> isn’t a special name and isn’t built into the language. For example, we
could choose to provide an associated function named <code>square</code> that would have
one dimension parameter and use that as both width and height, thus making it
easier to create a square <code>Rectangle</code> rather than having to specify the same
value twice:</p>
<p><span class="filename">Filename: src/lib.cairo</span></p>
<pre><code class="language-rust">trait RectangleTrait {
    fn square(size:u64) -&gt; Rectangle;
}

impl RectangleImpl of RectangleTrait {
    fn square(size: u64) -&gt; Rectangle {
        Rectangle { width: size, height: size }
    }
}</code></pre>
<p>To call this function, we use the <code>::</code> syntax with the implementation name;
<code>let square = RectangleImpl::square(10_u64);</code> is an example. This function is namespaced by
the implementation: the <code>::</code> syntax is used for both trait functions and
namespaces created by modules. We’ll discuss modules in [Chapter 7][modules]<!-- ignore -->.</p>
<blockquote>
<p>Note: It is also possible to call this function using the trait name, with <code>RectangleTrait::square(10_u64)</code>.</p>
</blockquote>
<h3 id="multiple-impl-blocks"><a class="header" href="#multiple-impl-blocks">Multiple <code>impl</code> Blocks</a></h3>
<p>Each struct is allowed to have multiple <code>trait</code> and <code>impl</code> blocks. For example, Listing
5-15 is equivalent to the code shown in Listing 5-16, which has each method in
its own <code>trait</code> and <code>impl</code> blocks.</p>
<pre><code class="language-rust">trait RectangleCalc {
    fn area(self: @Rectangle) -&gt; u64;
}
impl RectangleCalcImpl of RectangleCalc {
    fn area(self: @Rectangle) -&gt; u64 {
        (*self.width) * (*self.height)
    }
}

trait RectangleCmp {
    fn can_hold(self: @Rectangle, other: @Rectangle) -&gt; bool;
}

impl RectangleCmpImpl of RectangleCmp {
    fn can_hold(self: @Rectangle, other: @Rectangle) -&gt; bool {
        *self.width &gt; *other.width &amp; *self.height &gt; *other.height
    }
}</code></pre>
<p><span class="caption">Listing 5-16: Rewriting Listing 5-15 using multiple <code>impl</code>
blocks</span></p>
<p>There’s no reason to separate these methods into multiple <code>trait</code> and <code>impl</code> blocks here,
but this is valid syntax. We’ll see a case in which multiple blocks are
useful in <a href="ch07-00-generic-types-and-traits.html">Chapter 7</a>, where we discuss generic types and traits.</p>
<h2 id="summary-1"><a class="header" href="#summary-1">Summary</a></h2>
<p>Structs let you create custom types that are meaningful for your domain. By
using structs, you can keep associated pieces of data connected to each other
and name each piece to make your code clear. In <code>trait</code> and <code>impl</code> blocks, you can define
methods, which are functions associated to a type and let you specify the behavior that instances of your
type have.</p>
<p>But structs aren’t the only way you can create custom types: let’s turn to
Cairo’s enum feature to add another tool to your toolbox.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="enums-and-pattern-matching"><a class="header" href="#enums-and-pattern-matching">Enums and Pattern Matching</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="enums"><a class="header" href="#enums">Enums</a></h1>
<p>Enums, short for &quot;enumerations,&quot; are a way to define a custom data type that consists of a fixed set of named values, called <em>variants</em>. Enums are useful for representing a collection of related values where each value is distinct and has a specific meaning.</p>
<h2 id="enum-variants-and-values"><a class="header" href="#enum-variants-and-values">Enum Variants and Values</a></h2>
<p>Here's a simple example of an enum:</p>
<pre><code class="language-rs">#[derive(Drop)]
enum Direction {
    North : (),
    East : (),
    South : (),
    West : (),
}
</code></pre>
<p>Unlike other languages like Rust, every variant has a type. In this example, we've defined an enum called <code>Direction</code> with four variants: <code>North</code>, <code>East</code>, <code>South</code>, and <code>West</code>. The naming convention is to use PascalCase for enum variants. Each variant represents a distinct value of the Direction type and is associated with a unit type <code>()</code>. One variant can be instanciated using this syntax:</p>
<pre><code class="language-rs">let direction = Direction::North(());
</code></pre>
<p>It's easy to write code that acts differently depending on the variant of an enum instance, in this example to run specific code according to a Direction. You can learn more about it on the <a href="ch05-02-the-match-control-flow-construct.html">The Match Control Flow Construct page</a>.</p>
<h2 id="enums-combined-with-custom-types"><a class="header" href="#enums-combined-with-custom-types">Enums Combined with Custom Types</a></h2>
<p>Enums can also be used to store more interesting data associated with each variant. For example:</p>
<pre><code class="language-rs">#[derive(Drop)]
enum Message {
    Quit : (),
    Echo : (felt252),
    Move : (u128, u128),
}
</code></pre>
<p>In this example, the <code>Message</code> enum has three variants: <code>Quit</code>, <code>Echo</code> and <code>Move</code>, all with different types:</p>
<ul>
<li><code>Quit</code> has no data associated with it at all.</li>
<li><code>Echo</code> includes a single felt.</li>
<li><code>Move</code> includes two u128 values.</li>
</ul>
<p>You could even use a Struct or another Enum you defined inside one of your Enum variants.</p>
<h2 id="trait-implementations-for-enums"><a class="header" href="#trait-implementations-for-enums">Trait Implementations for Enums</a></h2>
<p>In Cairo, you can define traits and implement them for your custom enums. This allows you to define methods and behaviors associated with the enum. Here's an example of defining a trait and implementing it for the previous <code>Message</code> enum:</p>
<pre><code class="language-rs">trait Processing {
    fn process(self: Message);
}

impl ProcessingImpl of Processing {
    fn process(self: Message) {
        match self {
            Message::Quit(()) =&gt; {
                'quitting'.print();
            },
            Message::Echo(value) =&gt; {
                value.print();
            },
            Message::Move((x, y)) =&gt; {
                'moving'.print();
            },
        }
    }
}
</code></pre>
<p>In this example, we implemented the <code>Processing</code> trait for <code>Message</code>. Here is how it could be used to process a Quit message:</p>
<pre><code class="language-rust">let msg: Message = Message::Quit(());
msg.process();</code></pre>
<p>Running this code would print <code>quitting</code>.</p>
<h2 id="the-option-enum-and-its-advantages"><a class="header" href="#the-option-enum-and-its-advantages">The Option Enum and Its Advantages</a></h2>
<p>The Option enum is a standard Cairo enum that represents the concept of an optional value. It has two variants: <code>Some: T</code> and <code>None: ()</code>. <code>Some: T </code> indicates that there's a value of type <code>T</code>, while <code>None</code> represents the absence of a value.</p>
<pre><code class="language-rs">enum Option&lt;T&gt; {
    Some: T,
    None: (),
}
</code></pre>
<p>The <code>Option</code> enum is helpful because it allows you to explicitly represent the possibility of a value being absent, making your code more expressive and easier to reason about. Using <code>Option</code> can also help prevent bugs caused by using uninitialized or unexpected <code>null</code> values.</p>
<p>To give you an example, here is a function which returns the index of the first element of an array with a given value, or None if the element is not present.</p>
<blockquote>
<p>Note: in the future it would be nice to replace this example by something simpler using a loop and without gas related code.</p>
</blockquote>
<pre><code class="language-rust">use array::ArrayTrait;
use debug::PrintTrait;
fn find_value_recursive(
    arr: @Array&lt;felt252&gt;, value: felt252, index: usize
) -&gt; Option&lt;usize&gt; {

    match gas::withdraw_gas() {
        Option::Some(_) =&gt; {},
        Option::None(_) =&gt; {
            let mut data = ArrayTrait::new();
            data.append('OOG');
            panic(data);
        },
    }

    if index &gt;= arr.len() {
        return Option::None(());
    }

    if *arr.at(index) == value {
        return Option::Some(index);
    }

    find_value_recursive(arr, value, index + 1_usize)
}

#[test]
#[available_gas(999999)]
fn test_increase_amount() {
    let mut my_array = ArrayTrait::new();
    my_array.append(3);
    my_array.append(7);
    my_array.append(2);
    my_array.append(5);

    let value_to_find = 7;
    let result = find_value_recursive(@my_array, value_to_find, 0_usize);

    match result {
        Option::Some(index) =&gt; {
            if index == 1_usize {
                'it worked'.print();
            }
        },
        Option::None(()) =&gt; {
            'not found'.print();
        },
    }
}</code></pre>
<p>Running this code would print <code>it worked</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-match-control-flow-construct"><a class="header" href="#the-match-control-flow-construct">The Match Control Flow Construct</a></h1>
<!-- TODO : update mention of chapter 18 (on patterns and matching chapter) in paragraph below -->
<p>Cairo has an extremely powerful control flow construct called <code>match</code> that allows you to compare a value against a series of patterns and then execute code based on which pattern matches. Patterns can be made up of literal values, variable names, wildcards, and many other things. The power of match comes from the expressiveness of the patterns and the fact that the compiler confirms that all possible cases are handled.</p>
<p>Think of a match expression as being like a coin-sorting machine: coins slide down a track with variously sized holes along it, and each coin falls through the first hole it encounters that it fits into. In the same way, values go through each pattern in a match, and at the first pattern the value “fits”, the value falls into the associated code block to be used during execution.</p>
<p>Speaking of coins, let’s use them as an example using match! We can write a function that takes an unknown US coin and, in a similar way as the counting machine, determines which coin it is and and returns its value in cents, as shown in Listing 5-3.</p>
<pre><code class="language-rust">enum Coin {
    Penny: (),
    Nickel: (),
    Dime: (),
    Quarter: (),
}

fn value_in_cents(coin: Coin) -&gt; felt252 {
    match coin {
        Coin::Penny(_) =&gt; 1,
        Coin::Nickel(_) =&gt; 5,
        Coin::Dime(_) =&gt; 10,
        Coin::Quarter(_)=&gt; 25,
    }
}</code></pre>
<p>Listing 5-3: An enum and a match expression that has the variants of the enum as its patterns</p>
<p>Let’s break down the <code>match</code> in the <code>value_in_cents</code> function. First we list the <code>match</code> keyword followed by an expression, which in this case is the value <code>coin</code>. This seems very similar to a conditional expression used with if, but there’s a big difference: with if, the condition needs to evaluate to a Boolean value, but here it can be any type. The type of coin in this example is the <code>Coin</code> enum that we defined on the first line.</p>
<p>Next are the <code>match</code> arms. An arm has two parts: a pattern and some code. The first arm here has a pattern that is the value <code>Coin::Penny(_)</code> and then the <code>=&gt;</code> operator that separates the pattern and the code to run. The code in this case is just the value <code>1</code>. Each arm is separated from the next with a comma.</p>
<p>When the <code>match</code> expression executes, it compares the resultant value against the pattern of each arm, in order. If a pattern matches the value, the code associated with that pattern is executed. If that pattern doesn’t match the value, execution continues to the next arm, much as in a coin-sorting machine. We can have as many arms as we need: in the above example, our match has four arms.</p>
<p>In Cairo, the order of the arms must follow the same order as the enum.</p>
<p>The code associated with each arm is an expression, and the resultant value of the expression in the matching arm is the value that gets returned for the entire match expression.</p>
<p>We don’t typically use curly brackets if the match arm code is short, as it is in our example where each arm just returns a value. If you want to run multiple lines of code in a match arm, you must use curly brackets, with a comma following the arm. For example, the following code prints “Lucky penny!” every time the method is called with a <code>Coin::Penny(())</code>, but still returns the last value of the block, <code>1</code>:</p>
<pre><code class="language-rust">fn value_in_cents(coin: Coin) -&gt; felt252 {
    match coin {
        Coin::Penny(_) =&gt; {
            ('Lucky penny!').print();
            1
        },
        Coin::Nickel(_) =&gt; 5,
        Coin::Dime(_) =&gt; 10,
        Coin::Quarter(_)=&gt; 25,
    }
}</code></pre>
<h2 id="patterns-that-bind-to-values"><a class="header" href="#patterns-that-bind-to-values">Patterns That Bind to Values</a></h2>
<p>Another useful feature of match arms is that they can bind to the parts of the values that match the pattern. This is how we can extract values out of enum variants.</p>
<p>As an example, let’s change one of our enum variants to hold data inside it. From 1999 through 2008, the United States minted quarters with different designs for each of the 50 states on one side. No other coins got state designs, so only quarters have this extra value. We can add this information to our <code>enum</code> by changing the <code>Quarter</code> variant to include a <code>UsState</code> value stored inside it, which we’ve done in Listing 5-4.</p>
<pre><code class="language-rust">#[derive(Drop)]
enum UsState {
    Alabama: (),
    Alaska: (),
}

#[derive(Drop)]
enum Coin {
    Penny: (),
    Nickel: (),
    Dime: (),
    Quarter: (UsState),
}</code></pre>
<p>Listing 5-4: A <code>Coin</code> enum in which the <code>Quarter</code> variant also holds a <code>UsState</code> value</p>
<p>Let’s imagine that a friend is trying to collect all 50 state quarters. While we sort our loose change by coin type, we’ll also call out the name of the state associated with each quarter so that if it’s one our friend doesn’t have, they can add it to their collection.</p>
<p>In the match expression for this code, we add a variable called <code>state</code> to the pattern that matches values of the variant <code>Coin::Quarter</code>. When a <code>Coin::Quarter</code> matches, the <code>state</code> variable will bind to the value of that quarter’s state. Then we can use <code>state</code> in the code for that arm, like so:</p>
<pre><code class="language-rust">fn value_in_cents(coin: Coin) -&gt; felt252 {
    match coin {
        Coin::Penny(_) =&gt; 1,
        Coin::Nickel(_) =&gt; 5,
        Coin::Dime(_) =&gt; 10,
        Coin::Quarter(state)=&gt; {
            state.print();
            25
        },
    }
}</code></pre>
<p>To print the value of a variant of an enum in Cairo, we need to add an implementation for the <code>print</code> function for the <code>debug::PrintTrait</code>:</p>
<pre><code class="language-rust">impl UsStatePrintImpl of PrintTrait::&lt;UsState&gt; {
    fn print(self: UsState) {
        match self {
            UsState::Alabama(_) =&gt; ('Alabama').print(),
            UsState::Alaska(_) =&gt; ('Alaska').print(),
        }
    }
}</code></pre>
<p>If we were to call <code>value_in_cents(Coin::Quarter(UsState::Alaska(())))</code>, <code>coin</code> would be <code>Coin::Quarter(UsState::Alaska())</code>. When we compare that value with each of the match arms, none of them match until we reach <code>Coin::Quarter(state)</code>. At that point, the binding for state will be the value <code>UsState::Alaska()</code>. We can then use that binding in the <code>PrintTrait</code>, thus getting the inner state value out of the <code>Coin</code> enum variant for <code>Quarter</code>.</p>
<h2 id="matching-with-options"><a class="header" href="#matching-with-options">Matching with Options</a></h2>
<p>In the previous section, we wanted to get the inner <code>T</code> value out of the <code>Some</code> case when using <code>Option&lt;T&gt;</code>; we can also handle <code>Option&lt;T&gt;</code> using <code>match</code>, as we did with the <code>Coin</code> enum! Instead of comparing coins, we’ll compare the variants of <code>Option&lt;T&gt;</code>, but the way the <code>match</code> expression works remains the same. You can use Options by importing the <code>option::OptionTrait</code> trait.</p>
<p>Let’s say we want to write a function that takes an <code>Option&lt;u8&gt;</code> and, if there’s a value inside, adds <code>1_u8</code> to that value. If there isn’t a value inside, the function should return the <code>None</code> value and not attempt to perform any operations.</p>
<p>This function is very easy to write, thanks to match, and will look like Listing 5-5.</p>
<pre><code class="language-rust">use option::OptionTrait;
use debug::PrintTrait;

fn plus_one(x: Option&lt;u8&gt;) -&gt; Option&lt;u8&gt; {
    match x {
        Option::Some(val) =&gt; Option::Some(val + 1_u8),
        Option::None(_) =&gt; Option::None(()),
    }
}

fn main() {
    let five : Option&lt;u8&gt; = Option::Some(5_u8);
    let six : Option&lt;u8&gt; = plus_one(five);
    six.unwrap().print();
    let none = plus_one(Option::None(()));
    none.unwrap().print();
}</code></pre>
<p>Listing 5-5: A function that uses a match expression on an <code>Option&lt;u8&gt;</code></p>
<p>Note that your arms must respect the same order as the enum defined in the <code>OptionTrait</code> of the core Cairo lib.</p>
<pre><code class="language-rust">    enum Option&lt;T&gt; {
        Some: T,
        None: (),
    }</code></pre>
<p>Let’s examine the first execution of <code>plus_one</code> in more detail. When we call <code>plus_one(five)</code>, the variable <code>x</code> in the body of <code>plus_one</code> will have the value <code>Some(5_u8)</code>. We then compare that against each match arm:</p>
<pre><code class="language-rust">    Option::Some(val) =&gt; Option::Some(val + 1_u8),</code></pre>
<p>The <code>Option::Some(5_u8)</code> value match the pattern <code>Option::Some(val)</code>? It does! We have the same variant. The <code>val</code> binds to the value contained in <code>Option::Some</code>, so <code>val</code> takes the value <code>5_u8</code>. The code in the match arm is then executed, so we add <code>1_u8</code> to the value of <code>val</code> and create a new <code>Option::Some</code> value with our total <code>6_u8</code> inside. Because the first arm matched, no other arms are compared.</p>
<p>Now let’s consider the second call of <code>plus_one</code> in our main function, where <code>x</code> is <code>Option::None(())</code>. We enter the match and compare to the first arm:</p>
<pre><code class="language-rust">    Option::Some(val) =&gt; Option::Some(val + 1_u8),</code></pre>
<p>The <code>Option::Some(5_u8)</code> value doesn’t match the pattern <code>Option::None</code>, so we continue to the next arm:</p>
<pre><code class="language-rust">    Option::None(_) =&gt; Option::None(()),</code></pre>
<p>It matches! There’s no value to add to, so the program stops and returns the <code>Option::None(())</code> value on the right side of <code>=&gt;</code>.</p>
<p>Combining <code>match</code> and enums is useful in many situations. You’ll see this pattern a lot in Cairo code: <code>match</code> against an enum, bind a variable to the data inside, and then execute code based on it. It’s a bit tricky at first, but once you get used to it, you’ll wish you had it in all languages. It’s consistently a user favorite.</p>
<h2 id="matches-are-exhaustive"><a class="header" href="#matches-are-exhaustive">Matches Are Exhaustive</a></h2>
<p>There’s one other aspect of match we need to discuss: the arms’ patterns must cover all possibilities. Consider this version of our <code>plus_one</code> function, which has a bug and won’t compile:</p>
<pre><code class="language-bash">$ cairo-run src/test.cairo
    error: Unsupported match. Currently, matches require one arm per variant,
    in the order of variant definition.
    --&gt; test.cairo:34:5
        match x {
        ^*******^
    Error: failed to compile: ./src/test.cairo
</code></pre>
<p>Cairo knows that we didn’t cover every possible case, and even knows which pattern we forgot! Matches in Cairo are exhaustive: we must exhaust every last possibility in order for the code to be valid. Especially in the case of <code>Option&lt;T&gt;</code>, when Cairo prevents us from forgetting to explicitly handle the <code>None</code> case, it protects us from assuming that we have a value when we might have null, thus making the billion-dollar mistake discussed earlier impossible.</p>
<h2 id="match-0-and-the-_-placeholder"><a class="header" href="#match-0-and-the-_-placeholder">Match 0 and the _ Placeholder</a></h2>
<p>Using enums, we can also take special actions for a few particular values, but for all other values take one default action. Currently only <code>0</code> and the <code>_</code>operator are supported.</p>
<p>Imagine we’re implementing a game where, you get a random number between 0 and 7. If you have 0, you win. For all other values you loose. Here's a match that implements that logic, with the number hardcoded rather than a random value.</p>
<pre><code class="language-rust">fn did_i_win(nb: felt252) {
    match nb {
        0 =&gt; ('You won!').print(),
        _ =&gt; ('You lost...').print(),
    }
}</code></pre>
<p>The first arm, the pattern is the literal values 0. For the last arm that covers every other possible value, the pattern is the character <code>_</code>. This code compiles, even though we haven’t listed all the possible values a <code>felt252</code> can have, because the last pattern will match all values not specifically listed. This catch-all pattern meets the requirement that <code>match</code> must be exhaustive. Note that we have to put the catch-all arm last because the patterns are evaluated in order. If we put the catch-all arm earlier, the other arms would never run, so Cairo will warn us if we add arms after a catch-all!</p>
<!-- TODO : might need to link the end of this chapter to patterns and matching chapter -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="managing-cairo-projects-with-packages-crates-and-modules"><a class="header" href="#managing-cairo-projects-with-packages-crates-and-modules">Managing Cairo Projects with Packages, Crates and Modules</a></h1>
<p>As you write large programs, organizing your code will become increasingly
important. By grouping related functionality and separating code with distinct
features, you’ll clarify where to find code that implements a particular
feature and where to go to change how a feature works.</p>
<p>The programs we’ve written so far have been in one module in one file. As a
project grows, you should organize code by splitting it into multiple modules
and then multiple files. As a package grows, you can extract parts into
separate crates that become external dependencies. This chapter covers all
these techniques.</p>
<p>We’ll also discuss encapsulating implementation details, which lets you reuse
code at a higher level: once you’ve implemented an operation, other code can
call your code without having to know how the
implementation works.</p>
<p>A related concept is scope: the nested context in which code is written has a
set of names that are defined as “in scope.” When reading, writing, and
compiling code, programmers and compilers need to know whether a particular
name at a particular spot refers to a variable, function, struct, enum, module,
constant, or other item and what that item means. You can create scopes and
change which names are in or out of scope. You can’t have two items with the
same name in the same scope.</p>
<p>Cairo has a number of features that allow you to manage your code’s
organization. These features, sometimes
collectively referred to as the <em>module system</em>, include:</p>
<ul>
<li><strong>Packages:</strong> A Scarb feature that lets you build, test, and share crates</li>
<li><strong>Crates:</strong> A tree of modules that corresponds to a single compilation unit.
It has a root directory, and a root module defined at the file <code>lib.cairo</code> under this directory.</li>
<li><strong>Modules</strong> and <strong>use:</strong> Let you control the organization and scope of items.</li>
<li><strong>Paths:</strong> A way of naming an item, such as a struct, function, or module</li>
</ul>
<p>In this chapter, we’ll cover all these features, discuss how they interact, and
explain how to use them to manage scope. By the end, you should have a solid
understanding of the module system and be able to work with scopes like a pro!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="packages-and-crates"><a class="header" href="#packages-and-crates">Packages and Crates</a></h1>
<h2 id="what-is-a-crate"><a class="header" href="#what-is-a-crate">What is a crate?</a></h2>
<p>A crate is the smallest amount of code that the Cairo compiler considers at a time. Even if you run <code>cairo-compile</code> rather than <code>scarb build</code> and pass a single source code file, the compiler considers that file to be a crate. Crates can contain modules, and the modules may be defined in other files that get compiled with the crate, as will be discussed in the subsequent sections.</p>
<h2 id="what-is-the-crate-root"><a class="header" href="#what-is-the-crate-root">What is the crate root?</a></h2>
<p>The crate root is the <code>lib.cairo</code> source file that the Cairo compiler starts from and makes up the root module of your crate (we’ll explain modules in depth in the <a href="./ch06-02-defining-modules-to-control-scope.html">“Defining Modules to Control Scope”</a> section).</p>
<h2 id="what-is-a-package"><a class="header" href="#what-is-a-package">What is a package?</a></h2>
<p>A cairo package is a bundle of one or more crates with a Scarb.toml file that describes how to build those crates. This enables the splitting of code into smaller, reusable parts and facilitates more structured dependency management.</p>
<h2 id="creating-a-package-with-scarb"><a class="header" href="#creating-a-package-with-scarb">Creating a Package with Scarb</a></h2>
<p>You can create a new Cairo package using the scarb command-line tool. To create a new package, run the following command:</p>
<pre><code class="language-bash">scarb new my_crate
</code></pre>
<p>This command will generate a new package directory named my_crate with the following structure:</p>
<pre><code>my_crate/
├── Scarb.toml
└── src
    └── lib.cairo
</code></pre>
<ul>
<li><code>src/</code> is the main directory where all the Cairo source files for the package will be stored.</li>
<li><code>lib.cairo</code> is the default root module of the crate, which is also the main entry point of the package. By default, it is empty.</li>
<li><code>Scarb.toml</code> is the package manifest file, which contains metadata and configuration options for the package, such as dependencies, package name, version, and authors. You can find documentation about it on the <a href="https://docs.swmansion.com/scarb/docs/reference/manifest">scarb reference</a>.</li>
</ul>
<pre><code class="language-toml">[package]
name = &quot;my_crate&quot;
version = &quot;0.1.0&quot;

[dependencies]
# foo = { path = &quot;vendor/foo&quot; }
</code></pre>
<p>As you develop your package, you may want to organize your code into multiple Cairo source files. You can do this by creating additional <code>.cairo</code> files within the <code>src</code> directory or its subdirectories.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="defining-modules-to-control-scope"><a class="header" href="#defining-modules-to-control-scope">Defining Modules to Control Scope</a></h2>
<p>In this section, we’ll talk about modules and other parts of the module system,
namely <em>paths</em> that allow you to name items and the <code>use</code> keyword that brings a
path into scope.</p>
<p>First, we’re going to start with a list of rules for easy reference when you’re
organizing your code in the future. Then we’ll explain each of the rules in
detail.</p>
<h3 id="modules-cheat-sheet"><a class="header" href="#modules-cheat-sheet">Modules Cheat Sheet</a></h3>
<p>Here we provide a quick reference on how modules, paths and the <code>use</code> keyword
work in the compiler, and how most developers organize their
code. We’ll be going through examples of each of these rules throughout this
chapter, but this is a great place to refer to as a reminder of how modules
work. You can create a new Scarb project with <code>scarb new backyard</code> to follow along.</p>
<ul>
<li>
<p><strong>Start from the crate root</strong>: When compiling a crate, the compiler first
looks in the crate root file (<em>src/lib.cairo</em>) for code to compile.</p>
</li>
<li>
<p><strong>Declaring modules</strong>: In the crate root file, you can declare new modules;
say, you declare a “garden” module with <code>mod garden;</code>. The compiler will look
for the module’s code in these places:</p>
<ul>
<li>
<p>Inline, within curly brackets that replace the semicolon following <code>mod garden;</code>.</p>
<pre><code class="language-rust">  // crate root file (lib.cairo)
    mod garden {
    // code defining the garden module goes here
    }</code></pre>
</li>
</ul>
</li>
<li>
<p>In the file <em>src/garden.cairo</em></p>
</li>
<li>
<p><strong>Declaring submodules</strong>: In any file other than the crate root, you can
declare submodules. For example, you might declare <code>mod vegetables;</code> in
<em>src/garden.cairo</em>. The compiler will look for the submodule’s code within the
directory named for the parent module in these places:</p>
<ul>
<li>
<p>Inline, directly following <code>mod vegetables</code>, within curly brackets instead
of the semicolon.</p>
<pre><code class="language-rust">// src/garden.cairo file
mod vegetables {
    // code defining the vegetables submodule goes here
}</code></pre>
</li>
<li>
<p>In the file <em>src/garden/vegetables.cairo</em></p>
</li>
</ul>
</li>
<li>
<p><strong>Paths to code in modules</strong>: Once a module is part of your crate, you can
refer to code in that module from anywhere else in that same crate, using the path
to the code. For example, an <code>Asparagus</code> type in the garden vegetables module would be found at
<code>backyard::garden::vegetables::Asparagus</code>.</p>
</li>
<li>
<p><strong>The <code>use</code> keyword</strong>: Within a scope, the <code>use</code> keyword creates shortcuts to
items to reduce repetition of long paths. In any scope that can refer to
<code>backyard::garden::vegetables::Asparagus</code>, you can create a shortcut with
<code>use backyard::garden::vegetables::Asparagus;</code> and from then on you only need to
write <code>Asparagus</code> to make use of that type in the scope.</p>
</li>
</ul>
<p>Here we create a crate named <code>backyard</code> that illustrates these rules. The
crate’s directory, also named <code>backyard</code>, contains these files and directories:</p>
<pre><code class="language-text">backyard/
├── Scarb.toml
├── cairo_project.toml
└── src
    ├── garden
    │   └── vegetables.cairo
    ├── garden.cairo
    └── lib.cairo
</code></pre>
<blockquote>
<p>Note: You will notice here a <code>cairo_project.toml</code> file.
This is the configuration file for &quot;vanilla&quot; Cairo projects (i.e. not managed by Scarb),
which is required to run the <code>cairo-run .</code> command to run the code of the crate.
It is required until Scarb implements this feature. The content of the file is:</p>
<pre><code class="language-toml">[crate_roots]
backyard = &quot;src&quot;
</code></pre>
<p>and indicates that the crate named &quot;backyard&quot; is located in the <code>src</code> directory.</p>
</blockquote>
<p>The crate root file in this case is <em>src/lib.cairo</em>, and it contains:</p>
<p><span class="filename">Filename: src/lib.cairo</span></p>
<pre><code class="language-rust">use garden::vegetables::Asparagus;

mod garden;

fn main(){
    let Asparagus = Asparagus{};
}

</code></pre>
<p>The <code>mod garden;</code> line tells the compiler to include the code it finds in <em>src/garden.cairo</em>, which is:</p>
<p><span class="filename">Filename: src/garden.cairo</span></p>
<pre><code class="language-rust">mod vegetables;</code></pre>
<p>Here, <code>mod vegetables;</code> means the code in <em>src/garden/vegetables.cairo</em> is
included too. That code is:</p>
<pre><code class="language-rust">#[derive(Copy,Drop)]
struct Asparagus{}</code></pre>
<p>The line <code>use garden::vegetables::Asparagus;</code> lets us use bring the <code>Asparagus</code> type into scope,
so we can use it in the <code>main</code> function.</p>
<p>Now let’s get into the details of these rules and demonstrate them in action!</p>
<h3 id="grouping-related-code-in-modules"><a class="header" href="#grouping-related-code-in-modules">Grouping Related Code in Modules</a></h3>
<p><em>Modules</em> let us organize code within a crate for readability and easy reuse.
As an example, let’s write a library crate that provides the functionality of a
restaurant. We’ll define the signatures of functions but leave their bodies
empty to concentrate on the organization of the code, rather than the
implementation of a restaurant.</p>
<p>In the restaurant industry, some parts of a restaurant are referred to as
<em>front of house</em> and others as <em>back of house</em>. Front of house is where
customers are; this encompasses where the hosts seat customers, servers take
orders and payment, and bartenders make drinks. Back of house is where the
chefs and cooks work in the kitchen, dishwashers clean up, and managers do
administrative work.</p>
<p>To structure our crate in this way, we can organize its functions into nested
modules. Create a new package named <code>restaurant</code> by running <code>scarb new restaurant</code>; then enter the code in Listing 6-1 into <em>src/lib.cairo</em> to
define some modules and function signatures. Here’s the front of house section:</p>
<p><span class="filename">Filename: src/lib.cairo</span></p>
<pre><code class="language-rust">mod front_of_house {
    mod hosting {
        fn add_to_waitlist() {}

        fn seat_at_table() {}
    }

    mod serving {
        fn take_order() {}

        fn serve_order() {}

        fn take_payment() {}
    }
}</code></pre>
<p><span class="caption">Listing 6-1: A <code>front_of_house</code> module containing other
modules that then contain functions</span></p>
<p>We define a module with the <code>mod</code> keyword followed by the name of the module
(in this case, <code>front_of_house</code>). The body of the module then goes inside curly
brackets. Inside modules, we can place other modules, as in this case with the
modules <code>hosting</code> and <code>serving</code>. Modules can also hold definitions for other
items, such as structs, enums, constants, traits, and—as in Listing
6-1—functions.</p>
<p>By using modules, we can group related definitions together and name why
they’re related. Programmers using this code can navigate the code based on the
groups rather than having to read through all the definitions, making it easier
to find the definitions relevant to them. Programmers adding new functionality
to this code would know where to place the code to keep the program organized.</p>
<p>Earlier, we mentioned that <em>src/lib.cairo</em> is called the crate
root. The reason for this name is that the content of this file form a module named after the crate name at the root of the crate’s module structure,
known as the <em>module tree</em>.</p>
<p>Listing 6-2 shows the module tree for the structure in Listing 6-1.</p>
<pre><code class="language-text">restaurant
 └── front_of_house
     ├── hosting
     │   ├── add_to_waitlist
     │   └── seat_at_table
     └── serving
         ├── take_order
         ├── serve_order
         └── take_payment
</code></pre>
<p><span class="caption">Listing 6-2: The module tree for the code in Listing
6-1</span></p>
<p>This tree shows how some of the modules nest inside one another; for example,
<code>hosting</code> nests inside <code>front_of_house</code>. The tree also shows that some modules
are <em>siblings</em> to each other, meaning they’re defined in the same module;
<code>hosting</code> and <code>serving</code> are siblings defined within <code>front_of_house</code>. If module
A is contained inside module B, we say that module A is the <em>child</em> of module B
and that module B is the <em>parent</em> of module A. Notice that the entire module
tree is rooted under the explicit name of the crate <code>restaurant</code>.</p>
<p>The module tree might remind you of the filesystem’s directory tree on your
computer; this is a very apt comparison! Just like directories in a filesystem,
you use modules to organize your code. And just like files in a directory, we
need a way to find our modules.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="paths-for-referring-to-an-item-in-the-module-tree"><a class="header" href="#paths-for-referring-to-an-item-in-the-module-tree">Paths for Referring to an Item in the Module Tree</a></h2>
<p>To show Cairo where to find an item in a module tree, we use a path in the same way we use a path when navigating a filesystem. To call a function, we need to know its path.</p>
<p>A path can take two forms:</p>
<ul>
<li>
<p>An <em>absolute path</em> is the full path starting from a crate root. The absolute path begins with the crate name.</p>
</li>
<li>
<p>A <em>relative path</em> starts from the current module.</p>
<p>Both absolute and relative paths are followed by one or more identifiers
separated by double colons (<code>::</code>).</p>
</li>
</ul>
<p>To illustrate this notion let's take back our example for the restaurant we used in the last chapter. We have a crate named <code>restaurant</code> in which we have a module named <code>front_of_house</code> that contains a module named <code>hosting</code>. The <code>hosting</code> module contains a function named <code>add_to_waitlist</code>. We want to call the <code>add_to_waitlist</code> function from the <code>eat_at_restaurant</code> function. We need to tell Cairo the path to the <code>add_to_waitlist</code> function so it can find it.</p>
<p><span class="filename">Filename: src/lib.cairo</span></p>
<pre><code class="language-rust">mod front_of_house {
    mod hosting {
        fn add_to_waitlist() {}

        fn seat_at_table() {}
    }

    mod serving {
        fn take_order() {}

        fn serve_order() {}

        fn take_payment() {}
    }
}


pub fn eat_at_restaurant() {
    // Absolute path
    restaurant::front_of_house::hosting::add_to_waitlist(); // ✅ Compiles

    // Relative path
    front_of_house::hosting::add_to_waitlist(); // ✅ Compiles
}</code></pre>
<p>The first time we call the <code>add_to_waitlist</code> function in <code>eat_at_restaurant</code>,
we use an absolute path. The <code>add_to_waitlist</code> function is defined in the same
crate as <code>eat_at_restaurant</code>. In Cairo, absolute paths start from the crate root, which you need to refer to by using the crate name.</p>
<p>The second time we call <code>add_to_waitlist</code>, we use a relative path. The path starts with <code>front_of_house</code>, the name of the module
defined at the same level of the module tree as <code>eat_at_restaurant</code>. Here the
filesystem equivalent would be using the path
<code>./front_of_house/hosting/add_to_waitlist</code>. Starting with a module name means
that the path is relative to the current module.</p>
<h3 id="starting-relative-paths-with-super"><a class="header" href="#starting-relative-paths-with-super">Starting Relative Paths with <code>super</code></a></h3>
<p>Choosing whether to use a <code>super</code> or not is a decision you’ll make
based on your project, and depends on whether you’re more likely to move item
definition code separately from or together with the code that uses the item.</p>
<p><span class="filename">Filename: src/lib.cairo</span></p>
<pre><code class="language-rust">fn deliver_order() {}

mod back_of_house {
    fn fix_incorrect_order() {
        cook_order();
        super::deliver_order();
    }

    fn cook_order() {}
}</code></pre>
<p>Here you can see directly that you access a parent's module easily using <code>super</code>, which wasn't the case previously.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generic-types"><a class="header" href="#generic-types">Generic Types</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generic-data-types"><a class="header" href="#generic-data-types">Generic Data Types</a></h1>
<p>We use generics to create definitions for item declarations, such as structs and functions, which we can then use with many different concrete data types. In Cairo we can use generics when defining functions, structs, enums, traits, implementations and methods! In this chapter we are going to take a look on how to effectively use generic types with all of them.</p>
<h2 id="generic-functions"><a class="header" href="#generic-functions">Generic Functions</a></h2>
<p>When defining a function that uses generics, we place the generics in the function signature, where we would usually specify the data types of the parameter and return value. For example, imagine we want to create a function which given two <code>Array</code> of items, will return the largest one. If we need to perform this operations for lists of different types, then we would have to redefine the function each time. Luckily we can implement the function once using generics and move on to other tasks.</p>
<pre><code class="language-rust">// This code does not compile!

use array::ArrayTrait;

// Specify generic type T between the angulars
fn largest_list&lt;T&gt;(l1: Array&lt;T&gt;, l2: Array&lt;T&gt;) -&gt; Array&lt;T&gt; {
    if l1.len() &gt; l2.len() {
        l1
    } else {
        l2
    }
}

fn main() {
    let mut l1 = ArrayTrait::new();
    let mut l2 = ArrayTrait::new();

    l1.append(1);
    l1.append(2);

    l2.append(3);
    l2.append(4);
    l2.append(5);

    // There is no need to specify the concrete type of T because
    // it is inferred by the compiler
    let l3 = largest_list(l1, l2);
}</code></pre>
<p>The <code>largest_list</code> function compares two lists of the same type and returns the one with more elements and drops the other. If you compile the previous code, you will notice that it will fail with an error saying that there are no traits defined for droping an array of a generic type. This happens because the compiler has no way to guarantee that an <code>Array&lt;T&gt;</code> is droppable when executing the <code>main</code> function. In order to drop an array of <code>T</code>, the compiler must first know how to drop <code>T</code>. This can be fixed by specifiying in the function signature of <code>largest_list</code> that <code>T</code> must implement the drop trait. The correct function definition of <code>largest_list</code> is as follows:</p>
<pre><code class="language-rust">fn largest_list&lt;T, impl TDrop: Drop&lt;T&gt;&gt;(l1: Array&lt;T&gt;, l2: Array&lt;T&gt;) -&gt; Array&lt;T&gt; {
    if l1.len() &gt; l2.len() {
        l1
    } else {
        l2
    }
}</code></pre>
<p>The new <code>largest_list</code> function includes in its definition the requirement that whatever generic type is placed there, it must be droppable. The <code>main</code> function remains unchanged, the compiler is smart enough to deduct which concrete type is being used and if it implements the <code>Drop</code> trait.</p>
<h3 id="constraints-for-generic-types"><a class="header" href="#constraints-for-generic-types">Constraints for Generic Types</a></h3>
<p>When defining generic types, it is useful to have information about them. Knowing which traits a generic type implements allow us to use them more effectively in a functions logic at the cost of constraining the generic types that can be used with the function. We saw an example of this previously by adding the <code>TDrop</code> implementation as part of the generic arguments of <code>largest_list</code>. While <code>TDrop</code> was added to satisfy the compilers requirements, we can also add constraints to benefit our function logic.</p>
<p>Imagine that we want, given a list of elements of some generic type <code>T</code>, find the smallest element among them. Initially, we know that for an element of type <code>T</code> to be comparable, it must implement the <code>PartialOrd</code> trait. The resulting function would be:</p>
<pre><code class="language-rust">// This code does not compile!
use array:ArrayTrait;

// Given a list of T get the smallest one.
// The PartialOrd trait implements comparison operations for T
fn smallest_element&lt;T, impl TPartialOrd: PartialOrd&lt;T&gt;&gt;(list: @Array&lt;T&gt;) -&gt; T {
    // This represents the smallest element through the iteration
    // Notice that we use the desnap (*) operator
    let mut smallest = *list[0_usize];

    // The index we will use to move through the list
    let mut index = 1_usize;

    // Iterate through the whole list storing the smallest
    loop {
        if index &gt;= list.len(){
            break smallest;
        }
        if *list[index] &lt; smallest {
            smallest = *list[index];
        }
        index = index + 1;
    }
}

fn main()  {
    let mut list = ArrayTrait::new();
    list.append(5_u8);
    list.append(3_u8);
    list.append(10_u8);

    // We need to specify that we are passing a snapshot of `list` as an argument
    let s = smallest_element(@list);
    assert(s == 3_u8, 0);

}</code></pre>
<p>The <code>smallest_element</code> function uses a generic type <code>T</code> that implements the <code>PartialOrd</code> trait, takes an snapshot of an <code>Array&lt;T&gt;</code> as a parameter and returns a copy of the smallest element. Because the parameter is of type <code>@Array&lt;T&gt;</code>, we no longer need to drop it at the end of the execution and so we don't require to implement the <code>Drop</code> trait for <code>T</code> as well. Why it does not compile then?</p>
<p>When indexing on <code>list</code>, the value results in a snap of the indexed element, unless <code>PartialOrd</code> is implemented for <code>@T</code> we need to desnap the element using <code>*</code>. The <code>*</code> operation requires a copy from <code>@T</code> to<code>T</code>, which means that <code>T</code> needs to implement the <code>Copy</code> trait. After copying an element of type <code>@T</code> to <code>T</code>, there are now variables with type <code>T</code> that need to be dropped, requiring for <code>T</code> to implement the <code>Drop</code> trait as well. We must then add both <code>Drop</code> and <code>Copy</code> traits implementation for the function to be correct. After updating the<code>smallest_element</code> function the resulting code would be:</p>
<pre><code class="language-rs">fn smallest_element&lt;T, impl TPartialOrd: PartialOrd&lt;T&gt;, impl TCopy: Copy&lt;T&gt;, impl TDrop: Drop&lt;T&gt;&gt;(list: @Array&lt;T&gt;) -&gt; T {
    let mut smallest = *list[0_usize];
    let mut index = 1_usize;
    loop {
        if index &gt;= list.len(){
            break smallest;
        }
        if *list[index] &lt; smallest {
            smallest = *list[index];
        }
        index = index + 1;
    }
}
</code></pre>
<h2 id="structs"><a class="header" href="#structs">Structs</a></h2>
<p>We can also define structs to use a generic type parameter for one or more fields using the <code>&lt;&gt;</code> syntax, similar to function definitions. First we declare the name of the type parameter inside the angle brackets just after the name of the struct. Then we use the generic type in the struct definition where we would otherwise specify concrete data types. The next code example shows the definition <code>Wallet&lt;T&gt;</code> which has a <code>balance</code> field of type <code>T</code>.</p>
<pre><code class="language-rust">// This code does not compile!

#[derive(Drop)]
struct Wallet&lt;T&gt; {
    balance: T,
}


fn main() {
   let w = Wallet{ balance: 3_u128};
}</code></pre>
<p>Compiling the above code would error due to the <code>derive</code> macro not working well with generics. When using generic types is best to directly write the traits you want to use:</p>
<pre><code class="language-rust">struct Wallet&lt;T&gt; {
    balance: T,
}

impl WalletDrop&lt;T, impl TDrop : Drop&lt;T&gt;&gt; of Drop&lt;Wallet&lt;t&gt;&gt;;

fn main() {
   let w = Wallet{ balance: 3_u128};
}</code></pre>
<p>We avoid using the <code>derive</code> macro for <code>Drop</code> implementation of <code>Wallet</code> and instead define our own <code>WalletDrop</code> implementation. Notice that we must define, just like functions, an additional generic type for <code>WalletDrop</code> saying that <code>T</code> implements the <code>Drop</code> trait as well. We are basically saying that the struct <code>Wallet&lt;T&gt;</code> is droppable as long as <code>T</code> is also droppable.</p>
<p>Finally, if we want to add a field to <code>Wallet</code> representing its Cairo address and we want that field to be different than <code>T</code> but generic as well, we can simply add another generic type between the <code>&lt;&gt;</code>:</p>
<pre><code class="language-rust">struct Wallet&lt;T, U&gt; {
    balance: T,
    address: U,
}

impl WalletDrop&lt;T, impl TDrop: Drop&lt;T&gt;, U, impl UDrop: Drop&lt;U&gt;&gt; of Drop&lt;Wallet&lt;T, U&gt;&gt;;


fn main() {
   let w = Wallet{ balance: 3_u128, address: 14};
}</code></pre>
<p>We add to <code>Wallet</code> struct definiton a new generic type <code>U</code> and then assign this type to the new field member <code>address</code>.
Then we adapt the <code>WalletDrop</code> trait to work with the new generic type <code>U</code>. Notice that when initializing the struct inside <code>main</code> it automatically infers that <code>T</code> is a <code>u128</code> and <code>U</code> is a <code>felt252</code> and since they are both droppable, <code>Wallet</code> is droppable as well!</p>
<h2 id="enums-1"><a class="header" href="#enums-1">Enums</a></h2>
<p>As we did with structs, we can define enums to hold generic data types in their variants. For example the <code>Option&lt;T&gt;</code> enum provided by the Cairo core library:</p>
<pre><code class="language-rust">enum Option&lt;T&gt; {
    Some(T),
    None,
}</code></pre>
<p>The <code>Option&lt;T&gt;</code> enum is generic over a type <code>T</code> and has two variants: <code>Some</code>, which holds one value of type <code>T</code> and <code>None</code> that doesn't hold any value. By using the <code>Option&lt;T&gt;</code> enum, it is possible for us to express the abstract concept of an optional value and because the value has a generic type <code>T</code> we can use this abstraction with any type.</p>
<p>Enums can use multiple generic types as well, like definition of the <code>Result&lt;T, E&gt;</code> enum that the core library provides:</p>
<pre><code class="language-rust">enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}</code></pre>
<p>The <code>Result&lt;T, E&gt;</code> enum is has two generic types, <code>T</code> and <code>E</code>, and two variants: <code>Ok</code> which holds the value of type <code>T</code> and <code>Err</code> which holds the value of type <code>E</code>. This definition makes it convenient to use the <code>Result</code> enum anywhere we have an operation that might succeed (by returning a value of type <code>T</code>) or fail (by returning a value of type <code>E</code>).</p>
<h2 id="generic-methods"><a class="header" href="#generic-methods">Generic Methods</a></h2>
<p>We can implement methods on structs and enums, and use the generic types in their definition, too. Using our previous definition of <code>Wallet&lt;T&gt;</code> struct, we define a <code>balance</code> method for it:</p>
<pre><code class="language-rust">struct Wallet&lt;T&gt; {
    balance: T,
}

impl WalletDrop&lt;T, impl TDrop: Drop&lt;T&gt;&gt; of Drop&lt;Wallet&lt;T, U&gt;&gt;;

trait WalletTrait&lt;T&gt; {
    fn balance(self: @Wallet&lt;T&gt;) -&gt; @T;
}

impl WalletImpl&lt;T&gt; of WalletTrait&lt;T&gt; {
    fn balance(self: @Wallet&lt;T&gt;) -&gt; @T{
        return self.balance;
    }
}

fn main() {
    let w = Wallet {balance: 50};
    assert(w.balance() == 50, 0);
}</code></pre>
<p>We first define <code>WalletTrait&lt;T&gt;</code> trait using a generic type <code>T</code> which defines a method that returns a snapshot of the field <code>address</code> from <code>Wallet</code>. Then we give an implementation for the trait in <code>WalletImpl&lt;T&gt;</code>. Note that you need to include a generic type in both definitions of the trait and the implementation.</p>
<p>We can also specify constraints on generic types when defining methods on the type. We could, for example, implement methods only for <code>Wallet&lt;u128&gt;</code> instances rather than <code>Wallet&lt;T&gt;</code>. In the code example we define an implementation for wallets which have a concrete type of <code>u128</code> for the <code>balance</code> field.</p>
<pre><code class="language-rust">trait WalletReceiveTrait {
    fn receive(ref self: Wallet&lt;u128&gt;, value: u128);
}

impl WalletReceiveImpl of WalletReceiveTrait {
    fn receive(ref self: Wallet&lt;u128&gt;, value: u128) {
        self.balance += value;
    }
}

fn main() {
    let mut w = Wallet {balance: 50_u128};
    assert(w.balance() == 50_u128, 0);

    w.receive(100_u128)
    assert(w.balance() == 150_u128, 0);
}</code></pre>
<p>The new method <code>receive</code> increments the size of the balance of any instance of a <code>Wallet&lt;u128&gt;</code>. Notice that we changed the <code>main</code> function making <code>w</code> a mutable variable in order for it to be able to update its balance. If we were to change the initialization of <code>w</code> by changing the type of <code>balance</code> the previous code wouldn't compile.</p>
<p>Cairo allow us to define generic methods inside generic traits as well. Using the past implementation from <code>Wallet&lt;U, V&gt;</code> we are going to define a trait that picks two wallets of different generic types and create a new one with a generic type of each. First, lets rewrite the struct definiton:</p>
<pre><code class="language-rust">struct Wallet&lt;T, U&gt; {
    balance: T,
    address: U,
}</code></pre>
<p>Next we are going to naively define the mixup trait and implementation:</p>
<pre><code class="language-rust">// This does not compile!
trait WalletMixTrait&lt;T1, U1&gt; {
    fn mixup&lt;T2, U2&gt;(self: Wallet&lt;T1, U1&gt;, other: Wallet&lt;T2, U2&gt;) -&gt; Wallet&lt;T1, U2&gt;;
}

impl WalletMixImpl&lt;T1,  U1&gt; of WalletMixTrait&lt;T1, U1&gt; {
    fn mixup&lt;T2, U2&gt;(self: Wallet&lt;T1, U1&gt;, other: Wallet&lt;T2, U2&gt;) -&gt; Wallet&lt;T1, U2&gt; {
        Wallet {balance: self.balance, address: other.address}
    }
}</code></pre>
<p>We are creating a trait <code>WalletMixTrait&lt;T1, U1&gt;</code> with the <code>mixup&lt;T2, U2&gt;</code> methods which given an instance of <code>Wallet&lt;T1, U1&gt;</code> and <code>Wallet&lt;T2, U2&gt;</code> creates a new <code>Wallet&lt;T1, U2&gt;</code>. As <code>mixup</code> signature specify, both <code>self</code> and <code>other</code> are getting dropped at the end of the function, which is the reason for this code not to compile. If you have been following from the start until now you would know that we must add a requirement for all the generic types specifiying that they will implement the <code>Drop</code> trait in order for the compiler to know how to drop instances of <code>Wallet&lt;T, U&gt;</code>. The updated implementation is as follow:</p>
<pre><code class="language-rust">trait WalletMixTrait&lt;T1, U1&gt; {
    fn mixup&lt;T2, impl T2Drop: Drop&lt;T2&gt;, U2, impl U2Drop: Drop&lt;U2&gt;&gt;(self: Wallet&lt;T1, U1&gt;, other: Wallet&lt;T2, U2&gt;) -&gt; Wallet&lt;T1, U2&gt;;
}

impl WalletMixImpl&lt;T1, impl T1Drop: Drop&lt;T1&gt;,  U1, impl U1Drop: Drop&lt;U1&gt;&gt; of WalletMixTrait&lt;T1, U1&gt; {
    fn mixup&lt;T2, impl T2Drop: Drop&lt;T2&gt;, U2, impl U2Drop: Drop&lt;U2&gt;&gt;(self: Wallet&lt;T1, U1&gt;, other: Wallet&lt;T2, U2&gt;) -&gt; Wallet&lt;T1, U2&gt; {
        Wallet {balance: self.balance, address: other.address}
    }
}</code></pre>
<p>We add the requirements for <code>T1</code> and <code>U1</code> to be droppable on <code>WalletMixImpl</code> declaration. Then we do the same for <code>T2</code> and <code>U2</code>, this time as part of <code>mixup</code> signature. We can now try the <code>mixup</code> function:</p>
<pre><code class="language-rs">fn main() {
   let w1 = Wallet{ balance: true, address: 10_u128};
   let w2 = Wallet{ balance: 32, address: 100_u8};

   let w3 = w1.mixup(w2);

   assert(w3.balance == true, 0);
   assert(w3.address == 100_u8, 0);
}
</code></pre>
<p>We first create two instances: one of <code>Wallet&lt;bool, u128&gt;</code> and the other of <code>Wallet&lt;felt252, u8&gt;</code>. Then, we call <code>mixup</code> and create a new <code>Wallet&lt;bool, u8&gt;</code> instance.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="traits-in-cairo"><a class="header" href="#traits-in-cairo">Traits in Cairo</a></h1>
<p>Traits specify functionality blueprints that can be implemented. The blueprint specification includes a set of function signatures containing type annotations for the parameters and return value. This sets a standard to implement the specific functionality.</p>
<h2 id="defining-a-trait"><a class="header" href="#defining-a-trait">Defining a Trait</a></h2>
<p>To define a trait, you use the keyword <code>trait</code> followed by the name of the trait in <code>PascalCase</code> then the function signatures in a pair of curly braces.</p>
<p>For example, let's say that we have multiple structs representing shapes. We want our application to be able to perform geometry operations on these shapes, So we define a trait <code>ShapeGeometry</code> that contains a blueprint to implement geometry operations on a shape like this,</p>
<pre><code class="language-rust">trait ShapeGeometry {
    fn boundary( self: Rectangle ) -&gt; u64;
    fn area( self: Rectangle ) -&gt; u64;
}</code></pre>
<p>Here our trait <code>ShapeGeometry</code> declares signatures for two methods <code>boundary</code> and <code>area</code>. When implemented, both these functions should return a <code>u64</code> and accept parameters as specified by the trait.</p>
<h2 id="implementing-a-trait"><a class="header" href="#implementing-a-trait">Implementing a Trait</a></h2>
<p>A trait can be implemented using <code>impl</code> keyword with the name of your implementation followed by <code>of</code> then the name of trait being implemented. Here's an example implementing <code>ShapeGeometry</code> trait.</p>
<pre><code class="language-rust">impl RectangleGeometry of ShapeGeometry {
	fn boundary( self: Rectangle ) -&gt; u64 {
        2_u64 * (self.height + self.width)
    }
	fn area( self: Rectangle ) -&gt; u64 {
		self.height * self.width
	}
}</code></pre>
<p>In the code above, <code>RectangleGeometry</code> implements the trait <code>ShapeGeometry</code> defining what the methods <code>boundary</code> and <code>area</code> should do. Note the the function parameters and return value types are identical to the trait specification.</p>
<h2 id="parameter-self"><a class="header" href="#parameter-self">Parameter <code>self</code></a></h2>
<p>In the example above, <code>self</code> is a special parameter. When a parameter with name <code>self</code> is used, the implemented functions are also <a href="ch04-03-method-syntax.html#defining-methods">attached to the instances of the type as methods</a>. Here's an illustration,</p>
<p>When the <code>ShapeGeometry</code> trait is implemented, the function <code>area</code> from the <code>ShapeGeometry</code> trait can be called in two ways:</p>
<pre><code class="language-rust">let rect = Rectangle { ... }; // Rectangle instantiation

// First way, as a method on the struct instance
let area1 = rect.area();
// Second way, from the implementation
let area2 = RectangleGeometry::area(rect);
// `area1` has same value as `area2`
area1.print();
area2.print();</code></pre>
<p>And the implementation of the <code>area</code> method will be accessed via the <code>self</code> parameter.</p>
<h2 id="traits-with-generic-types"><a class="header" href="#traits-with-generic-types">Traits with generic types</a></h2>
<p>Usually we want to write a trait when we want multiple types to implement a functionality in a standard way. However, in the example above the signatures are static and cannot be used for multiple types. To do this, we use generic types when defining traits.</p>
<p>In the example below, we use generic type <code>T</code> and our method signatures can use this alias which can be provided during implementation.</p>
<pre><code class="language-rust">use debug::PrintTrait;

// Here T is an alias type which will be provided buring implementation
trait ShapeGeometry&lt;T&gt; {
    fn boundary( self: T ) -&gt; u64;
    fn area( self: T ) -&gt; u64;
}

// Implementation RectangleGeometry passes in &lt;Rectangle&gt;
// to implement the trait for that type
impl RectangleGeometry of ShapeGeometry::&lt;Rectangle&gt; {
    fn boundary( self: Rectangle ) -&gt; u64 {
        2_u64 * (self.height + self.width)
    }
    fn area( self: Rectangle ) -&gt; u64 {
        self.height * self.width
    }
}

// We might have another struct Circle
// which can use the same trait spec
impl CircleGeometry of ShapeGeometry::&lt;Circle&gt; {
    fn boundary( self: Circle ) -&gt; u64 {
        (2_u64 * 314_u64 * self.radius) / 100_u64
    }
    fn area( self: Circle ) -&gt; u64 {
       (314_u64 * self.radius * self.radius) / 100_u64
    }
}

fn main() {
    let rect = Rectangle { height: 5_u128, width: 7_u128 };
    rect.area().print(); // 35
    rect.boundary().print(); // 24

    let circ = Circle { radius: 5_u128 };
    circ.area().print(); // 78
    circ.boundary().print(); // 31
}</code></pre>
<h2 id="managing-and-using-external-trait-implementations"><a class="header" href="#managing-and-using-external-trait-implementations">Managing and using external trait implementations</a></h2>
<p>To use traits methods, you need to make sure the correct traits/implementation(s) are imported. In the code above we imported <code>PrintTrait</code> from <code>debug</code> with <code>use debug::PrintTrait;</code> to use <code>print()</code> methods.</p>
<p>In some cases you might need to import not only the trait but also the implementation if they are declared in separate modules.
If <code>CircleGeometry</code> was in a separate module/file <code>circle</code> then to use <code>boundary</code> on <code>circ: Circle</code>, we'd need to import <code>CircleGeometry</code> in addition to <code>ShapeGeometry</code>.</p>
<p>If the code was organised into modules like this,</p>
<pre><code class="language-rust">use debug::PrintTrait;

// struct Circle { ... } and struct Rectangle { ... }

mod geometry {
    use super::Rectangle;
    trait ShapeGeometry&lt;T&gt; {
        // ...
    }

    impl RectangleGeometry of ShapeGeometry::&lt;Rectangle&gt; {
        // ...
    }
}

// Could be in a different file
mod circle {
    use super::geometry::ShapeGeometry;
    use super::Circle;
    impl CircleGeometry of ShapeGeometry::&lt;Circle&gt; {
        // ...
    }
}

fn main() {
    let rect = Rectangle { height: 5_u64, width: 7_u64 };
    let circ = Circle { radius: 5_u64 };
    // Fails with this error
    // Method `area` not found on... Did you import the correct trait and impl?
    rect.area().print();
    circ.area().print();
}</code></pre>
<p>To make it work, in addition to,</p>
<pre><code class="language-rust">use geometry::ShapeGeometry;</code></pre>
<p>you might also need to use <code>CircleGeometry</code>,</p>
<pre><code class="language-rust">use circle::CircleGeometry</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="testing-cairo-programs"><a class="header" href="#testing-cairo-programs">Testing Cairo Programs</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-to-write-tests"><a class="header" href="#how-to-write-tests">How To Write Tests</a></h1>
<h2 id="the-anatomy-of-a-test-function"><a class="header" href="#the-anatomy-of-a-test-function">The Anatomy of a Test Function</a></h2>
<p>Tests are Cairo functions that verify that the non-test code is functioning in the expected manner. The bodies of test functions typically perform these three actions:</p>
<ul>
<li>Set up any needed data or state.</li>
<li>Run the code you want to test.</li>
<li>Assert the results are what you expect.</li>
</ul>
<p>Let’s look at the features Cairo provides specifically for writing tests that take these actions, which include the <code>test</code> attribute, the <code>assert</code> function, and and the <code>should_panic</code> attribute.</p>
<h3 id="the-anatomy-of-a-test-function-1"><a class="header" href="#the-anatomy-of-a-test-function-1">The Anatomy of a Test Function</a></h3>
<p>At its simplest, a test in Cairo is a function that’s annotated with the <code>test</code> attribute. Attributes are metadata about pieces of Cairo code; one example is the derive attribute we used with structs in Chapter 4. To change a function into a test function, add <code>#[test]</code> on the line before <code>fn</code>. When you run your tests with the <code>cairo-test</code> command, Cairo builds a test runner binary that runs the annotated functions and reports on whether each test function passes or fails.</p>
<p>Let's create a new project called <code>adder</code> that will add two numbers using Scarb with the command <code>scarb new adder</code>:</p>
<pre><code class="language-shell">adder
├── cairo_project.toml
├── Scarb.toml
└── src
    └── lib.cairo
</code></pre>
<!-- TODO: remove when Scarb test work -->
<blockquote>
<p>Note: You will notice here a <code>cairo_project.toml</code> file.
This is the configuration file for &quot;vanilla&quot; Cairo projects (i.e. not managed by Scarb),
which is required to run the <code>cairo-test .</code> command to run the code of the crate.
It is required until Scarb implements this feature. The content of the file is:</p>
<pre><code class="language-toml">[crate_roots]
adder = &quot;src&quot;
</code></pre>
<p>and indicates that the crate named &quot;adder&quot; is located in the <code>src</code> directory.</p>
</blockquote>
<p>In <em>lib.cairo</em>, let's add a firt test, as shown in Listing 9-1.</p>
<p><span class="filename">Filename: lib.cairo</span></p>
<pre><code class="language-rust">#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        let result = 2 + 2;
        assert(result == 4, 'result is not 4');
    }
}</code></pre>
<p>Listing 9-1: A test module and function</p>
<p>For now, let’s ignore the top two lines and focus on the function. Note the <code>#[test]</code> annotation: this attribute indicates this is a test function, so the test runner knows to treat this function as a test. We might also have non-test functions in the tests module to help set up common scenarios or perform common operations, so we always need to indicate which functions are tests.</p>
<p>The example function body uses the <code>assert</code> function, which contains the result of adding 2 and 2, equals 4. This assertion serves as an example of the format for a typical test. Let’s run it to see that this test passes.</p>
<p>The <code>cairo-test .</code> command runs all tests in our project, as shown in Listing 9-2.</p>
<pre><code class="language-shell">$ cairo-test .
running 1 tests
test adder::lib::tests::it_works ... ok
test result: ok. 1 passed; 0 failed; 0 ignored; 0 filtered out;
</code></pre>
<p>Listing 9-2: The output from running a test</p>
<p><code>cairo-test</code> compiled and ran the test. We see the line <code>running 1 tests</code>. The next line shows the name of the generated test function, called <code>it_works</code>, and that the result of running that test is <code>ok</code>. The overall summary <code>test result: ok.</code> means that all the tests passed, and the portion that reads <code>1 passed; 0 failed</code> totals the number of tests that passed or failed.</p>
<p>It’s possible to mark a test as ignored so it doesn’t run in a particular instance; we’ll cover that in the <a href="ch09-01-how-to-write-tests.html#ignoring-some-tests-unless-specifically-requested">Ignoring Some Tests Unless Specifically Requested</a> section later in this chapter. Because we haven’t done that here, the summary shows <code>0 ignored</code>. We can also pass an argument to the <code>cairo-test</code> command to run only a test whose name matches a string; this is called filtering and we’ll cover that in the <a href="ch09-01-how-to-write-tests.html#running-single-tests">Running Single Tests</a> section. We also haven’t filtered the tests being run, so the end of the summary shows <code>0 filtered out</code>.</p>
<p>Let’s start to customize the test to our own needs. First change the name of the <code>it_works</code> function to a different name, such as <code>exploration</code>, like so:</p>
<p><span class="filename">Filename: lib.cairo</span></p>
<pre><code class="language-rust">#[cfg(test)]
mod tests {
    #[test]
    fn exploration() {
        let result = 2 + 2;
        assert(result == 4, 'result is not 4');
    }
}</code></pre>
<p>Then run <code>cairo-test  -- --path src</code> again. The output now shows <code>exploration</code> instead of <code>it_works</code>:</p>
<pre><code class="language-shell">$ cairo-test .
running 1 tests
test adder::lib::tests::exploration ... ok
test result: ok. 1 passed; 0 failed; 0 ignored; 0 filtered out;
</code></pre>
<p>Now we’ll add another test, but this time we’ll make a test that fails! Tests fail when something in the test function panics. Each test is run in a new thread, and when the main thread sees that a test thread has died, the test is marked as failed. Enter the new test as a function named <code>another</code>, so your <em>src/lib.cairo</em> file looks like Listing 9-3.</p>
<pre><code class="language-rust">#[test]
fn another() {
    let result = 2 + 2;
    assert(result == 6, 'Make this test fail');
}</code></pre>
<p>Listing 9-3: Adding a second test that will fail</p>
<pre><code class="language-shell">$ cairo-test .
running 2 tests
test adder::lib::tests::exploration ... ok
test adder::lib::tests::another ... fail
failures:
    adder::lib::tests::another - panicked with [593979512822486838786147395675889716 ('Make this test fail'), ].
Error: test result: FAILED. 1 passed; 1 failed; 0 ignored
</code></pre>
<p>Listing 9-4: Test results when one test passes and one test fails</p>
<p>Instead of <code>ok</code>, the line <code>adder::lib::tests::another</code> shows <code>fail</code>. A new section appear between the individual results and the summary. It displays the detailed reason for each test failure. In this case, we get the details that <code>another</code> failed because it panicked with <code>[593979512822486838786147395675889716 ('Make this test fail'), ]</code> in the <em>src/lib.cairo</em> file.</p>
<p>The summary line displays at the end: overall, our test result is <code>FAILED</code>. We had one test pass and one test fail.</p>
<p>Now that you’ve seen what the test results look like in different scenarios, let’s look at some functions that are useful in tests.</p>
<h2 id="checking-results-with-the-assert-function"><a class="header" href="#checking-results-with-the-assert-function">Checking Results with the assert function</a></h2>
<p>The <code>assert</code> function, provided by Cairo, is useful when you want to ensure that some condition in a test evaluates to <code>true</code>. We give the <code>assert</code> function a first argument that evaluates to a Boolean. If the value is <code>true</code>, nothing happens and the test passes. If the value is <code>false</code>, the assert function calls <code>panic()</code> to cause the test to fail with a message we defined as the second argument of the <code>assert</code> function. Using the <code>assert</code> function helps us check that our code is functioning in the way we intend.</p>
<p>In <a href="ch04-03-method-syntax.html#multiple-impl-blocks">Chapter 4, Listing 5-15</a>, we used a <code>Rectangle</code> struct and a <code>can_hold</code> method, which are repeated here in Listing 9-5. Let’s put this code in the <em>src/lib.cairo</em> file, then write some tests for it using the <code>assert</code> function.</p>
<p><span class="filename">Filename: lib.cairo</span></p>
<pre><code class="language-rust">trait RectangleTrait {
    fn area(self: @Rectangle) -&gt; u64;
    fn can_hold(self: @Rectangle, other: @Rectangle) -&gt; bool;
}

impl RectangleImpl of RectangleTrait {
    fn area(self: @Rectangle) -&gt; u64 {
        *self.width * *self.height
    }
    fn can_hold(self: @Rectangle, other: @Rectangle) -&gt; bool {
        *self.width &gt; *other.width &amp; *self.height &gt; *other.height
    }
}</code></pre>
<p>Listing 9-5: Using the <code>Rectangle</code> struct and its <code>can_hold</code> method from Chapter 5</p>
<p>The <code>can_hold</code> method returns a <code>Boolean</code>, which means it’s a perfect use case for the assert function. In Listing 9-6, we write a test that exercises the <code>can_hold</code> method by creating a <code>Rectangle</code> instance that has a width of <code>8_u64</code> and a height of <code>7_u64</code> and asserting that it can hold another <code>Rectangle</code> instance that has a width of <code>5_u64</code> and a height of <code>1_u64</code>.</p>
<p><span class="filename">Filename: lib.cairo</span></p>
<pre><code class="language-rust">#[cfg(test)]
mod tests {
    use super::Rectangle;
    use super::RectangleTrait;

    #[test]
    fn larger_can_hold_smaller() {
        let larger = Rectangle {
            height: 7_u64,
            width: 8_u64,
        };
        let smaller = Rectangle {
            height: 1_u64,
            width: 5_u64,
        };

        assert(larger.can_hold(@smaller), 'rectangle cannot hold');
    }
}</code></pre>
<p>Listing 9-6: A test for <code>can_hold</code> that checks whether a larger rectangle can indeed hold a smaller rectangle</p>
<p>Note that we’ve added two new lines inside the tests module: <code>use super::Rectangle;</code> and <code>use super::RectangleTrait;</code>. The tests module is a regular module that follows the usual visibility rules. Because the tests module is an inner module, we need to bring the code under test in the outer module into the scope of the inner module.</p>
<p>We’ve named our test <code>larger_can_hold_smaller</code>, and we’ve created the two <code>Rectangle</code> instances that we need. Then we called the assert function and passed it the result of calling <code>larger.can_hold(@smaller)</code>. This expression is supposed to return <code>true</code>, so our test should pass. Let’s find out!</p>
<pre><code class="language-shell">$ cairo-test .
running 1 tests
test adder::lib::tests::larger_can_hold_smaller ... ok
test result: ok. 1 passed; 0 failed; 0 ignored; 0 filtered out;
</code></pre>
<p>It does pass! Let’s add another test, this time asserting that a smaller rectangle cannot hold a larger rectangle:</p>
<p><span class="filename">Filename: lib.cairo</span></p>
<pre><code class="language-rust">#[cfg(test)]
mod tests {
    use super::Rectangle;
    use super::RectangleTrait;

    #[test]
    fn larger_can_hold_smaller() {
        // --snip--
    }

    #[test]
    fn smaller_cannot_hold_larger() {
        let larger = Rectangle {
            height: 7_u64,
            width: 8_u64,
        };
        let smaller = Rectangle {
            height: 1_u64,
            width: 5_u64,
        };

        assert(!smaller.can_hold(@larger), 'rectangle cannot hold');
    }
}</code></pre>
<p>Because the correct result of the <code>can_hold</code> function in this case is <code>false</code>, we need to negate that result before we pass it to the assert function. As a result, our test will pass if <code>can_hold</code> returns false:</p>
<pre><code class="language-shell">$ cairo-test .
    running 2 tests
    test adder::lib::tests::smaller_cannot_hold_larger ... ok
    test adder::lib::tests::larger_can_hold_smaller ... ok
    test result: ok. 2 passed; 0 failed; 0 ignored; 0 filtered out;
</code></pre>
<p>Two tests that pass! Now let’s see what happens to our test results when we introduce a bug in our code. We’ll change the implementation of the <code>can_hold</code> method by replacing the greater-than sign with a less-than sign when it compares the widths:</p>
<pre><code class="language-rust">// --snip--
impl RectangleImpl of RectangleTrait {
    fn can_hold(self: @Rectangle, other: @Rectangle) -&gt; bool {
        *self.width &lt; *other.width &amp; *self.height &gt; *other.height
    }
}</code></pre>
<p>Running the tests now produces the following:</p>
<pre><code class="language-shell">$ cairo-test .
running 2 tests
test adder::lib::tests::smaller_cannot_hold_larger ... ok
test adder::lib::tests::larger_can_hold_smaller ... fail
failures:
   adder::lib::tests::larger_can_hold_smaller - panicked with [167190012635530104759003347567405866263038433127524 ('rectangle cannot hold'), ].

Error: test result: FAILED. 1 passed; 1 failed; 0 ignored
</code></pre>
<p>Our tests caught the bug! Because <code>larger.width</code> is <code>8_u64</code> and <code>smaller.width</code> is <code>5_u64</code>, the comparison of the widths in <code>can_hold</code> now returns <code>false</code>: <code>8_u6</code>4 is not less than <code>5_u64</code>.</p>
<h2 id="checking-for-panics-with-should_panic"><a class="header" href="#checking-for-panics-with-should_panic">Checking for Panics with <code>should_panic</code></a></h2>
<p>In addition to checking return values, it’s important to check that our code handles error conditions as we expect. For example, consider the Guess type in Listing 9-8. Other code that uses <code>Guess</code> depends on the guarantee that <code>Guess</code> instances will contain only values between <code>1_u64</code> and <code>100_u64</code>. We can write a test that ensures that attempting to create a <code>Guess</code> instance with a value outside that range panics.</p>
<p>We do this by adding the attribute <code>should_panic</code> to our test function. The test passes if the code inside the function panics; the test fails if the code inside the function doesn’t panic.</p>
<p>Listing 9-8 shows a test that checks that the error conditions of <code>GuessTrait::new</code> happen when we expect them to.</p>
<p><span class="filename">Filename: lib.cairo</span></p>
<pre><code class="language-rust">use array::ArrayTrait;

#[derive(Copy, Drop)]
struct Guess {
    value: u64,
}

trait GuessTrait {
    fn new(value: u64) -&gt; Guess;
}

impl GuessImpl of GuessTrait {
    fn new(value: u64) -&gt; Guess {
        if value &lt; 1_u64 {
            let mut data = ArrayTrait::new();
            data.append('Guess must be higher than 1');
            panic(data);
        } else if value &gt; 100_u64 {
            let mut data = ArrayTrait::new();
            data.append('Guess must be smaller than 100');
            panic(data);
        }

        Guess { value, }
    }
}

#[cfg(test)]
mod tests {
    use super::Guess;
    use super::GuessTrait;

    #[test]
    #[should_panic]
    fn greater_than_100() {
        GuessTrait::new(200_u64);
    }
}</code></pre>
<p>Listing 9-8: Testing that a condition will cause a panic</p>
<p>We place the <code>#[should_panic]</code> attribute after the <code>#[test]</code> attribute and before the test function it applies to. Let’s look at the result when this test passes:</p>
<pre><code class="language-shell">$ cairo-test .
running 1 tests
test adder::lib::tests::greater_than_100 ... ok
test result: ok. 1 passed; 0 failed; 0 ignored; 0 filtered out;
</code></pre>
<p>Looks good! Now let’s introduce a bug in our code by removing the condition that the new function will panic if the value is greater than <code>100_u64</code>:</p>
<pre><code class="language-rust">// --snip--
impl GuessImpl of GuessTrait {
    fn new(value: u64) -&gt; Guess {
        if value &lt; 1_u64 {
            let mut data = ArrayTrait::new();
            data.append('Guess must be between 1 and 100');
            panic(data);
        }

        Guess { value, }
    }
}</code></pre>
<p>When we run the test in Listing 9-8, it will fail:</p>
<pre><code class="language-shell">$ cairo-test .
running 1 tests
test adder::lib::tests::greater_than_100 ... fail
failures:
   adder::lib::tests::greater_than_100 - expected panic but finished successfully.
Error: test result: FAILED. 0 passed; 1 failed; 0 ignored
</code></pre>
<p>We don’t get a very helpful message in this case, but when we look at the test function, we see that it’s annotated with <code>#[should_panic]</code>. The failure we got means that the code in the test function did not cause a panic.</p>
<p>Tests that use <code>should_panic</code> can be imprecise. A <code>should_panic</code> test would pass even if the test panics for a different reason from the one we were expecting. To make <code>should_panic</code> tests more precise, we can add an optional expected parameter to the <code>should_panic</code> attribute. The test harness will make sure that the failure message contains the provided text. For example, consider the modified code for <code>Guess</code> in Listing 9-9 where the new function panics with different messages depending on whether the value is too small or too large.</p>
<p><span class="filename">Filename: lib.cairo</span></p>
<pre><code class="language-rust">// --snip--
impl GuessImpl of GuessTrait {
    fn new(value: u64) -&gt; Guess {
        if value &lt; 1_u64 {
            let mut data = ArrayTrait::new();
            data.append('Guess must be greater than 1');
            panic(data);
        } else if value &gt; 100_u64 {
            let mut data = ArrayTrait::new();
            data.append('Guess must be lower than 100');
            panic(data);
        }

        Guess { value, }
    }
}

#[cfg(test)]
mod tests {
    use super::Guess;
    use super::GuessTrait;

    #[test]
    #[should_panic(expected: ('Guess must be lower than 100', ))]
    fn greater_than_100() {
        GuessTrait::new(200_u64);
    }
}</code></pre>
<p>Listing 9-9: Testing for a panic with a panic message containing the error message string</p>
<p>This test will pass because the value we put in the <code>should_panic</code> attribute’s expected parameter is the string of the message that the <code>Guess::new</code> function panics with. We need to specify the entire panic message that we expect.</p>
<p>To see what happens when a <code>should_panic</code> test with an expected message fails, let’s again introduce a bug into our code by swapping the bodies of the if <code>value &lt; 1_u64</code> and the else if <code>value &gt; 100_u64</code> blocks:</p>
<pre><code class="language-rust">if value &lt; 1_u64 {
    let mut data = ArrayTrait::new();
    data.append('Guess must be lower than 100');
    panic(data);
} else if value &gt; 100_u64 {
    let mut data = ArrayTrait::new();
    data.append('Guess must be greater than 1');
    panic(data);
}</code></pre>
<p>This time when we run the <code>should_panic</code> test, it will fail:</p>
<pre><code class="language-shell">$ cairo-test .
running 1 tests
test adder::lib::tests::greater_than_100 ... fail
failures:
   adder::lib::tests::greater_than_100 - panicked with [7525466742201272999442800965907272684056773373474020086884212809777 ('Guess must be greater than 1'), ].

Error: test result: FAILED. 0 passed; 1 failed; 0 ignored
</code></pre>
<p>The failure message indicates that this test did indeed panic as we expected, but the panic message did not include the expected string. The panic message that we did get in this case was <code>Guess must be greater than 1</code>. Now we can start figuring out where our bug is!</p>
<h2 id="running-single-tests"><a class="header" href="#running-single-tests">Running Single Tests</a></h2>
<p>Sometimes, running a full test suite can take a long time. If you’re working on code in a particular area, you might want to run only the tests pertaining to that code. You can choose which tests to run by passing <code>cairo-test</code> the name of the test you want to run as an argument.</p>
<p>To demonstrate how to run a single test, we’ll first create two tests functions, as shown in Listing 9-10, and choose which ones to run.</p>
<p><span class="filename">Filename: src/lib.cairo</span></p>
<pre><code class="language-rust">#[cfg(test)]
mod tests {
    #[test]
    fn add_two_and_two() {
        let result = 2 + 2;
        assert(result == 4, 'result is not 4');
    }

    #[test]
    fn add_three_and_two() {
        let result = 3 + 2;
        assert(result == 5, 'result is not 5');
    }
}</code></pre>
<p>Listing 9-10: Two tests with two different names</p>
<p>We can pass the name of any test function to <code>cairo-test</code> to run only that test using the <code>-f</code> flag:</p>
<pre><code class="language-shell">$ cairo-test . -f add_two_and_two
running 1 tests
test adder::lib::tests::add_two_and_two ... ok
test result: ok. 1 passed; 0 failed; 0 ignored; 1 filtered out;
</code></pre>
<p>Only the test with the name <code>add_two_and_two</code> ran; the other test didn’t match that name. The test output lets us know we had one more test that didn’t run by displaying 1 filtered out at the end.</p>
<p>We can also specify part of a test name, and any test whose name contains that value will be run.</p>
<h2 id="ignoring-some-tests-unless-specifically-requested"><a class="header" href="#ignoring-some-tests-unless-specifically-requested">Ignoring Some Tests Unless Specifically Requested</a></h2>
<p>Sometimes a few specific tests can be very time-consuming to execute, so you might want to exclude them during most runs of <code>cairo-test</code>. Rather than listing as arguments all tests you do want to run, you can instead annotate the time-consuming tests using the <code>ignore</code> attribute to exclude them, as shown here:</p>
<p><span class="filename">Filename: src/lib.cairo</span></p>
<pre><code class="language-rust">#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        let result = 2 + 2;
        assert(result == 4, 'result is not 4');
    }

    #[test]
    #[ignore]
    fn expensive_test() {
        // code that takes an hour to run
    }
}</code></pre>
<p>After <code>#[test]</code> we add the <code>#[ignore]</code> line to the test we want to exclude. Now when we run our tests, it_works runs, but expensive_test doesn’t:</p>
<pre><code class="language-shell">$ cairo-test .
running 2 tests
test adder::lib::tests::expensive_test ... ignored
test adder::lib::tests::it_works ... ok
test result: ok. 1 passed; 0 failed; 1 ignored; 0 filtered out;
</code></pre>
<p>The <code>expensive_test</code> function is listed as ignored.</p>
<p>When you’re at a point where it makes sense to check the results of the ignored tests and you have time to wait for the results, you can run <code>cairo-test -- --include-ignored</code> to run all tests whether they’re ignored or not.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="testing-organization"><a class="header" href="#testing-organization">Testing Organization</a></h1>
<p>We'll think about tests in terms of two main categories: unit tests and integration tests. Unit tests are small and more focused, testing one module in isolation at a time, and can test private functions. Integration tests use your code in the same way any other external code would, using only the public interface and potentially exercising multiple modules per test.</p>
<p>Writing both kinds of tests is important to ensure that the pieces of your library are doing what you expect them to, separately and together.</p>
<h2 id="unit-tests"><a class="header" href="#unit-tests">Unit Tests</a></h2>
<p>The purpose of unit tests is to test each unit of code in isolation from the rest of the code to quickly pinpoint where code is and isn’t working as expected. You’ll put unit tests in the <code>src</code> directory in each file with the code that they’re testing.</p>
<p>The convention is to create a module named tests in each file to contain the test functions and to annotate the module with <code>cfg(test)</code>.</p>
<h3 id="the-tests-module-and-cfgtest"><a class="header" href="#the-tests-module-and-cfgtest">The Tests Module and <code>#[cfg(test)]</code></a></h3>
<p>The <code>#[cfg(test)]</code> annotation on the tests module tells Cairo to compile and run the test code only when you run <code>cairo-test</code>, not when you run <code>cairo-run</code>. This saves compile time when you only want to build the library and saves space in the resulting compiled artifact because the tests are not included. You’ll see that because integration tests go in a different directory, they don’t need the <code>#[cfg(test)]</code> annotation. However, because unit tests go in the same files as the code, you’ll use <code>#[cfg(test)]</code> to specify that they shouldn’t be included in the compiled result.</p>
<p>Recall that when we created the new <code>adder</code> project in the first section of this chapter, we wrote this first test:</p>
<p><span class="filename">Filename: lib.cairo</span></p>
<pre><code class="language-rust">#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        let result = 2 + 2;
        assert(result == 4, 'result is not 4');
    }
}</code></pre>
<p>The attribute <code>cfg</code> stands for configuration and tells Cairo that the following item should only be included given a certain configuration option. In this case, the configuration option is <code>test</code>, which is provided by Cairo for compiling and running tests. By using the <code>cfg</code> attribute, Cairo compiles our test code only if we actively run the tests with <code>cairo-test</code>. This includes any helper functions that might be within this module, in addition to the functions annotated with <code>#[test]</code>.</p>
<h2 id="integration-tests"><a class="header" href="#integration-tests">Integration Tests</a></h2>
<p>Integration tests use your library in the same way any other code would. Their purpose is to test whether many parts of your library work together correctly. Units of code that work correctly on their own could have problems when integrated, so test coverage of the integrated code is important as well. To create integration tests, you first need a <code>tests</code> directory.</p>
<h3 id="the-tests-directory"><a class="header" href="#the-tests-directory">The <code>tests</code> Directory</a></h3>
<pre><code class="language-shell">adder
├── cairo_project.toml
├── src
    ├── lib.cairo
│   └── main.cairo
└── tests
    ├── lib.cairo
    └── integration_test.cairo
</code></pre>
<!-- TODO: remove when Scarb test work -->
<blockquote>
<p>To successfully run your tests with <code>cairo-test</code> you will need to update your <code>cairo_project.toml</code> file to add the declaration of your <code>tests</code> crate.</p>
<pre><code class="language-rust">[crate_roots]
adder = &quot;src&quot;
tests = &quot;tests&quot;</code></pre>
</blockquote>
<p>Each test file is compiled as its own separate crate, that's why whenever you add a new test file you must add it to your <em>tests/lib.cairo</em>.</p>
<p><span class="filename">Filename: tests/lib.cairo</span></p>
<pre><code class="language-rust">#[cfg(tests)]
mod integration_tests</code></pre>
<p>Enter the code in Listing 11-13 into the <em>tests/integration_test.cairo</em> file:</p>
<p><span class="filename">Filename: tests/integration_test.cairo</span></p>
<pre><code class="language-rust">use adder::main;

#[test]
fn internal() {
    assert(main::internal_adder(2_u32, 2_u32) == 4_u32, 'internal_adder failed');
}</code></pre>
<p>Each file in the tests directory is a separate crate, so we need to bring our library into each test crate’s scope. For that reason we add <code>use adder::main</code> at the top of the code, which we didn’t need in the unit tests.</p>
<pre><code class="language-shell">$ cairo-test -- --path tests/
running 1 tests
test tests::tests_integration::it_adds_two ... ok
test result: ok. 1 passed; 0 failed; 0 ignored; 0 filtered out;
</code></pre>
<p>The result of the tests is the same as what we've been seeing: one line for each test.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="apéndice"><a class="header" href="#apéndice">Apéndice:</a></h1>
<p>Las siguientes secciones contienen material de referencia que puede resultarle útil en su viaje a Cairo.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="apéndice-a---herramientas-de-desarrollo-útiles"><a class="header" href="#apéndice-a---herramientas-de-desarrollo-útiles">Apéndice A - Herramientas de desarrollo útiles</a></h2>
<p>En este apéndice, hablamos de algunas herramientas de desarrollo útiles que el proyecto Cairo
proporciona. Veremos el formateo automático, formas rápidas de aplicar
correcciones de advertencias, un linter, y la integración con IDEs.</p>
<h3 id="formateo-automático-con-cairo-format"><a class="header" href="#formateo-automático-con-cairo-format">Formateo automático con <code>cairo-format</code>.</a></h3>
<p>La herramienta <code>cairo-format</code> reformatea tu código de acuerdo con el estilo de código de la comunidad. Muchos proyectos colaborativos usan <code>cairo-format</code> para evitar discusiones sobre qué estilo usar al escribir Cairo: todo el mundo formatea su código usando la herramienta.</p>
<p>Para formatear cualquier proyecto de Cairo, introduce lo siguiente:</p>
<pre><code class="language-console">cairo-format -r
</code></pre>
<p>Ejecutando este comando reformateará todo el código de Cairo en el directorio actual de forma recursiva. Esto solo cambiará el estilo de código, no la semántica del código.</p>
<h3 id="integración-del-ide-usando-cairo-language-server"><a class="header" href="#integración-del-ide-usando-cairo-language-server">Integración del IDE usando <code>cairo-language-server</code></a></h3>
<p>Para ayudar con la integración del IDE, la comunidad de Cairo recomienda el uso de <a href="https://github.com/starkware-libs/cairo/tree/main/crates/cairo-lang-language-server"><code>cairo-language-server</code></a>. Esta herramienta es un conjunto de utilidades centradas en el compilador que utiliza el <a href="http://langserver.org/">Protocolo del Servidor de Lenguaje</a>, que es una especificación para que los IDE y los lenguajes de programación se comuniquen entre sí. Diferentes clientes pueden utilizar <code>cairo-language-server</code>, como la extensión de Cairo para Visual Studio Code.</p>
<p>Visita la <a href="https://github.com/starkware-libs/cairo/tree/main/vscode-cairo">página</a> de <code>vscode-cairo</code> para obtener instrucciones de instalación. Obtendrás habilidades como autocompletado, saltar a la definición y errores en línea.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
