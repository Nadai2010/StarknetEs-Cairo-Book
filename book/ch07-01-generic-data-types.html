<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Funciones genéricas - El lenguaje de programación Cairo </title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">El lenguaje de programación Cairo</a></li><li class="chapter-item expanded affix "><a href="ch00-01-foreword.html">Prólogo</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Introducción</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Cómo empezar</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Instalación</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hola, Mundo!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-scarb.html"><strong aria-hidden="true">1.3.</strong> Hola, Scarb!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-common-programming-concepts.html"><strong aria-hidden="true">2.</strong> Conceptos comunes de programación</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch02-01-variables-and-mutability.html"><strong aria-hidden="true">2.1.</strong> Variables y mutabilidad</a></li><li class="chapter-item expanded "><a href="ch02-02-data-types.html"><strong aria-hidden="true">2.2.</strong> Tipos de datos</a></li><li class="chapter-item expanded "><a href="ch02-03-functions.html"><strong aria-hidden="true">2.3.</strong> Funciones</a></li><li class="chapter-item expanded "><a href="ch02-04-comments.html"><strong aria-hidden="true">2.4.</strong> Comentarios</a></li><li class="chapter-item expanded "><a href="ch02-05-control-flow.html"><strong aria-hidden="true">2.5.</strong> Flujo de contro</a></li></ol></li><li class="chapter-item expanded "><a href="ch03-00-understanding-ownership.html"><strong aria-hidden="true">3.</strong> Comprender Ownership</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-what-is-ownership.html"><strong aria-hidden="true">3.1.</strong> ¿Qué es Ownership?</a></li><li class="chapter-item expanded "><a href="ch03-02-references-and-snapshots.html"><strong aria-hidden="true">3.2.</strong> Referencias e instantáneas</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-using-structs-to-structure-related-data.html"><strong aria-hidden="true">4.</strong>  Uso de estructuras para estructurar datos relacionados</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-defining-and-instantiating-structs.html"><strong aria-hidden="true">4.1.</strong> Definición e instanciación de estructuras</a></li><li class="chapter-item expanded "><a href="ch04-02-an-example-program-using-structs.html"><strong aria-hidden="true">4.2.</strong> Un programa de ejemplo usando estructuras</a></li><li class="chapter-item expanded "><a href="ch04-03-method-syntax.html"><strong aria-hidden="true">4.3.</strong> Sintaxis de métodos</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-enums-and-pattern-matching.html"><strong aria-hidden="true">5.</strong> Enums y Concordancia de Patrones</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-enums.html"><strong aria-hidden="true">5.1.</strong> Enums</a></li><li class="chapter-item expanded "><a href="ch05-02-the-match-control-flow-construct.html"><strong aria-hidden="true">5.2.</strong> La construcción del flujo de control de coincidencias</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-managing-cairo-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">6.</strong> Gestionando Proyectos Cairo con Paquetes, Crates y Módulos</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-packages-and-crates.html"><strong aria-hidden="true">6.1.</strong> Paquetes y Crates</a></li><li class="chapter-item expanded "><a href="ch06-02-defining-modules-to-control-scope.html"><strong aria-hidden="true">6.2.</strong> Definición de módulos para controlar el alcance</a></li><li class="chapter-item expanded "><a href="ch06-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">6.3.</strong> Rutas para referirse a un elemento en el Arbol de Módulos</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-generic-types.html"><strong aria-hidden="true">7.</strong> Tipos de datos Genéricos</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-generic-data-types.html" class="active"><strong aria-hidden="true">7.1.</strong> Funciones genéricas</a></li><li class="chapter-item expanded "><a href="ch07-02-traits-in-cairo.html"><strong aria-hidden="true">7.2.</strong> Traits en Cairo</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-testing-cairo-programs.html"><strong aria-hidden="true">8.</strong> Probando programas de Cairo</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-how-to-write-tests.html"><strong aria-hidden="true">8.1.</strong> Cómo escribir Tests</a></li><li class="chapter-item expanded "><a href="ch09-02-test-organization.html"><strong aria-hidden="true">8.2.</strong> Organización de Testing</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">9.</strong> Apéndice</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">9.1.</strong> A - Herramientas de desarrollo útiles</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">El lenguaje de programación Cairo </h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="generic-data-types"><a class="header" href="#generic-data-types">Generic Data Types</a></h1>
<p>We use generics to create definitions for item declarations, such as structs and functions, which we can then use with many different concrete data types. In Cairo we can use generics when defining functions, structs, enums, traits, implementations and methods! In this chapter we are going to take a look on how to effectively use generic types with all of them.</p>
<h2 id="generic-functions"><a class="header" href="#generic-functions">Generic Functions</a></h2>
<p>When defining a function that uses generics, we place the generics in the function signature, where we would usually specify the data types of the parameter and return value. For example, imagine we want to create a function which given two <code>Array</code> of items, will return the largest one. If we need to perform this operations for lists of different types, then we would have to redefine the function each time. Luckily we can implement the function once using generics and move on to other tasks.</p>
<pre><code class="language-rust">// This code does not compile!

use array::ArrayTrait;

// Specify generic type T between the angulars
fn largest_list&lt;T&gt;(l1: Array&lt;T&gt;, l2: Array&lt;T&gt;) -&gt; Array&lt;T&gt; {
    if l1.len() &gt; l2.len() {
        l1
    } else {
        l2
    }
}

fn main() {
    let mut l1 = ArrayTrait::new();
    let mut l2 = ArrayTrait::new();

    l1.append(1);
    l1.append(2);

    l2.append(3);
    l2.append(4);
    l2.append(5);

    // There is no need to specify the concrete type of T because
    // it is inferred by the compiler
    let l3 = largest_list(l1, l2);
}</code></pre>
<p>The <code>largest_list</code> function compares two lists of the same type and returns the one with more elements and drops the other. If you compile the previous code, you will notice that it will fail with an error saying that there are no traits defined for droping an array of a generic type. This happens because the compiler has no way to guarantee that an <code>Array&lt;T&gt;</code> is droppable when executing the <code>main</code> function. In order to drop an array of <code>T</code>, the compiler must first know how to drop <code>T</code>. This can be fixed by specifiying in the function signature of <code>largest_list</code> that <code>T</code> must implement the drop trait. The correct function definition of <code>largest_list</code> is as follows:</p>
<pre><code class="language-rust">fn largest_list&lt;T, impl TDrop: Drop&lt;T&gt;&gt;(l1: Array&lt;T&gt;, l2: Array&lt;T&gt;) -&gt; Array&lt;T&gt; {
    if l1.len() &gt; l2.len() {
        l1
    } else {
        l2
    }
}</code></pre>
<p>The new <code>largest_list</code> function includes in its definition the requirement that whatever generic type is placed there, it must be droppable. The <code>main</code> function remains unchanged, the compiler is smart enough to deduct which concrete type is being used and if it implements the <code>Drop</code> trait.</p>
<h3 id="constraints-for-generic-types"><a class="header" href="#constraints-for-generic-types">Constraints for Generic Types</a></h3>
<p>When defining generic types, it is useful to have information about them. Knowing which traits a generic type implements allow us to use them more effectively in a functions logic at the cost of constraining the generic types that can be used with the function. We saw an example of this previously by adding the <code>TDrop</code> implementation as part of the generic arguments of <code>largest_list</code>. While <code>TDrop</code> was added to satisfy the compilers requirements, we can also add constraints to benefit our function logic.</p>
<p>Imagine that we want, given a list of elements of some generic type <code>T</code>, find the smallest element among them. Initially, we know that for an element of type <code>T</code> to be comparable, it must implement the <code>PartialOrd</code> trait. The resulting function would be:</p>
<pre><code class="language-rust">// This code does not compile!
use array:ArrayTrait;

// Given a list of T get the smallest one.
// The PartialOrd trait implements comparison operations for T
fn smallest_element&lt;T, impl TPartialOrd: PartialOrd&lt;T&gt;&gt;(list: @Array&lt;T&gt;) -&gt; T {
    // This represents the smallest element through the iteration
    // Notice that we use the desnap (*) operator
    let mut smallest = *list[0_usize];

    // The index we will use to move through the list
    let mut index = 1_usize;

    // Iterate through the whole list storing the smallest
    loop {
        if index &gt;= list.len(){
            break smallest;
        }
        if *list[index] &lt; smallest {
            smallest = *list[index];
        }
        index = index + 1;
    }
}

fn main()  {
    let mut list = ArrayTrait::new();
    list.append(5_u8);
    list.append(3_u8);
    list.append(10_u8);

    // We need to specify that we are passing a snapshot of `list` as an argument
    let s = smallest_element(@list);
    assert(s == 3_u8, 0);

}</code></pre>
<p>The <code>smallest_element</code> function uses a generic type <code>T</code> that implements the <code>PartialOrd</code> trait, takes an snapshot of an <code>Array&lt;T&gt;</code> as a parameter and returns a copy of the smallest element. Because the parameter is of type <code>@Array&lt;T&gt;</code>, we no longer need to drop it at the end of the execution and so we don't require to implement the <code>Drop</code> trait for <code>T</code> as well. Why it does not compile then?</p>
<p>When indexing on <code>list</code>, the value results in a snap of the indexed element, unless <code>PartialOrd</code> is implemented for <code>@T</code> we need to desnap the element using <code>*</code>. The <code>*</code> operation requires a copy from <code>@T</code> to<code>T</code>, which means that <code>T</code> needs to implement the <code>Copy</code> trait. After copying an element of type <code>@T</code> to <code>T</code>, there are now variables with type <code>T</code> that need to be dropped, requiring for <code>T</code> to implement the <code>Drop</code> trait as well. We must then add both <code>Drop</code> and <code>Copy</code> traits implementation for the function to be correct. After updating the<code>smallest_element</code> function the resulting code would be:</p>
<pre><code class="language-rs">fn smallest_element&lt;T, impl TPartialOrd: PartialOrd&lt;T&gt;, impl TCopy: Copy&lt;T&gt;, impl TDrop: Drop&lt;T&gt;&gt;(list: @Array&lt;T&gt;) -&gt; T {
    let mut smallest = *list[0_usize];
    let mut index = 1_usize;
    loop {
        if index &gt;= list.len(){
            break smallest;
        }
        if *list[index] &lt; smallest {
            smallest = *list[index];
        }
        index = index + 1;
    }
}
</code></pre>
<h2 id="structs"><a class="header" href="#structs">Structs</a></h2>
<p>We can also define structs to use a generic type parameter for one or more fields using the <code>&lt;&gt;</code> syntax, similar to function definitions. First we declare the name of the type parameter inside the angle brackets just after the name of the struct. Then we use the generic type in the struct definition where we would otherwise specify concrete data types. The next code example shows the definition <code>Wallet&lt;T&gt;</code> which has a <code>balance</code> field of type <code>T</code>.</p>
<pre><code class="language-rust">// This code does not compile!

#[derive(Drop)]
struct Wallet&lt;T&gt; {
    balance: T,
}


fn main() {
   let w = Wallet{ balance: 3_u128};
}</code></pre>
<p>Compiling the above code would error due to the <code>derive</code> macro not working well with generics. When using generic types is best to directly write the traits you want to use:</p>
<pre><code class="language-rust">struct Wallet&lt;T&gt; {
    balance: T,
}

impl WalletDrop&lt;T, impl TDrop : Drop&lt;T&gt;&gt; of Drop&lt;Wallet&lt;t&gt;&gt;;

fn main() {
   let w = Wallet{ balance: 3_u128};
}</code></pre>
<p>We avoid using the <code>derive</code> macro for <code>Drop</code> implementation of <code>Wallet</code> and instead define our own <code>WalletDrop</code> implementation. Notice that we must define, just like functions, an additional generic type for <code>WalletDrop</code> saying that <code>T</code> implements the <code>Drop</code> trait as well. We are basically saying that the struct <code>Wallet&lt;T&gt;</code> is droppable as long as <code>T</code> is also droppable.</p>
<p>Finally, if we want to add a field to <code>Wallet</code> representing its Cairo address and we want that field to be different than <code>T</code> but generic as well, we can simply add another generic type between the <code>&lt;&gt;</code>:</p>
<pre><code class="language-rust">struct Wallet&lt;T, U&gt; {
    balance: T,
    address: U,
}

impl WalletDrop&lt;T, impl TDrop: Drop&lt;T&gt;, U, impl UDrop: Drop&lt;U&gt;&gt; of Drop&lt;Wallet&lt;T, U&gt;&gt;;


fn main() {
   let w = Wallet{ balance: 3_u128, address: 14};
}</code></pre>
<p>We add to <code>Wallet</code> struct definiton a new generic type <code>U</code> and then assign this type to the new field member <code>address</code>.
Then we adapt the <code>WalletDrop</code> trait to work with the new generic type <code>U</code>. Notice that when initializing the struct inside <code>main</code> it automatically infers that <code>T</code> is a <code>u128</code> and <code>U</code> is a <code>felt252</code> and since they are both droppable, <code>Wallet</code> is droppable as well!</p>
<h2 id="enums"><a class="header" href="#enums">Enums</a></h2>
<p>As we did with structs, we can define enums to hold generic data types in their variants. For example the <code>Option&lt;T&gt;</code> enum provided by the Cairo core library:</p>
<pre><code class="language-rust">enum Option&lt;T&gt; {
    Some(T),
    None,
}</code></pre>
<p>The <code>Option&lt;T&gt;</code> enum is generic over a type <code>T</code> and has two variants: <code>Some</code>, which holds one value of type <code>T</code> and <code>None</code> that doesn't hold any value. By using the <code>Option&lt;T&gt;</code> enum, it is possible for us to express the abstract concept of an optional value and because the value has a generic type <code>T</code> we can use this abstraction with any type.</p>
<p>Enums can use multiple generic types as well, like definition of the <code>Result&lt;T, E&gt;</code> enum that the core library provides:</p>
<pre><code class="language-rust">enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}</code></pre>
<p>The <code>Result&lt;T, E&gt;</code> enum is has two generic types, <code>T</code> and <code>E</code>, and two variants: <code>Ok</code> which holds the value of type <code>T</code> and <code>Err</code> which holds the value of type <code>E</code>. This definition makes it convenient to use the <code>Result</code> enum anywhere we have an operation that might succeed (by returning a value of type <code>T</code>) or fail (by returning a value of type <code>E</code>).</p>
<h2 id="generic-methods"><a class="header" href="#generic-methods">Generic Methods</a></h2>
<p>We can implement methods on structs and enums, and use the generic types in their definition, too. Using our previous definition of <code>Wallet&lt;T&gt;</code> struct, we define a <code>balance</code> method for it:</p>
<pre><code class="language-rust">struct Wallet&lt;T&gt; {
    balance: T,
}

impl WalletDrop&lt;T, impl TDrop: Drop&lt;T&gt;&gt; of Drop&lt;Wallet&lt;T, U&gt;&gt;;

trait WalletTrait&lt;T&gt; {
    fn balance(self: @Wallet&lt;T&gt;) -&gt; @T;
}

impl WalletImpl&lt;T&gt; of WalletTrait&lt;T&gt; {
    fn balance(self: @Wallet&lt;T&gt;) -&gt; @T{
        return self.balance;
    }
}

fn main() {
    let w = Wallet {balance: 50};
    assert(w.balance() == 50, 0);
}</code></pre>
<p>We first define <code>WalletTrait&lt;T&gt;</code> trait using a generic type <code>T</code> which defines a method that returns a snapshot of the field <code>address</code> from <code>Wallet</code>. Then we give an implementation for the trait in <code>WalletImpl&lt;T&gt;</code>. Note that you need to include a generic type in both definitions of the trait and the implementation.</p>
<p>We can also specify constraints on generic types when defining methods on the type. We could, for example, implement methods only for <code>Wallet&lt;u128&gt;</code> instances rather than <code>Wallet&lt;T&gt;</code>. In the code example we define an implementation for wallets which have a concrete type of <code>u128</code> for the <code>balance</code> field.</p>
<pre><code class="language-rust">trait WalletReceiveTrait {
    fn receive(ref self: Wallet&lt;u128&gt;, value: u128);
}

impl WalletReceiveImpl of WalletReceiveTrait {
    fn receive(ref self: Wallet&lt;u128&gt;, value: u128) {
        self.balance += value;
    }
}

fn main() {
    let mut w = Wallet {balance: 50_u128};
    assert(w.balance() == 50_u128, 0);

    w.receive(100_u128)
    assert(w.balance() == 150_u128, 0);
}</code></pre>
<p>The new method <code>receive</code> increments the size of the balance of any instance of a <code>Wallet&lt;u128&gt;</code>. Notice that we changed the <code>main</code> function making <code>w</code> a mutable variable in order for it to be able to update its balance. If we were to change the initialization of <code>w</code> by changing the type of <code>balance</code> the previous code wouldn't compile.</p>
<p>Cairo allow us to define generic methods inside generic traits as well. Using the past implementation from <code>Wallet&lt;U, V&gt;</code> we are going to define a trait that picks two wallets of different generic types and create a new one with a generic type of each. First, lets rewrite the struct definiton:</p>
<pre><code class="language-rust">struct Wallet&lt;T, U&gt; {
    balance: T,
    address: U,
}</code></pre>
<p>Next we are going to naively define the mixup trait and implementation:</p>
<pre><code class="language-rust">// This does not compile!
trait WalletMixTrait&lt;T1, U1&gt; {
    fn mixup&lt;T2, U2&gt;(self: Wallet&lt;T1, U1&gt;, other: Wallet&lt;T2, U2&gt;) -&gt; Wallet&lt;T1, U2&gt;;
}

impl WalletMixImpl&lt;T1,  U1&gt; of WalletMixTrait&lt;T1, U1&gt; {
    fn mixup&lt;T2, U2&gt;(self: Wallet&lt;T1, U1&gt;, other: Wallet&lt;T2, U2&gt;) -&gt; Wallet&lt;T1, U2&gt; {
        Wallet {balance: self.balance, address: other.address}
    }
}</code></pre>
<p>We are creating a trait <code>WalletMixTrait&lt;T1, U1&gt;</code> with the <code>mixup&lt;T2, U2&gt;</code> methods which given an instance of <code>Wallet&lt;T1, U1&gt;</code> and <code>Wallet&lt;T2, U2&gt;</code> creates a new <code>Wallet&lt;T1, U2&gt;</code>. As <code>mixup</code> signature specify, both <code>self</code> and <code>other</code> are getting dropped at the end of the function, which is the reason for this code not to compile. If you have been following from the start until now you would know that we must add a requirement for all the generic types specifiying that they will implement the <code>Drop</code> trait in order for the compiler to know how to drop instances of <code>Wallet&lt;T, U&gt;</code>. The updated implementation is as follow:</p>
<pre><code class="language-rust">trait WalletMixTrait&lt;T1, U1&gt; {
    fn mixup&lt;T2, impl T2Drop: Drop&lt;T2&gt;, U2, impl U2Drop: Drop&lt;U2&gt;&gt;(self: Wallet&lt;T1, U1&gt;, other: Wallet&lt;T2, U2&gt;) -&gt; Wallet&lt;T1, U2&gt;;
}

impl WalletMixImpl&lt;T1, impl T1Drop: Drop&lt;T1&gt;,  U1, impl U1Drop: Drop&lt;U1&gt;&gt; of WalletMixTrait&lt;T1, U1&gt; {
    fn mixup&lt;T2, impl T2Drop: Drop&lt;T2&gt;, U2, impl U2Drop: Drop&lt;U2&gt;&gt;(self: Wallet&lt;T1, U1&gt;, other: Wallet&lt;T2, U2&gt;) -&gt; Wallet&lt;T1, U2&gt; {
        Wallet {balance: self.balance, address: other.address}
    }
}</code></pre>
<p>We add the requirements for <code>T1</code> and <code>U1</code> to be droppable on <code>WalletMixImpl</code> declaration. Then we do the same for <code>T2</code> and <code>U2</code>, this time as part of <code>mixup</code> signature. We can now try the <code>mixup</code> function:</p>
<pre><code class="language-rs">fn main() {
   let w1 = Wallet{ balance: true, address: 10_u128};
   let w2 = Wallet{ balance: 32, address: 100_u8};

   let w3 = w1.mixup(w2);

   assert(w3.balance == true, 0);
   assert(w3.address == 100_u8, 0);
}
</code></pre>
<p>We first create two instances: one of <code>Wallet&lt;bool, u128&gt;</code> and the other of <code>Wallet&lt;felt252, u8&gt;</code>. Then, we call <code>mixup</code> and create a new <code>Wallet&lt;bool, u8&gt;</code> instance.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch07-00-generic-types.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="ch07-02-traits-in-cairo.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch07-00-generic-types.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="ch07-02-traits-in-cairo.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
