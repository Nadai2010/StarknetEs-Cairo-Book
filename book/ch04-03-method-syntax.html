<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Sintaxis de métodos - El lenguaje de programación Cairo </title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">El lenguaje de programación Cairo</a></li><li class="chapter-item expanded affix "><a href="ch00-01-foreword.html">Prólogo</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Introducción</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Cómo empezar</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Instalación</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hola, Mundo!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-scarb.html"><strong aria-hidden="true">1.3.</strong> Hola, Scarb!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-common-programming-concepts.html"><strong aria-hidden="true">2.</strong> Conceptos comunes de programación</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch02-01-variables-and-mutability.html"><strong aria-hidden="true">2.1.</strong> Variables y mutabilidad</a></li><li class="chapter-item expanded "><a href="ch02-02-data-types.html"><strong aria-hidden="true">2.2.</strong> Tipos de datos</a></li><li class="chapter-item expanded "><a href="ch02-03-functions.html"><strong aria-hidden="true">2.3.</strong> Funciones</a></li><li class="chapter-item expanded "><a href="ch02-04-comments.html"><strong aria-hidden="true">2.4.</strong> Comentarios</a></li><li class="chapter-item expanded "><a href="ch02-05-control-flow.html"><strong aria-hidden="true">2.5.</strong> Flujo de contro</a></li></ol></li><li class="chapter-item expanded "><a href="ch03-00-understanding-ownership.html"><strong aria-hidden="true">3.</strong> Comprender Ownership</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-what-is-ownership.html"><strong aria-hidden="true">3.1.</strong> ¿Qué es Ownership?</a></li><li class="chapter-item expanded "><a href="ch03-02-references-and-snapshots.html"><strong aria-hidden="true">3.2.</strong> Referencias e instantáneas</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-using-structs-to-structure-related-data.html"><strong aria-hidden="true">4.</strong>  Uso de estructuras para estructurar datos relacionados</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-defining-and-instantiating-structs.html"><strong aria-hidden="true">4.1.</strong> Definición e instanciación de estructuras</a></li><li class="chapter-item expanded "><a href="ch04-02-an-example-program-using-structs.html"><strong aria-hidden="true">4.2.</strong> Un programa de ejemplo usando estructuras</a></li><li class="chapter-item expanded "><a href="ch04-03-method-syntax.html" class="active"><strong aria-hidden="true">4.3.</strong> Sintaxis de métodos</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-enums-and-pattern-matching.html"><strong aria-hidden="true">5.</strong> Enums y Concordancia de Patrones</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-enums.html"><strong aria-hidden="true">5.1.</strong> Enums</a></li><li class="chapter-item expanded "><a href="ch05-02-the-match-control-flow-construct.html"><strong aria-hidden="true">5.2.</strong> La construcción del flujo de control de coincidencias</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-managing-cairo-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">6.</strong> Gestionando Proyectos Cairo con Paquetes, Crates y Módulos</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-packages-and-crates.html"><strong aria-hidden="true">6.1.</strong> Paquetes y Crates</a></li><li class="chapter-item expanded "><a href="ch06-02-defining-modules-to-control-scope.html"><strong aria-hidden="true">6.2.</strong> Definición de módulos para controlar el alcance</a></li><li class="chapter-item expanded "><a href="ch06-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">6.3.</strong> Rutas para referirse a un elemento en el Arbol de Módulos</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-generic-types.html"><strong aria-hidden="true">7.</strong> Tipos de datos Genéricos</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-generic-data-types.html"><strong aria-hidden="true">7.1.</strong> Funciones genéricas</a></li><li class="chapter-item expanded "><a href="ch07-02-traits-in-cairo.html"><strong aria-hidden="true">7.2.</strong> Traits en Cairo</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-testing-cairo-programs.html"><strong aria-hidden="true">8.</strong> Probando programas de Cairo</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-how-to-write-tests.html"><strong aria-hidden="true">8.1.</strong> Cómo escribir Tests</a></li><li class="chapter-item expanded "><a href="ch09-02-test-organization.html"><strong aria-hidden="true">8.2.</strong> Organización de Testing</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">9.</strong> Apéndice</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">9.1.</strong> A - Herramientas de desarrollo útiles</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">El lenguaje de programación Cairo </h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="method-syntax"><a class="header" href="#method-syntax">Method Syntax</a></h2>
<p><em>Methods</em> are similar to functions: we declare them with the <code>fn</code> keyword and a
name, they can have parameters and a return value, and they contain some code
that’s run when the method is called from somewhere else. Unlike functions,
methods are defined within the context of a type and their first parameter is
always <code>self</code>, which represents the instance of the type the method is being
called on. For those familiar with Rust, Cairo's approach might be confusing,
as methods cannot be defined directly on types. Instead, you must define a trait
and an implementation associated with the type for which the method is intended.</p>
<h3 id="defining-methods"><a class="header" href="#defining-methods">Defining Methods</a></h3>
<p>Let’s change the <code>area</code> function that has a <code>Rectangle</code> instance as a parameter
and instead make an <code>area</code> method defined on the <code>RectangleTrait</code> trait, as shown
in Listing 5-13.</p>
<p><span class="filename">Filename: src/lib.cairo</span></p>
<pre><code class="language-rust">use debug::PrintTrait;
#[derive(Copy, Drop)]
struct Rectangle {
    width: u64,
    height: u64,
}

trait RectangleTrait {
    fn area(self: @Rectangle) -&gt; u64;
}

impl RectangleImpl of RectangleTrait {
    fn area(self: @Rectangle) -&gt; u64 {
        (*self.width) * (*self.height)
    }
}

fn main() {
    let rect1 = Rectangle { width: 30_u64, height: 50_u64,  };

    rect1.area().print();
}</code></pre>
<p><span class="caption">Listing 4-13: Defining an <code>area</code> method to use on the
<code>Rectangle</code> </span></p>
<p>To define the function within the context of <code>Rectangle</code>, we start by definining a <code>trait</code>
block with the signature of the method that we want to implement. Traits are not linked to
a specific type; only the <code>self</code> parameter of the method defines which type it can be used
with. Then, we define an <code>impl</code> (implementation) block for <code>RectangleTrait</code>, that defines
the behavior of the methods implemented. Everything within this <code>impl</code> block will be
associated with the type of the <code>self</code> parameter of the method called. While it is technically
possible to define methods for multiple types within the same <code>impl</code> block, it is not
a recommended practice, as it can lead to confusion. We recommend that the type of the <code>self</code> parameter
stays consistent within the same <code>impl</code> block.
Then we move the <code>area</code> function within the <code>impl</code> curly brackets and change the first (and in this case, only)
parameter to be <code>self</code> in the signature and everywhere within the body. In
<code>main</code>, where we called the <code>area</code> function and passed <code>rect1</code> as an argument,
we can instead use the <em>method syntax</em> to call the <code>area</code> method on our <code>Rectangle</code>
instance. The method syntax goes after an instance: we add a dot followed by
the method name, parentheses, and any arguments.</p>
<p>Methods must have a parameter named <code>self</code> of the type they will be applied to for their first parameter.
Note that we used the <code>@</code> snapshot operator in front of the <code>Rectangle</code> type in the function signature.
By doing so, we indicate that this method takes an immutable snapshot of the <code>Rectangle</code> instance, which is
automatically created by the compiler when passing the instance to the method.
Methods can take ownership of <code>self</code>, use <code>self</code> with snapshots as we’ve done here, or use a mutable reference to <code>self</code>
using the <code>ref self: T</code> syntax.</p>
<p>We chose <code>self: @Rectangle</code> here for the same reason we used <code>@Rectangle</code> in the function
version: we don’t want to take ownership, and we just want to read the data in
the struct, not write to it. If we wanted to change the instance that we’ve
called the method on as part of what the method does, we’d use <code>ref self: Rectangle</code> as
the first parameter. Having a method that takes ownership of the instance by
using just <code>self</code> as the first parameter is rare; this technique is usually
used when the method transforms <code>self</code> into something else and you want to
prevent the caller from using the original instance after the transformation.</p>
<p>Observe the use of the desnap operator <code>*</code> within the area method when accessing the struct's members.
This is necessary because the struct is passed as a snapshot, and all of its field values are of type <code>@T</code>,
requiring them to be desnapped in order to manipulate them.</p>
<p>The main reason for using methods instead of functions is for organization and code clarity. We’ve put all the things we can do with an instance of a type in one combination of <code>trait</code> &amp; <code>impl</code> blocks, rather than making future users
of our code search for capabilities of <code>Rectangle</code> in various places in the
library we provide. However, we can define multiple combinations of <code>trait</code> &amp; <code>impl</code> blocks for the same type at different places, which can be useful for a more granular code organization. For example, you could implement
the <code>Add</code> trait for your type in one <code>impl</code> block, and the <code>Sub</code> trait in another block.</p>
<p>Note that we can choose to give a method the same name as one of the struct’s
fields. For example, we can define a method on <code>Rectangle</code> that is also named
<code>width</code>:</p>
<p><span class="filename">Filename: src/lib.cairo</span></p>
<pre><code class="language-rust">use debug::PrintTrait;
#[derive(Copy, Drop)]
struct Rectangle {
    width: u64,
    height: u64,
}

trait RectangleTrait {
    fn width(self: @Rectangle) -&gt; bool;
}

impl RectangleImpl of RectangleTrait {
    fn width(self: @Rectangle) -&gt; bool {
        (*self.width) &gt; 0_u64
    }
}

fn main() {
    let rect1 = Rectangle { width: 30_u64, height: 50_u64,  };
    rect1.width().print();
}</code></pre>
<p>Here, we’re choosing to make the <code>width</code> method return <code>true</code> if the value in
the instance’s <code>width</code> field is greater than <code>0</code> and <code>false</code> if the value is
<code>0</code>: we can use a field within a method of the same name for any purpose. In
<code>main</code>, when we follow <code>rect1.width</code> with parentheses, Cairo knows we mean the
method <code>width</code>. When we don’t use parentheses, Cairo knows we mean the field
<code>width</code>.</p>
<h3 id="methods-with-more-parameters"><a class="header" href="#methods-with-more-parameters">Methods with More Parameters</a></h3>
<p>Let’s practice using methods by implementing a second method on the <code>Rectangle</code>
struct. This time we want an instance of <code>Rectangle</code> to take another instance
of <code>Rectangle</code> and return <code>true</code> if the second <code>Rectangle</code> can fit completely
within <code>self</code> (the first <code>Rectangle</code>); otherwise, it should return <code>false</code>.
That is, once we’ve defined the <code>can_hold</code> method, we want to be able to write
the program shown in Listing 5-14.</p>
<p><span class="filename">Filename: src/lib.cairo</span></p>
<pre><code class="language-swift">use debug::PrintTrait;
#[derive(Copy, Drop)]
struct Rectangle {
    width: u64,
    height: u64,
}


fn main() {
    let rect1 = Rectangle {
        width: 30_u64,
        height: 50_u64,
    };
    let rect2 = Rectangle {
        width: 10_u64,
        height: 40_u64,
    };
    let rect3 = Rectangle {
        width: 60_u64,
        height: 45_u64,
    };

    'Can rect1 hold rect2?'.print();
    rect1.can_hold(@rect2).print();

    'Can rect1 hold rect?'.print();
    rect1.can_hold(@rect3).print();
}
</code></pre>
<p><span class="caption">Listing 5-14: Using the as-yet-unwritten <code>can_hold</code>
method</span></p>
<p>The expected output would look like the following because both dimensions of
<code>rect2</code> are smaller than the dimensions of <code>rect1</code>, but <code>rect3</code> is wider than
<code>rect1</code>:</p>
<pre><code class="language-text">❯ cairo-run src/lib.cairo
[DEBUG]	Can rec1 hold rect2?           	(raw: 384675147322001379018464490539350216396261044799)

[DEBUG]	true                           	(raw: 1953658213)

[DEBUG]	Can rect1 hold rect?           	(raw: 384675147322001384331925548502381811111693612095)

[DEBUG]	false                          	(raw: 439721161573)

</code></pre>
<p>We know we want to define a method, so it will be within the <code>trait RectangleTrait</code>
and <code>impl RectangleImpl of RectangleTrait</code> blocks.
The method name will be <code>can_hold</code>, and it will take a snapshot
of another <code>Rectangle</code> as a parameter. We can tell what the type of the
parameter will be by looking at the code that calls the method:
<code>rect1.can_hold(@rect2)</code> passes in <code>@rect2</code>, which is a snapshot to
<code>rect2</code>, an instance of <code>Rectangle</code>. This makes sense because we only need to
read <code>rect2</code> (rather than write, which would mean we’d need a mutable borrow),
and we want <code>main</code> to retain ownership of <code>rect2</code> so we can use it again after
calling the <code>can_hold</code> method. The return value of <code>can_hold</code> will be a
Boolean, and the implementation will check whether the width and height of
<code>self</code> are greater than the width and height of the other <code>Rectangle</code>,
respectively. Let’s add the new <code>can_hold</code> method to the <code>trait</code> and <code>impl</code> blocks from
Listing 5-13, shown in Listing 5-15.</p>
<p><span class="filename">Filename: src/lib.cairo</span></p>
<pre><code class="language-rust">trait RectangleTrait {
    fn area(self: @Rectangle) -&gt; u64;
    fn can_hold(self: @Rectangle, other: @Rectangle) -&gt; bool;
}

impl RectangleImpl of RectangleTrait {
    fn area(self: @Rectangle) -&gt; u64 {
        *self.width * *self.height
    }

    fn can_hold(self: @Rectangle, other: @Rectangle) -&gt; bool {
        *self.width &gt; *other.width &amp; *self.height &gt; *other.height
    }
}</code></pre>
<p><span class="caption">Listing 5-15: Implementing the <code>can_hold</code> method on
<code>Rectangle</code> that takes another <code>Rectangle</code> instance as a parameter</span></p>
<p>When we run this code with the <code>main</code> function in Listing 5-14, we’ll get our
desired output. Methods can take multiple parameters that we add to the
signature after the <code>self</code> parameter, and those parameters work just like
parameters in functions.</p>
<h3 id="accessing-implementation-functions"><a class="header" href="#accessing-implementation-functions">Accessing implementation functions</a></h3>
<p>All functions defined within a <code>trait</code> and <code>impl</code> block can be directly addressed
using the <code>::</code> operator on the implementation name.
Functions in traits that aren’t methods are often used for constructors that
will return a new instance of the struct. These are often called <code>new</code>, but
<code>new</code> isn’t a special name and isn’t built into the language. For example, we
could choose to provide an associated function named <code>square</code> that would have
one dimension parameter and use that as both width and height, thus making it
easier to create a square <code>Rectangle</code> rather than having to specify the same
value twice:</p>
<p><span class="filename">Filename: src/lib.cairo</span></p>
<pre><code class="language-rust">trait RectangleTrait {
    fn square(size:u64) -&gt; Rectangle;
}

impl RectangleImpl of RectangleTrait {
    fn square(size: u64) -&gt; Rectangle {
        Rectangle { width: size, height: size }
    }
}</code></pre>
<p>To call this function, we use the <code>::</code> syntax with the implementation name;
<code>let square = RectangleImpl::square(10_u64);</code> is an example. This function is namespaced by
the implementation: the <code>::</code> syntax is used for both trait functions and
namespaces created by modules. We’ll discuss modules in [Chapter 7][modules]<!-- ignore -->.</p>
<blockquote>
<p>Note: It is also possible to call this function using the trait name, with <code>RectangleTrait::square(10_u64)</code>.</p>
</blockquote>
<h3 id="multiple-impl-blocks"><a class="header" href="#multiple-impl-blocks">Multiple <code>impl</code> Blocks</a></h3>
<p>Each struct is allowed to have multiple <code>trait</code> and <code>impl</code> blocks. For example, Listing
5-15 is equivalent to the code shown in Listing 5-16, which has each method in
its own <code>trait</code> and <code>impl</code> blocks.</p>
<pre><code class="language-rust">trait RectangleCalc {
    fn area(self: @Rectangle) -&gt; u64;
}
impl RectangleCalcImpl of RectangleCalc {
    fn area(self: @Rectangle) -&gt; u64 {
        (*self.width) * (*self.height)
    }
}

trait RectangleCmp {
    fn can_hold(self: @Rectangle, other: @Rectangle) -&gt; bool;
}

impl RectangleCmpImpl of RectangleCmp {
    fn can_hold(self: @Rectangle, other: @Rectangle) -&gt; bool {
        *self.width &gt; *other.width &amp; *self.height &gt; *other.height
    }
}</code></pre>
<p><span class="caption">Listing 5-16: Rewriting Listing 5-15 using multiple <code>impl</code>
blocks</span></p>
<p>There’s no reason to separate these methods into multiple <code>trait</code> and <code>impl</code> blocks here,
but this is valid syntax. We’ll see a case in which multiple blocks are
useful in <a href="ch07-00-generic-types-and-traits.html">Chapter 7</a>, where we discuss generic types and traits.</p>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>Structs let you create custom types that are meaningful for your domain. By
using structs, you can keep associated pieces of data connected to each other
and name each piece to make your code clear. In <code>trait</code> and <code>impl</code> blocks, you can define
methods, which are functions associated to a type and let you specify the behavior that instances of your
type have.</p>
<p>But structs aren’t the only way you can create custom types: let’s turn to
Cairo’s enum feature to add another tool to your toolbox.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch04-02-an-example-program-using-structs.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="ch05-00-enums-and-pattern-matching.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch04-02-an-example-program-using-structs.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="ch05-00-enums-and-pattern-matching.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
