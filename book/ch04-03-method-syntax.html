<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Sintaxis de métodos - El lenguaje de programación Cairo </title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">El lenguaje de programación Cairo</a></li><li class="chapter-item expanded affix "><a href="ch00-01-foreword.html">Prólogo</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Introducción</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Cómo empezar</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Instalación</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hola, Mundo!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-scarb.html"><strong aria-hidden="true">1.3.</strong> Hola, Scarb!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-common-programming-concepts.html"><strong aria-hidden="true">2.</strong> Conceptos comunes de programación</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch02-01-variables-and-mutability.html"><strong aria-hidden="true">2.1.</strong> Variables y mutabilidad</a></li><li class="chapter-item expanded "><a href="ch02-02-data-types.html"><strong aria-hidden="true">2.2.</strong> Tipos de datos</a></li><li class="chapter-item expanded "><a href="ch02-03-functions.html"><strong aria-hidden="true">2.3.</strong> Funciones</a></li><li class="chapter-item expanded "><a href="ch02-04-comments.html"><strong aria-hidden="true">2.4.</strong> Comentarios</a></li><li class="chapter-item expanded "><a href="ch02-05-control-flow.html"><strong aria-hidden="true">2.5.</strong> Flujo de control</a></li></ol></li><li class="chapter-item expanded "><a href="ch03-00-understanding-ownership.html"><strong aria-hidden="true">3.</strong> Comprender Ownership</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-what-is-ownership.html"><strong aria-hidden="true">3.1.</strong> ¿Qué es Ownership?</a></li><li class="chapter-item expanded "><a href="ch03-02-references-and-snapshots.html"><strong aria-hidden="true">3.2.</strong> Referencias y Snapshots</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-using-structs-to-structure-related-data.html"><strong aria-hidden="true">4.</strong>  Uso de estructuras para estructurar datos relacionados</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-defining-and-instantiating-structs.html"><strong aria-hidden="true">4.1.</strong> Definición e instanciación de estructuras</a></li><li class="chapter-item expanded "><a href="ch04-02-an-example-program-using-structs.html"><strong aria-hidden="true">4.2.</strong> Un programa de ejemplo usando estructuras</a></li><li class="chapter-item expanded "><a href="ch04-03-method-syntax.html" class="active"><strong aria-hidden="true">4.3.</strong> Sintaxis de métodos</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-enums-and-pattern-matching.html"><strong aria-hidden="true">5.</strong> Enums y Concordancia de Patrones</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-enums.html"><strong aria-hidden="true">5.1.</strong> Enums</a></li><li class="chapter-item expanded "><a href="ch05-02-the-match-control-flow-construct.html"><strong aria-hidden="true">5.2.</strong> La construcción del flujo de control de coincidencias</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-managing-cairo-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">6.</strong> Gestionando Proyectos Cairo con Paquetes, Crates y Módulos</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-packages-and-crates.html"><strong aria-hidden="true">6.1.</strong> Paquetes y Crates</a></li><li class="chapter-item expanded "><a href="ch06-02-defining-modules-to-control-scope.html"><strong aria-hidden="true">6.2.</strong> Definición de módulos para controlar el alcance</a></li><li class="chapter-item expanded "><a href="ch06-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">6.3.</strong> Rutas para referirse a un elemento en el Arbol de Módulos</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-generic-types.html"><strong aria-hidden="true">7.</strong> Tipos de datos Genéricos</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-generic-data-types.html"><strong aria-hidden="true">7.1.</strong> Funciones genéricas</a></li><li class="chapter-item expanded "><a href="ch07-02-traits-in-cairo.html"><strong aria-hidden="true">7.2.</strong> Traits en Cairo</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-testing-cairo-programs.html"><strong aria-hidden="true">8.</strong> Probando programas de Cairo</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-how-to-write-tests.html"><strong aria-hidden="true">8.1.</strong> Cómo escribir Tests</a></li><li class="chapter-item expanded "><a href="ch09-02-test-organization.html"><strong aria-hidden="true">8.2.</strong> Organización de Testing</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">9.</strong> Apéndice</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">9.1.</strong> A - Herramientas de desarrollo útiles</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">El lenguaje de programación Cairo </h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="method-syntax"><a class="header" href="#method-syntax">Sintaxis de métodos</a></h2>
<p>Los métodos son similares a las funciones: los declaramos con la palabra clave <code>fn</code> y un nombre, pueden tener parámetros, retornar un valor, y contener código que se ejecuta cuando el método es llamado desde otro lugar. A diferencia de las funciones, los métodos se definen dentro del contexto de un tipo y su primer parámetro siempre es <code>self</code>, que representa la instancia del tipo al que se llama el método. Para aquellos familiarizados con Rust, el enfoque de Cairo puede resultar confuso, ya que los métodos no se pueden definir directamente en los tipos. En su lugar, debe definir un rasgo y una implementación asociados con el tipo para el que está destinado el método.</p>
<h3 id="defining-methods"><a class="header" href="#defining-methods">Definición de métodos</a></h3>
<p>Cambiemos la función <code>area</code> que tiene una instancia de <code>Rectangle</code> como parámetro y en su lugar crea un método <code>area</code> definido en el <em>trait</em> <code>RectangleTrait</code>, como se muestra en el Listado 5-13. </p>
<p><span class="filename">Filename: src/lib.cairo</span></p>
<pre><code class="language-rust">use debug::PrintTrait;
#[derive(Copy, Drop)]
struct Rectangle {
    width: u64,
    height: u64,
}

trait RectangleTrait {
    fn area(self: @Rectangle) -&gt; u64;
}

impl RectangleImpl of RectangleTrait {
    fn area(self: @Rectangle) -&gt; u64 {
        (*self.width) * (*self.height)
    }
}

fn main() {
    let rect1 = Rectangle { width: 30_u64, height: 50_u64,  };

    rect1.area().print();
}</code></pre>
<p><span class="caption">Listing 4-13: Definiendo el método <code>area</code> para usar en la estructura <code>Rectangle</code> </span></p>

<p>Para definir la función dentro del contexto de <code>Rectangle</code>, comenzamos definiendo un <code>trait</code>
    con la declaración del método que queremos implementar. Los <em>Traits</em> no están vinculados a
    un tipo específico; solo el parámetro <code>self</code> del método define qué tipo se puede usar
    con dicho <em>trait</em>. Luego, definimos un bloque con la palabra clave <code>impl</code> para <code>RectangleTrait</code>, que define
    el comportamiento de los métodos implementados. Todo dentro de este bloque <code>impl</code> será
    asociado con el tipo del parámetro <code>self</code> del método llamado. Si bien es técnicamente
    posible definir métodos para múltiples tipos dentro del mismo bloque <code>impl</code>, no es
    una práctica recomendada, ya que puede producir una confusión. Recomendamos que el tipo del parámetro <code>self</code>
    permanece consistente dentro del mismo bloque <code>impl</code>.
    Luego movemos la función <code>area</code> dentro de los corchetes <code>impl</code> y cambiamos el primer (y en este caso, único)
    parámetro para ser <code>self</code> en la declaración y en todas partes dentro del cuerpo. En
    <code>main</code>, donde llamamos a la función <code>area</code> y pasamos <code>rect1</code> como argumento,
    en su lugar, podemos usar la <em>sintaxis del método</em> para llamar al método <code>area</code> en nuestra instancia del <code>Rectangle</code>. 
    La sintaxis del método va después de una instancia: agregamos un punto seguido de
    el nombre del método, los paréntesis y los argumentos.</p>

<p>Los métodos deben tener un parámetro llamado <code>self</code> del tipo al que se aplicarán para su primer parámetro.
    Tenga en cuenta que usamos el operador <code>@</code> (<em>snapshot</em>) delante del tipo <code>Rectangle</code> en la declaración de la función.
    Al hacerlo, indicamos que este método toma un <em>snapshot</em> inmutable de la instancia de <code>Rectangle</code>, que es
    creado automáticamente por el compilador al pasar la instancia al método.
    Los métodos pueden tomar posesión de <code>self</code>, usar <code>self</code> con <em>snapshot</em> como lo hemos hecho aquí, o usar una referencia mutable a <code>self</code>
    utilizando la sintaxis <code>ref self: T</code>.</p>

<p>Elegimos <code>self: @Rectangle</code> por la misma razón que usamos <code>@Rectangle</code> en la función
    versión: no queremos tomar posesión, y solo queremos leer los datos en
    la estructura, no escribir en ella. Si quisiéramos cambiar la instancia que hemos
    llamado al método como parte de lo que hace el método, usaríamos <code>ref self: Rectangle</code> como
    el primer parámetro. Tener un método que tome posesión de la instancia por
    usar solo <code>self</code> como primer parámetro es raro; esta técnica suele ser usada
     cuando el método transforma <code>self</code> en otra cosa y desea
    evitar que la persona que llama use la instancia original después de la transformación.</p>

<p>Observe el uso del operador <em>desnap</em> <code>*</code> dentro del método <em>area</em> cuando accede a los miembros de la estructura.
    Esto es necesario porque la estructura se pasa como una <em>snapshot</em> y todos sus valores de campo son del tipo <code>@T</code>,
    requiriendo que sean <em>desnapped</em> para poder manipularlos.</p>


<p>La principal razón para usar métodos en lugar de funciones es la organización y la claridad del código. Hemos puesto todas las cosas que podemos hacer con una instancia de un tipo en una combinación de bloques de tipo <code>trait</code> &amp; <code>impl</code>, en lugar de hacer que los futuros usuarios
    de nuestro código busquen capacidades de <code>Rectangle</code> en varios lugares en la
    biblioteca que ofrecemos. Sin embargo, podemos definir múltiples combinaciones de <code>trait</code> &amp; <code>impl</code> para el mismo tipo en diferentes lugares, lo que puede ser útil para organizar nuestro código. Por ejemplo, podría implementar
    el <em>trait</em> <code>Add</code> para su tipo en un bloque <code>impl</code>, y el <em>trait</em> <code>Sub</code> en otro bloque.</p>




<p>Note that we can choose to give a method the same name as one of the struct’s
fields. For example, we can define a method on <code>Rectangle</code> that is also named
<code>width</code>:</p>

<p>Tenga en cuenta que podemos optar por dar a un método el mismo nombre que uno de los campos de la estructura. 
    Por ejemplo, podemos definir un método en <code>Rectangle</code> que también se llama
    <code>width</code>:</p>

<p><span class="filename">Filename: src/lib.cairo</span></p>
<pre><code class="language-rust">use debug::PrintTrait;
#[derive(Copy, Drop)]
struct Rectangle {
    width: u64,
    height: u64,
}

trait RectangleTrait {
    fn width(self: @Rectangle) -&gt; bool;
}

impl RectangleImpl of RectangleTrait {
    fn width(self: @Rectangle) -&gt; bool {
        (*self.width) &gt; 0_u64
    }
}

fn main() {
    let rect1 = Rectangle { width: 30_u64, height: 50_u64,  };
    rect1.width().print();
}</code></pre>

<p>Aquí, elegimos hacer que el método <code>width</code> devuelva <code>true</code> si el valor en
    el campo <code>width</code> de la instancia es mayor que <code>0</code> y <code>false</code> si el valor es
    <code>0</code>: podemos usar un campo dentro de un método del mismo nombre para cualquier propósito. En
    <code>main</code>, cuando seguimos <code>rect1.width</code> entre paréntesis, Cairo sabe que nos referimos al
    método <code>ancho</code>. Cuando no usamos paréntesis, Cairo sabe que nos referimos al campo
    <código>ancho</código>.</p>

<h3 id="methods-with-more-parameters"><a class="header" href="#methods-with-more-parameters">Métodos con más parámetros</a></h3>

<p>Practiquemos el uso de métodos implementando un segundo método en la estructura <code>Rectangle</code>.
    Esta vez queremos que una instancia de <code>Rectangle</code> tome otra instancia
    de <code>Rectangle</code> y devolver <code>true</code> si el segundo <code>Rectangle</code> puede caber completamente
    dentro de <code>self</code> (el primer <code>Rectangle</code>); de lo contrario, debería devolver <code>false</code>.
    Es decir, una vez que hemos definido el método <code>can_hold</code>, queremos poder escribir
    el programa que se muestra en el Listado 5-14.</p>

<p><span class="filename">Filename: src/lib.cairo</span></p>
<pre><code class="language-swift">use debug::PrintTrait;
#[derive(Copy, Drop)]
struct Rectangle {
    width: u64,
    height: u64,
}


fn main() {
    let rect1 = Rectangle {
        width: 30_u64,
        height: 50_u64,
    };
    let rect2 = Rectangle {
        width: 10_u64,
        height: 40_u64,
    };
    let rect3 = Rectangle {
        width: 60_u64,
        height: 45_u64,
    };

    'Can rect1 hold rect2?'.print();
    rect1.can_hold(@rect2).print();

    'Can rect1 hold rect?'.print();
    rect1.can_hold(@rect3).print();
}
</code></pre>
<p><span class="caption">Listing 5-14: Usando el método todavia no escrito <code>can_hold</code></span></p>
<p>La salida esperada sería similar a la siguiente porque ambas dimensiones de
    <code>rect2</code> son más pequeñas que las dimensiones de <code>rect1</code>, pero <code>rect3</code> es más ancha que
    <código>rect1</código>:</p>

<pre><code class="language-text">❯ cairo-run src/lib.cairo
[DEBUG]	Can rec1 hold rect2?           	(raw: 384675147322001379018464490539350216396261044799)

[DEBUG]	true                           	(raw: 1953658213)

[DEBUG]	Can rect1 hold rect?           	(raw: 384675147322001384331925548502381811111693612095)

[DEBUG]	false                          	(raw: 439721161573)

</code></pre>

<p>Sabemos que queremos definir un método, por lo que estará dentro del bloque <code>trait RectangleTrait</code>
    y <code>impl RectangleImpl of RectangleTrait</code>.
    El nombre del método será <code>can_hold</code>, y tomará una <em>snapshot</em>
    de otro <code>Rectangle</code> como parámetro. Podemos decir cuál será el tipo de parámetro si miramos el código que llama al método:
    <code>rect1.can_hold(@rect2)</code> pasa <code>@rect2</code>, que es un <em>snapshot</em> para
    <code>rect2</code>, una instancia de <code>Rectangle</code>. Esto tiene sentido porque solo necesitamos
    leer <code>rect2</code> (en lugar de escribir, lo que significaría que necesitaríamos un préstamo mutable),
    y queremos que <code>main</code> conserve la propiedad de <code>rect2</code> para que podamos usarlo nuevamente después
    llamando al método <code>can_hold</code>. El valor de retorno de <code>can_hold</code> será un
    Boolean, y la implementación verificará si el ancho y la altura de
    <code>self</code> son mayores que el ancho y alto del otro <code>Rectangle</code>,
    respectivamente. Agreguemos el nuevo método <code>can_hold</code> a los bloques <code>trait</code> y <code>impl</code> del
    Listado 5-13, mostrado en el Listado 5-15.</p>

<p><span class="filename">Filename: src/lib.cairo</span></p>
<pre><code class="language-rust">trait RectangleTrait {
    fn area(self: @Rectangle) -&gt; u64;
    fn can_hold(self: @Rectangle, other: @Rectangle) -&gt; bool;
}

impl RectangleImpl of RectangleTrait {
    fn area(self: @Rectangle) -&gt; u64 {
        *self.width * *self.height
    }

    fn can_hold(self: @Rectangle, other: @Rectangle) -&gt; bool {
        *self.width &gt; *other.width &amp; *self.height &gt; *other.height
    }
}</code></pre>
<p><span class="caption">Listing 5-15: Implementación del método <code>can_hold</code> en
<code>Rectangle</code> que recibe una instancia de <code>Rectangle</code> como parámetro</span></p>


<p>Cuando ejecutamos este código con la función <code>main</code> en el Listado 5-14, obtendremos nuestro
    salida deseada. Los métodos pueden tomar múltiples parámetros que agregamos a su definición 
    después del parámetro <code>self</code>, y esos parámetros funcionan como
    parámetros en funciones.</p>

<h3 id="accessing-implementation-functions"><a class="header" href="#accessing-implementation-functions">Acceso a las funciones de implementación</a></h3>

<p>Todas las funciones definidas dentro de un bloque <code>trait</code> e <code>impl</code> se pueden abordar directamente
    utilizando el operador <code>::</code> en el nombre de la implementación.
    Las funciones en los <em>trait</em> que no son métodos a menudo se usan para constructores que
    devolverá una nueva instancia de la estructura. Estos a menudo se denominan <code>new</code>, pero
    <code>new</code> no es un nombre especial y no está integrado en el lenguaje de Cairo. Por ejemplo, nosotros
    podría optar por proporcionar una función asociada llamada <code>square</code> que tendría
    un parámetro de dimensión y usarlo como ancho y alto, haciéndolo así
    más fácil para crear un cuadrado con <code>Rectangle</code> en lugar de tener que especificar el mismo
    valor dos veces:</p>


<p><span class="filename">Filename: src/lib.cairo</span></p>
<pre><code class="language-rust">trait RectangleTrait {
    fn square(size:u64) -&gt; Rectangle;
}

impl RectangleImpl of RectangleTrait {
    fn square(size: u64) -&gt; Rectangle {
        Rectangle { width: size, height: size }
    }
}</code></pre>

<p>To call this function, we use the <code>::</code> syntax with the implementation name;
<code>let square = RectangleImpl::square(10_u64);</code> is an example. This function is namespaced by
the implementation: the <code>::</code> syntax is used for both trait functions and
namespaces created by modules. We’ll discuss modules in [Chapter 7][modules]<!-- ignore -->.</p>

<p> Para llamar a esta función, usamos la sintaxis <code>::</code> con el nombre de implementación;
    <code>let square = RectangleImpl::square(10_u64);</code> es un ejemplo. Esta función está espaciada por
    la implementación: la sintaxis <code>::</code> se usa tanto para funciones del <em>trait</em> y   
    espacios de nombres creados por módulos. Lo discutiremos en el [Capítulo 7][modules]<!-- ignore -->.</p>

<blockquote>
<p>Nota: También es posible llamar a esta función usando el nombre del <em>trait</em>, con <code>RectangleTrait::square(10_u64)</code>.</p>
</blockquote>
<h3 id="multiple-impl-blocks"><a class="header" href="#multiple-impl-blocks">Multiples bloques con <code>impl</code></a></h3>

<p>Cada estructura tiene permitido tener múltiples bloques con <code>trait</code> e <code>impl</code>. Por ejemplo, en el Listado 5-15 es equivalente
    al código mostrado en el Listado 5-16, que tiene cada método en su propio bloque de <code>trait</code> e <code>impl</code>.</p>
<pre><code class="language-rust">trait RectangleCalc {
    fn area(self: @Rectangle) -&gt; u64;
}
impl RectangleCalcImpl of RectangleCalc {
    fn area(self: @Rectangle) -&gt; u64 {
        (*self.width) * (*self.height)
    }
}

trait RectangleCmp {
    fn can_hold(self: @Rectangle, other: @Rectangle) -&gt; bool;
}

impl RectangleCmpImpl of RectangleCmp {
    fn can_hold(self: @Rectangle, other: @Rectangle) -&gt; bool {
        *self.width &gt; *other.width &amp; *self.height &gt; *other.height
    }
}</code></pre>
<p><span class="caption">Listing 5-16: Reescribiendo el Listado 5-15 usando múltiples bloques de <code>impl</code></span></p>

<p>No hay razón para separar estos métodos en múltiples bloques de <code>trait</code> e <code>impl</code>, pero es una sintaxis válida. 
Veremos un caso en el que usar múltiples bloques es adecuado en el <a href="ch07-00-generic-types-and-traits.html">Capítulo 7</a>, donde discutimos tipos y <em>traits</em> genéricos.</p>

<h2 id="summary"><a class="header" href="#summary">Resumen</a></h2>

<p>Las estructuras permiten crear tipos personalizados que son significativos para su dominio. Usando estructuras, 
    puede mantener partes de datos asociadas conectadas entre sí
    y nombra cada pieza para que tu código quede claro. En los bloques <code>trait</code> e <code>impl</code>, puedes definir
    métodos, que son funciones asociadas a un tipo y le permiten especificar el comportamiento que las instancias de su
    tipo pueden tener</p>

<p>Pero las estructuras (<code>struct</code>) no son la única manera de crear tipos personalizados: pasemos a
    La función de enumeración (<code>enum</code>) de Cairo para agregar otra herramienta.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch04-02-an-example-program-using-structs.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="ch05-00-enums-and-pattern-matching.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch04-02-an-example-program-using-structs.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="ch05-00-enums-and-pattern-matching.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
